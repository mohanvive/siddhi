{
    "docs": [
        {
            "location": "/", 
            "text": "Siddhi\n\n\n\n  \n\n  \n\n  \n\n  \n\n  \n\n\nSiddhi is a \nStreaming\n and \nComplex Event Processing\n engine that listens to events from data streams, detects complex conditions described via a \nStreaming\n SQL language\n, and triggers actions.   \n\n\nOverview\n\n\n\n\nSiddhi supports:\n\n\n\n\n\n\nStreaming data integration \n\n\n\n\nRetrieving data from various event sources (Kafka, NATS, JMS, HTTP, CDC, etc)\n\n\nMap events to and from multiple event formats (JSON, XML, Text, Avro, etc)\n\n\nData preprocessing \n cleaning\n\n\nJoining multiple data streams \n\n\nIntegrate streaming data with databases (RDBMS, Cassandra, HBase, Redis, etc)\n\n\nIntegrate with external services\n\n\nPublish data to multiple event sinks (Email, JMS, HTTP, etc)\n\n\n\n\n\n\n\n\nStreaming data analytics\n\n\n\n\nGenerating alerts based on thresholds\n\n\nCalculate aggregations over a short windows (time, length, session, unique, etc) or a long time period\n\n\nCalculate aggregations over long time periods with seconds, minutes, hours, days, months \n years granularity  \n\n\nCorrelating data while finding missing and erroneous events\n\n\nDetecting temporal event patterns\n\n\nAnalyzing trends (rise, fall, turn, tipple bottom)\n\n\nRun pretreated machine learning models (PMML, Tensorflow) \n\n\nLearn and predict at runtime using online machine learning models\n\n\n\n\n\n\n\n\nAdaptive Intelligence\n\n\n\n\nStatic rule processing \n\n\nStateful rule processing \n\n\nDecision making through synchronous stream processing  \n\n\nQuery tables, windows and aggregations  \n\n\n\n\n\n\n\n\nAnd many more ...  For more information, see \nPatterns of Streaming Realtime Analytics\n\n\n\n\n\n\nSiddhi is free and open source, under \nApache Software License v2.0\n.\n\n\nGet Started!\n\n\nGet started with Siddhi in a few minutes by following the \nSiddhi Quick Start Guide\n\n\nWhy use Siddhi ?\n\n\n\n\nIt is \nfast\n. \nUBER\n \nuses it to process 20 Billion events per day (300,000 events per second). \n\n\nIt is \nlightweight\n (\n2MB),  and embeddable in Android, Python and RaspberryPi.\n\n\nIt has \nover 50 \nSiddhi Extensions\n\n\nIt is \nused by over 60 companies including many Fortune 500 companies\n in production. Following are some examples:\n\n\nWSO2\n uses Siddhi for the following purposes:\n\n\nTo provide stream processing capabilities in their products such as \nWSO2 Stream Processor\n.\n\n\nAs the \nedge analytics\n library of \nWSO2 IoT Server\n.\n\n\nAs the core of \nWSO2 API Manager\n's throttling. \n\n\nAs the core of \nWSO2 products'\n analytics.\n\n\n\n\n\n\nUBER\n uses Siddhi for fraud analytics.\n\n\nApache Eagle\n uses Siddhi as a policy engine.\n\n\n\n\n\n\nSolutions based on Siddhi have been \nfinalists at \nACM DEBS Grand Challenge Stream Processing competitions\n in 2014, 2015, 2016, 2017\n.\n\n\nSiddhi has been \nthe basis of many academic research projects\n and has \nover 60 citations\n. \n\n\n\n\nIf you are a Siddhi user, we would love to hear more. \n\n\nDevelop Siddhi using IntelliJ IDEA\n\n\nInstall \nIDEA plugin\n to get the following features:\n\n\n\n\nSiddhi Query Editor\n with syntax highlighting and with basic auto completion\n\n\nSiddhi Runner and Debugger\n support to test Siddhi Application\n\n\n\n\nTry Siddhi with \nWSO2 Stream Processor\n\n\nWSO2 Stream Processor\n is a server version of Siddhi that is also released under \n \nApache Software License v2.0\n. It was a Strong Performer in \nThe Forrester Wave: Big Data Streaming Analytics, Q1 2016\n \n (\nReport\n) \nand a \nCool Vendors in Internet of Things Analytics, 2016\n. \n\n\nIf you use \nWSO2 Stream Processor\n, you can use the Siddhi functionality with the following additional features:  \n\n\n\n\nThe \nSiddhi Query Editor\n tool with syntax highlighting and advanced auto completion support\n\n\nThe \nSiddhi Runner and Debugger\n tool\n\n\nThe \nEvent Simulator\n  tool\n\n\nRun Siddhi as a \nserver\n with \nhigh availability\n and \nscalability\n.\n\n\nMonitoring support for Siddhi\n\n\nRealtime dashboard \n\n\nBusiness user-friendly query generation and deployment\n\n\n\n\nThere are domain specific solutions built using Siddhi, including \nFraud Detection, Stock Market Surveillance, Location analytics, Proximity Marketing, Contextual Recommendation, Ad Optimization, Operational Analytics, and Detecting Chart Patterns\n. \n\n\nFor more information please contact us via \nhttp://wso2.com/support/\n.\n\n\nSiddhi Versions\n\n\n \n\n\n\n\n\n\nActive development version of Siddhi\n : \nv5.0.0\n  \nbuilt on Java 8 \n 11.\n \n\n\nFind the released Siddhi libraries \nhere\n.\n\n\nSiddhi Query Guide\n for Siddhi v5.x.x\n\n\nArchitecture\n of Siddhi v5.x.x\n\n\n\n\n\n\nLatest Stable Release of Siddhi v4.x.x\n : \nv4.4.8\n \nbuilt on Java 8. (Recommended for production use)\n\n\nFind the released Siddhi libraries \nhere\n.\n\n\nSiddhi Query Guide\n for Siddhi v4.x.x\n\n\nArchitecture\n of Siddhi v4.x.x\n\n\n\n\n\n\nLatest Stable Release of Siddhi v3.x.x\n : \nv3.2.3\n \nbuilt on Java 7.\n\n\nFind the released Siddhi libraries \nhere\n.\n\n\nSiddhi Query Guide\n for Siddhi v3.x.x\n\n\n\n\n\n\nLatest API Docs\n\n\nLatest API Docs is \n5.0.1-SNAPSHOT\n.\n\n\nHow to Contribute\n\n\n\n\nReport issues at \nGitHub Issue Tracker\n.\n\n\nFeel free to try out the \nSiddhi source code\n and send your contributions as pull requests to the \nmaster branch\n.\n\n\n\n\nBuild from the Source\n\n\nPrerequisites\n\n\n\n\nOracle JDK 8\n or \nOpenJDK 8\n (Java 8 should be used for building in order to support both Java 8 and Java 11 at runtime)\n\n\nMaven 3.5.x version\n\n\n\n\nSteps to Build\n\n\n\n\n\n\nGet a clone or download source from \nGithub\n\n\nbash\ngit clone https://github.com/siddhi-io/siddhi.git\n\n\n\n\n\n\nRun the Maven command \nmvn clean install\n from the root directory\n\n\n\n\n\n\nContact us\n\n\n\n\nPost your questions with the \n\"Siddhi\"\n tag in \nStackoverflow\n. \n\n\nFor more details and support contact us via \nhttp://wso2.com/support/\n\n\n\n\nSupport\n\n\n\n\nWe are committed to ensuring support for Siddhi (with its \nextensions\n) and \nWSO2 Stream Processor\n from development to production.\n\n\nOur unique approach ensures that all support leverages our open development methodology and is provided by the very same engineers who build the technology. \n\n\nFor more details and to take advantage of this unique opportunity, contact us via \nhttp://wso2.com/support/\n. \n\n\n\n\nSiddhi was joint research project initiated by \nWSO2\n and \nUniversity of Moratuwa\n, Sri Lanka.", 
            "title": "Welcome to Siddhi"
        }, 
        {
            "location": "/#siddhi", 
            "text": "Siddhi is a  Streaming  and  Complex Event Processing  engine that listens to events from data streams, detects complex conditions described via a  Streaming\n SQL language , and triggers actions.", 
            "title": "Siddhi"
        }, 
        {
            "location": "/#overview", 
            "text": "Siddhi supports:    Streaming data integration    Retrieving data from various event sources (Kafka, NATS, JMS, HTTP, CDC, etc)  Map events to and from multiple event formats (JSON, XML, Text, Avro, etc)  Data preprocessing   cleaning  Joining multiple data streams   Integrate streaming data with databases (RDBMS, Cassandra, HBase, Redis, etc)  Integrate with external services  Publish data to multiple event sinks (Email, JMS, HTTP, etc)     Streaming data analytics   Generating alerts based on thresholds  Calculate aggregations over a short windows (time, length, session, unique, etc) or a long time period  Calculate aggregations over long time periods with seconds, minutes, hours, days, months   years granularity    Correlating data while finding missing and erroneous events  Detecting temporal event patterns  Analyzing trends (rise, fall, turn, tipple bottom)  Run pretreated machine learning models (PMML, Tensorflow)   Learn and predict at runtime using online machine learning models     Adaptive Intelligence   Static rule processing   Stateful rule processing   Decision making through synchronous stream processing    Query tables, windows and aggregations       And many more ...  For more information, see  Patterns of Streaming Realtime Analytics    Siddhi is free and open source, under  Apache Software License v2.0 .", 
            "title": "Overview"
        }, 
        {
            "location": "/#get-started", 
            "text": "Get started with Siddhi in a few minutes by following the  Siddhi Quick Start Guide", 
            "title": "Get Started!"
        }, 
        {
            "location": "/#why-use-siddhi", 
            "text": "It is  fast .  UBER  \nuses it to process 20 Billion events per day (300,000 events per second).   It is  lightweight  ( 2MB),  and embeddable in Android, Python and RaspberryPi.  It has  over 50  Siddhi Extensions  It is  used by over 60 companies including many Fortune 500 companies  in production. Following are some examples:  WSO2  uses Siddhi for the following purposes:  To provide stream processing capabilities in their products such as  WSO2 Stream Processor .  As the  edge analytics  library of  WSO2 IoT Server .  As the core of  WSO2 API Manager 's throttling.   As the core of  WSO2 products'  analytics.    UBER  uses Siddhi for fraud analytics.  Apache Eagle  uses Siddhi as a policy engine.    Solutions based on Siddhi have been  finalists at  ACM DEBS Grand Challenge Stream Processing competitions  in 2014, 2015, 2016, 2017 .  Siddhi has been  the basis of many academic research projects  and has  over 60 citations .    If you are a Siddhi user, we would love to hear more.", 
            "title": "Why use Siddhi ?"
        }, 
        {
            "location": "/#develop-siddhi-using-intellij-idea", 
            "text": "Install  IDEA plugin  to get the following features:   Siddhi Query Editor  with syntax highlighting and with basic auto completion  Siddhi Runner and Debugger  support to test Siddhi Application", 
            "title": "Develop Siddhi using IntelliJ IDEA"
        }, 
        {
            "location": "/#try-siddhi-with-wso2-stream-processor", 
            "text": "WSO2 Stream Processor  is a server version of Siddhi that is also released under \n  Apache Software License v2.0 . It was a Strong Performer in  The Forrester Wave: Big Data Streaming Analytics, Q1 2016  \n ( Report ) \nand a  Cool Vendors in Internet of Things Analytics, 2016 .   If you use  WSO2 Stream Processor , you can use the Siddhi functionality with the following additional features:     The  Siddhi Query Editor  tool with syntax highlighting and advanced auto completion support  The  Siddhi Runner and Debugger  tool  The  Event Simulator   tool  Run Siddhi as a  server  with  high availability  and  scalability .  Monitoring support for Siddhi  Realtime dashboard   Business user-friendly query generation and deployment   There are domain specific solutions built using Siddhi, including  Fraud Detection, Stock Market Surveillance, Location analytics, Proximity Marketing, Contextual Recommendation, Ad Optimization, Operational Analytics, and Detecting Chart Patterns .   For more information please contact us via  http://wso2.com/support/ .", 
            "title": "Try Siddhi with WSO2 Stream Processor"
        }, 
        {
            "location": "/#siddhi-versions", 
            "text": "Active development version of Siddhi  :  v5.0.0    built on Java 8   11.    Find the released Siddhi libraries  here .  Siddhi Query Guide  for Siddhi v5.x.x  Architecture  of Siddhi v5.x.x    Latest Stable Release of Siddhi v4.x.x  :  v4.4.8   built on Java 8. (Recommended for production use)  Find the released Siddhi libraries  here .  Siddhi Query Guide  for Siddhi v4.x.x  Architecture  of Siddhi v4.x.x    Latest Stable Release of Siddhi v3.x.x  :  v3.2.3   built on Java 7.  Find the released Siddhi libraries  here .  Siddhi Query Guide  for Siddhi v3.x.x", 
            "title": "Siddhi Versions"
        }, 
        {
            "location": "/#latest-api-docs", 
            "text": "Latest API Docs is  5.0.1-SNAPSHOT .", 
            "title": "Latest API Docs"
        }, 
        {
            "location": "/#how-to-contribute", 
            "text": "Report issues at  GitHub Issue Tracker .  Feel free to try out the  Siddhi source code  and send your contributions as pull requests to the  master branch .", 
            "title": "How to Contribute"
        }, 
        {
            "location": "/#build-from-the-source", 
            "text": "", 
            "title": "Build from the Source"
        }, 
        {
            "location": "/#prerequisites", 
            "text": "Oracle JDK 8  or  OpenJDK 8  (Java 8 should be used for building in order to support both Java 8 and Java 11 at runtime)  Maven 3.5.x version", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/#steps-to-build", 
            "text": "Get a clone or download source from  Github  bash\ngit clone https://github.com/siddhi-io/siddhi.git    Run the Maven command  mvn clean install  from the root directory", 
            "title": "Steps to Build"
        }, 
        {
            "location": "/#contact-us", 
            "text": "Post your questions with the  \"Siddhi\"  tag in  Stackoverflow .   For more details and support contact us via  http://wso2.com/support/", 
            "title": "Contact us"
        }, 
        {
            "location": "/#support", 
            "text": "We are committed to ensuring support for Siddhi (with its  extensions ) and  WSO2 Stream Processor  from development to production.  Our unique approach ensures that all support leverages our open development methodology and is provided by the very same engineers who build the technology.   For more details and to take advantage of this unique opportunity, contact us via  http://wso2.com/support/ .    Siddhi was joint research project initiated by  WSO2  and  University of Moratuwa , Sri Lanka.", 
            "title": "Support"
        }, 
        {
            "location": "/features/", 
            "text": "Features\n\n\n\n\nRetrieving Events \n\n\nFrom various data sources supporting multiple message formats\n\n\n\n\n\n\nMapping Events\n\n\nMapping events with various data formats to Stream for processing\n\n\nMapping streams to multiple data formats for publishing\n\n\n\n\n\n\nProcessing Streams\n\n\nFilter \n\n\nFiltering stream based on conditions\n\n\n\n\n\n\nWindow\n\n\nSupport for sliding and batch (tumbling) and many other type of windows  \n\n\n\n\n\n\nAggregation \n\n\nSupporting \nAvg\n, \nSum\n, \nMin\n, \nMax\n, etc\n\n\nFor long running aggregations and aggregation over windows \n\n\nAbility to perform aggregate processing with \nGroup by\n and filter aggregated data with \nHaving\n conditions\n\n\n\n\n\n\nIncremental Aggregation\n\n\nSupport for processing and retrieving long running Aggregation\n\n\nSupports data processing in seconds, minutes, hours, days, months, and years granularity\n\n\n\n\n\n\nTable and Stores\n\n\nFor storing events for future processing and retrieving them on demand\n\n\nSupporting storage in in-memory, RDBMs, Solr, mongoDb, etc \n\n\n\n\n\n\nJoin\n\n\nJoining two streams, two windows based on conditions \n\n\nJoining stream/window with table or incremental aggregation based on conditions  \n\n\nSupports inner joins, and left, right \n full outer joins\n\n\n\n\n\n\nPattern \n\n\nIdentifies event occurrence patterns among streams over time\n\n\nIdentify non occurrence of events\n\n\nSupports repetitive matches of event pattern occurrences with logical conditions and time bound\n\n\n\n\n\n\nSequence processing\n\n\nIdentifies continuous sequence of events from streams\n\n\nSupports zero to many, one to many, and zero to one event matching conditions\n\n\n\n\n\n\nPartitions\n\n\nGrouping queries and based on keywords or value ranges for isolated parallel processing\n\n\n\n\n\n\nScripting \n\n\nSupport writing scripts like JavaScript, Scala and R within Siddhi Queries\n\n\n\n\n\n\nProcess Based on event time\n\n\nWhole execution driven by the event time    \n\n\n\n\n\n\n\n\n\n\nPublishing Events \n\n\nTo various data sources with various message formats\n\n\nSupporting load balancing and failover data publishing \n\n\n\n\n\n\nError handling\n\n\nSupport errors and exceptions through error streams\n\n\nAutomatic backoff retries to external data stores, sources and sinks. \n\n\n\n\n\n\nParallel processing \n\n\nSupport parallel processing through asynchronous multithreading at streams  \n\n\n\n\n\n\nSnapshot and restore\n\n\nSupport for periodic state persistence and restore capabilities to allow state restore during failures", 
            "title": "Features"
        }, 
        {
            "location": "/features/#features", 
            "text": "Retrieving Events   From various data sources supporting multiple message formats    Mapping Events  Mapping events with various data formats to Stream for processing  Mapping streams to multiple data formats for publishing    Processing Streams  Filter   Filtering stream based on conditions    Window  Support for sliding and batch (tumbling) and many other type of windows      Aggregation   Supporting  Avg ,  Sum ,  Min ,  Max , etc  For long running aggregations and aggregation over windows   Ability to perform aggregate processing with  Group by  and filter aggregated data with  Having  conditions    Incremental Aggregation  Support for processing and retrieving long running Aggregation  Supports data processing in seconds, minutes, hours, days, months, and years granularity    Table and Stores  For storing events for future processing and retrieving them on demand  Supporting storage in in-memory, RDBMs, Solr, mongoDb, etc     Join  Joining two streams, two windows based on conditions   Joining stream/window with table or incremental aggregation based on conditions    Supports inner joins, and left, right   full outer joins    Pattern   Identifies event occurrence patterns among streams over time  Identify non occurrence of events  Supports repetitive matches of event pattern occurrences with logical conditions and time bound    Sequence processing  Identifies continuous sequence of events from streams  Supports zero to many, one to many, and zero to one event matching conditions    Partitions  Grouping queries and based on keywords or value ranges for isolated parallel processing    Scripting   Support writing scripts like JavaScript, Scala and R within Siddhi Queries    Process Based on event time  Whole execution driven by the event time          Publishing Events   To various data sources with various message formats  Supporting load balancing and failover data publishing     Error handling  Support errors and exceptions through error streams  Automatic backoff retries to external data stores, sources and sinks.     Parallel processing   Support parallel processing through asynchronous multithreading at streams      Snapshot and restore  Support for periodic state persistence and restore capabilities to allow state restore during failures", 
            "title": "Features"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/", 
            "text": "Siddhi 5.x Quick Start Guide\n\n\nSiddhi\n is a 100% open source Java library that is thoroughly optimized for high performance. \nIt performs \nStream Processing\n and \nComplex Event Processing\n on real time data streams. \n\n\nSiddhi is used by many companies including Uber and eBay (via Apache Eagle). \nUber processes more than 20 billion \nevents per day using Siddhi\n for fraud analytics, and Siddhi is used in Apache Eagle as a policy enforcement engine.\n\n\nThis quick start guide contains the following six sections:\n\n\n\n\nStream Processing and Complex Event Processing Overview - about the \ndomain\n of Siddhi\n\n\nAn Overview of Siddhi - Explaining the basic \narchitecture\n\n\nUsing Siddhi for the First Time - how to \nset up\n the software\n\n\nSiddhi \u2018Hello World!\u2019 - Your \nFirst Siddhi Application\n\n\nSimulating Events - \nTesting\n your query with simulated events\n\n\nA Bit of Stream Processing - \ntemporal event processing\n\n\n\n\n1. Stream Processing and Complex Event Processing (CEP) Overview\n\n\nBefore diving into using Siddhi, let's first discuss Stream Processing \nand Complex Event Processing in brief so that we can identify the use-cases where Siddhi can be used.\n\n\nFirst let's understand what an event is through an example. \nIf we consider the transactions carried out via an ATM as a data \nstream, one withdrawal from it can be considered an event\n. This event contains data about the amount, time, account number etc. \nMany such transactions form a stream.\n\n\n\n\nForrester\n defines Streaming Analytics as:\n\n\n\n\nSoftware that provides analytical operators to \norchestrate data flow\n, \ncalculate analytics\n, and \ndetect patterns\n on \nevent data \nfrom multiple, disparate live data sources\n to allow developers to build applications that \nsense, think, \nand act in real time\n.\n\n\n\n\nGartner\u2019s IT Glossary\n defines CEP as follows:\n\n\n\n\n\"CEP is a kind of computing in which \nincoming data about events is distilled into more useful, higher level \u201ccomplex\u201d \nevent data\n that provides insight into what is happening.\"\n\n\n\"\nCEP is event-driven\n because the computation is triggered by the receipt of event data. CEP is used for highly \ndemanding, continuous-intelligence applications that enhance situation awareness and support real-time decisions.\"\n\n\n\n\n\n\nBasically, Siddhi receives data event-by-event and processes them in real time to produce meaningful information.\n\n\nSiddhi Can be used in the following use-cases:\n\n\n\n\nFraud Analytics \n\n\nMonitoring \n\n\nAnomaly Detection\n\n\nSentiment Analysis\n\n\nProcessing Customer Behaviour\n\n\n.. etc\n\n\n\n\n2. Overview of Siddhi\n\n\n\n\nAs indicated above, Siddhi can:\n\n\n\n\naccept event inputs from many different types of sources\n\n\nprocess them to generate insights\n\n\npublish them to many types of sinks.\n\n\n\n\nTo use Siddhi, you need to write the processing logic as a \nSiddhi Application\n in the \nSiddhi Streaming SQL\n \nlanguage which is discussed in the 4th section. After writing and starting \na Siddhi application\n, it:\n\n\n\n\nTakes data one-by-one as events\n\n\nProcesses the data in each event\n\n\nGenerates new high level events based on the processing done so far\n\n\nSends newly generated events as the output to streams.\n\n\n\n\n3. Using Siddhi for the First Time\n\n\nIn this section, we will be using the WSO2 Stream Processor(referred to as SP in the rest of this guide)\u200a\u2014\u200aa server version of Siddhi that has a\nsophisticated editor with a GUI (referred to as \n\u201cStream Processor Studio\u201d\n) where you can write your query and simulate events\nas a data stream.\n\n\nStep 1\n\u200a\u2014\u200aInstall \n\nOracle Java SE Development Kit (JDK)\n version 1.8. \n\n\nStep 2\n\u200a\u2014\u200a\nSet the JAVA_HOME\n environment \nvariable. \n\n\nStep 3\n\u200a\u2014\u200aDownload the latest \nWSO2 Stream Processor\n. \n\n\nStep 4\n\u200a\u2014\u200aExtract the downloaded zip and navigate to \nSP_HOME\n/bin\n. \n (\nSP_HOME\n refers to the extracted folder) \n\n\nStep 5\n\u200a\u2014\u200aIssue the following command in the command prompt (Windows) / terminal (Linux) \n\n\nFor Windows: editor.bat\nFor Linux: ./editor.sh\n\n\n\n\n\nFor more details about WSO2 Stream Processor, see its \nQuick Start Guide\n.\n\n\nAfter successfully starting the Stream Processor Studio, the terminal in Linux should look like as shown below:\n\n\n\n\nAfter starting the WSO2 Stream Processor, access the Stream Processor Studio by visiting the following link in your browser.\n\n\nhttp://localhost:9390/editor\n\n\n\n\n\nThis takes you to the Stream Processor Studio landing page.\n\n\n\n\n4. Siddhi \u2018Hello World!\u2019\u200a\u2014\u200aYour First Siddhi Application\n\n\nSiddhi Streaming SQL is a rich, compact, easy-to-learn SQL-like language. \nLet's first learn how to find the total\n of values \ncoming into a data stream and output the current running total value with each event. Siddhi has lot of in-built functions and extensions \navailable for complex analysis, but to get started, let's use a simple one. You can find more information about the Siddhi grammar \nand its functions in the \nSiddhi Query Guide\n.\n\n\nLet's \nconsider a scenario where we are loading cargo boxes into a ship\n. We need to keep track of the total \nweight of the cargo added. \nMeasuring the weight of a cargo box when loading is considered an event\n.\n\n\n\n\nWe can write a Siddhi program for the above scenario which has \n4 parts\n.\n\n\nPart 1\u200a\u2014\u200aGiving our Siddhi application a suitable name.\n This is a Siddhi routine. In this example, let's name our application as \n\n\u201cHelloWorldApp\u201d\n\n\n@App:name(\nHelloWorldApp\n)\n\n\n\n\n\nPart 2\u200a\u2014\u200aDefining the input stream.\n The stream needs to have a name and a schema defining the data that each incoming event should contain.\nThe event data attributes are expressed as name and type pairs. In this example:\n\n\n\n\nThe name of the input stream\u200a\u2014\u200a\n\u201cCargoStream\u201d\n \n\nThis contains only one data attribute:\n\n\nThe name of the data in each event\u200a\u2014\u200a\n\u201cweight\u201d\n\n\nType of the data \n\u201cweight\u201d\n\u200a\u2014\u200aint\n\n\n\n\ndefine stream CargoStream (weight int);\n\n\n\n\n\nPart 3 - Defining the output stream.\n This has the same info as the previous definition with an additional \n\ntotalWeight\n attribute that contains the total weight calculated so far. Here, we need to add a \n\n\"sink\"\n  to log the \nOutputStream\n so that we can observe the output values. (\nSink is the Siddhi way to publish \nstreams to external systems.\n This particular \nlog\n type sink just logs the stream events. To learn more about sinks, see \n\nsink\n)\n\n\n@sink(type=\nlog\n, prefix=\nLOGGER\n)\ndefine stream OutputStream(weight int, totalWeight long);\n\n\n\n\n\nPart 4\u200a\u2014\u200aThe actual Siddhi query.\n Here we need to specify the following:\n\n\n\n\nA name for the query\u200a\u2014\u200a\n\u201cHelloWorldQuery\u201d\n\n\nWhich stream should be taken into processing\u200a\u2014\u200a\n\u201cCargoStream\u201d\n\n\nWhat data we require in the output stream\u200a\u2014\u200a\n\u201cweight\u201d\n, \n\u201ctotalWeight\u201d\n\n\nHow the output should be calculated - by calculating the \nsum\n of the the \nweight\ns  \n\n\nWhich stream should be populated with the output\u200a\u2014\u200a\n\u201cOutputStream\u201d\n\n\n\n\n@info(name=\nHelloWorldQuery\n)\nfrom CargoStream\nselect weight, sum(weight) as totalWeight\ninsert into OutputStream;\n\n\n\n\n\n\n\n5. Simulating Events\n\n\nThe Stream Processor Studio has in-built support to simulate events. You can do it via the \n\u201cEvent Simulator\u201d\n \npanel at the left of the Stream Processor Studio. You should save your \nHelloWorldApp\n by browsing to \nFile\n -\n \n\nSave\n before you run event simulation. Then click  \nEvent Simulator\n and configure it as shown below.\n\n\n\n\nStep 1\u200a\u2014\u200aConfigurations:\n\n\n\n\nSiddhi App Name\u200a\u2014\u200a\n\u201cHelloWorldApp\u201d\n\n\nStream Name\u200a\u2014\u200a\n\u201cCargoStream\u201d\n\n\nTimestamp\u200a\u2014\u200a(Leave it blank)\n\n\nweight\u200a\u2014\u200a2 (or some integer)\n\n\n\n\nStep 2\u200a\u2014\u200aClick \u201cRun\u201d mode and then click \u201cStart\u201d\n. This starts the Siddhi Application. \nIf the Siddhi application is successfully started, the following message is printed in the Stream Processor Studio console:\n\n\n\u201cHelloWorldApp.siddhi Started Successfully!\u201d\n \n\n\nStep 3\u200a\u2014\u200aClick \u201cSend\u201d and observe the terminal\n where you started WSO2 Stream Processor Studio. \nYou can see a log that contains \n\u201coutputData=[2, 2]\u201d\n. Click \nSend\n again and observe a log with \n\n\u201coutputData=[2, 4]\u201d\n. You can change the value of the weight and send it to see how the sum of the weight is updated.\n\n\n\n\nBravo! You have successfully completed creating Siddhi Hello World! \n\n\n6. A Bit of Stream Processing - \ntemporal event processing\n\n\nThis section demonstrates how to carry out \ntemporal window processing\n with Siddhi.\n\n\nUp to this point, we have been carrying out the processing by having only the running sum value in-memory. \nNo events were stored during this process. \n\n\nWindow processing\n\nis a method that allows us to store some events in-memory for a given period so that we can perform operations \nsuch as calculating the average, maximum, etc values within them.\n\n\nLet's imagine that when we are loading cargo boxes into the ship \nwe need to keep track of the average weight of \nthe recently loaded boxes\n so that we can balance the weight across the ship. \nFor this purpose, let's try to find the \naverage weight of last three boxes\n of each event.\n\n\n\n\nFor window processing, we need to modify our query as follows:\n\n\n@info(name=\nHelloWorldQuery\n) \nfrom CargoStream#window.length(3)\nselect weight, sum(weight) as totalWeight, avg(weight) as averageWeight\ninsert into OutputStream;\n\n\n\n\n\n\n\nfrom CargoStream#window.length(3)\n - Here, we are specifying that the last 3 events should be kept in memory for processing.\n\n\navg(weight) as averageWeight\n - Here, we are calculating the average of events stored in the window and producing the \naverage value as \n\"averageWeight\"\n (Note: Now the \nsum\n also calculates the \ntotalWeight\n based on the last three events).\n\n\n\n\nWe also need to modify the \n\"OutputStream\"\n definition to accommodate the new \n\"averageWeight\"\n.\n\n\ndefine stream OutputStream(weight int, totalWeight long, averageWeight double);\n\n\n\n\n\nThe updated Siddhi Application should look as shown below:\n\n\n\n\nNow you can send events using the Event Simulator and observe the log to see the sum and average of the weights of the last three \ncargo events.\n\n\nIt is also notable that the defined \nlength window\n only keeps 3 events in-memory. When the 4th event arrives, the \nfirst event in the window is removed from memory. This ensures that the memory usage does not grow beyond a specific limit. There are also other \nimplementations done in Siddhi  to reduce the memory consumption. For more information, see \nSiddhi Architecture\n.\n\n\nTo learn more about the Siddhi functionality, see \nSiddhi Query Guide\n.\n\n\nFeel free to try out Siddhi and event simulation to understand Siddhi better.\n\n\nIf you have questions please post them to the \nStackoverflow\n with \n\"Siddhi\"\n tag.", 
            "title": "Quick Start Guide"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#siddhi-5x-quick-start-guide", 
            "text": "Siddhi  is a 100% open source Java library that is thoroughly optimized for high performance. \nIt performs  Stream Processing  and  Complex Event Processing  on real time data streams.   Siddhi is used by many companies including Uber and eBay (via Apache Eagle).  Uber processes more than 20 billion \nevents per day using Siddhi  for fraud analytics, and Siddhi is used in Apache Eagle as a policy enforcement engine.  This quick start guide contains the following six sections:   Stream Processing and Complex Event Processing Overview - about the  domain  of Siddhi  An Overview of Siddhi - Explaining the basic  architecture  Using Siddhi for the First Time - how to  set up  the software  Siddhi \u2018Hello World!\u2019 - Your  First Siddhi Application  Simulating Events -  Testing  your query with simulated events  A Bit of Stream Processing -  temporal event processing", 
            "title": "Siddhi 5.x Quick Start Guide"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#1-stream-processing-and-complex-event-processing-cep-overview", 
            "text": "Before diving into using Siddhi, let's first discuss Stream Processing \nand Complex Event Processing in brief so that we can identify the use-cases where Siddhi can be used.  First let's understand what an event is through an example.  If we consider the transactions carried out via an ATM as a data \nstream, one withdrawal from it can be considered an event . This event contains data about the amount, time, account number etc. \nMany such transactions form a stream.   Forrester  defines Streaming Analytics as:   Software that provides analytical operators to  orchestrate data flow ,  calculate analytics , and  detect patterns  on \nevent data  from multiple, disparate live data sources  to allow developers to build applications that  sense, think, \nand act in real time .   Gartner\u2019s IT Glossary  defines CEP as follows:   \"CEP is a kind of computing in which  incoming data about events is distilled into more useful, higher level \u201ccomplex\u201d \nevent data  that provides insight into what is happening.\"  \" CEP is event-driven  because the computation is triggered by the receipt of event data. CEP is used for highly \ndemanding, continuous-intelligence applications that enhance situation awareness and support real-time decisions.\"    Basically, Siddhi receives data event-by-event and processes them in real time to produce meaningful information.  Siddhi Can be used in the following use-cases:   Fraud Analytics   Monitoring   Anomaly Detection  Sentiment Analysis  Processing Customer Behaviour  .. etc", 
            "title": "1. Stream Processing and Complex Event Processing (CEP) Overview"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#2-overview-of-siddhi", 
            "text": "As indicated above, Siddhi can:   accept event inputs from many different types of sources  process them to generate insights  publish them to many types of sinks.   To use Siddhi, you need to write the processing logic as a  Siddhi Application  in the  Siddhi Streaming SQL  \nlanguage which is discussed in the 4th section. After writing and starting  a Siddhi application , it:   Takes data one-by-one as events  Processes the data in each event  Generates new high level events based on the processing done so far  Sends newly generated events as the output to streams.", 
            "title": "2. Overview of Siddhi"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#3-using-siddhi-for-the-first-time", 
            "text": "In this section, we will be using the WSO2 Stream Processor(referred to as SP in the rest of this guide)\u200a\u2014\u200aa server version of Siddhi that has a\nsophisticated editor with a GUI (referred to as  \u201cStream Processor Studio\u201d ) where you can write your query and simulate events\nas a data stream.  Step 1 \u200a\u2014\u200aInstall  Oracle Java SE Development Kit (JDK)  version 1.8.   Step 2 \u200a\u2014\u200a Set the JAVA_HOME  environment \nvariable.   Step 3 \u200a\u2014\u200aDownload the latest  WSO2 Stream Processor .   Step 4 \u200a\u2014\u200aExtract the downloaded zip and navigate to  SP_HOME /bin .   ( SP_HOME  refers to the extracted folder)   Step 5 \u200a\u2014\u200aIssue the following command in the command prompt (Windows) / terminal (Linux)   For Windows: editor.bat\nFor Linux: ./editor.sh  For more details about WSO2 Stream Processor, see its  Quick Start Guide .  After successfully starting the Stream Processor Studio, the terminal in Linux should look like as shown below:   After starting the WSO2 Stream Processor, access the Stream Processor Studio by visiting the following link in your browser.  http://localhost:9390/editor  This takes you to the Stream Processor Studio landing page.", 
            "title": "3. Using Siddhi for the First Time"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#4-siddhi-hello-world-your-first-siddhi-application", 
            "text": "Siddhi Streaming SQL is a rich, compact, easy-to-learn SQL-like language.  Let's first learn how to find the total  of values \ncoming into a data stream and output the current running total value with each event. Siddhi has lot of in-built functions and extensions \navailable for complex analysis, but to get started, let's use a simple one. You can find more information about the Siddhi grammar \nand its functions in the  Siddhi Query Guide .  Let's  consider a scenario where we are loading cargo boxes into a ship . We need to keep track of the total \nweight of the cargo added.  Measuring the weight of a cargo box when loading is considered an event .   We can write a Siddhi program for the above scenario which has  4 parts .  Part 1\u200a\u2014\u200aGiving our Siddhi application a suitable name.  This is a Siddhi routine. In this example, let's name our application as  \u201cHelloWorldApp\u201d  @App:name( HelloWorldApp )  Part 2\u200a\u2014\u200aDefining the input stream.  The stream needs to have a name and a schema defining the data that each incoming event should contain.\nThe event data attributes are expressed as name and type pairs. In this example:   The name of the input stream\u200a\u2014\u200a \u201cCargoStream\u201d   \nThis contains only one data attribute:  The name of the data in each event\u200a\u2014\u200a \u201cweight\u201d  Type of the data  \u201cweight\u201d \u200a\u2014\u200aint   define stream CargoStream (weight int);  Part 3 - Defining the output stream.  This has the same info as the previous definition with an additional  totalWeight  attribute that contains the total weight calculated so far. Here, we need to add a  \"sink\"   to log the  OutputStream  so that we can observe the output values. ( Sink is the Siddhi way to publish \nstreams to external systems.  This particular  log  type sink just logs the stream events. To learn more about sinks, see  sink )  @sink(type= log , prefix= LOGGER )\ndefine stream OutputStream(weight int, totalWeight long);  Part 4\u200a\u2014\u200aThe actual Siddhi query.  Here we need to specify the following:   A name for the query\u200a\u2014\u200a \u201cHelloWorldQuery\u201d  Which stream should be taken into processing\u200a\u2014\u200a \u201cCargoStream\u201d  What data we require in the output stream\u200a\u2014\u200a \u201cweight\u201d ,  \u201ctotalWeight\u201d  How the output should be calculated - by calculating the  sum  of the the  weight s    Which stream should be populated with the output\u200a\u2014\u200a \u201cOutputStream\u201d   @info(name= HelloWorldQuery )\nfrom CargoStream\nselect weight, sum(weight) as totalWeight\ninsert into OutputStream;", 
            "title": "4. Siddhi \u2018Hello World!\u2019\u200a\u2014\u200aYour First Siddhi Application"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#5-simulating-events", 
            "text": "The Stream Processor Studio has in-built support to simulate events. You can do it via the  \u201cEvent Simulator\u201d  \npanel at the left of the Stream Processor Studio. You should save your  HelloWorldApp  by browsing to  File  -   Save  before you run event simulation. Then click   Event Simulator  and configure it as shown below.   Step 1\u200a\u2014\u200aConfigurations:   Siddhi App Name\u200a\u2014\u200a \u201cHelloWorldApp\u201d  Stream Name\u200a\u2014\u200a \u201cCargoStream\u201d  Timestamp\u200a\u2014\u200a(Leave it blank)  weight\u200a\u2014\u200a2 (or some integer)   Step 2\u200a\u2014\u200aClick \u201cRun\u201d mode and then click \u201cStart\u201d . This starts the Siddhi Application. \nIf the Siddhi application is successfully started, the following message is printed in the Stream Processor Studio console:  \u201cHelloWorldApp.siddhi Started Successfully!\u201d    Step 3\u200a\u2014\u200aClick \u201cSend\u201d and observe the terminal  where you started WSO2 Stream Processor Studio. \nYou can see a log that contains  \u201coutputData=[2, 2]\u201d . Click  Send  again and observe a log with  \u201coutputData=[2, 4]\u201d . You can change the value of the weight and send it to see how the sum of the weight is updated.   Bravo! You have successfully completed creating Siddhi Hello World!", 
            "title": "5. Simulating Events"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#6-a-bit-of-stream-processing-temporal-event-processing", 
            "text": "This section demonstrates how to carry out  temporal window processing  with Siddhi.  Up to this point, we have been carrying out the processing by having only the running sum value in-memory. \nNo events were stored during this process.   Window processing \nis a method that allows us to store some events in-memory for a given period so that we can perform operations \nsuch as calculating the average, maximum, etc values within them.  Let's imagine that when we are loading cargo boxes into the ship  we need to keep track of the average weight of \nthe recently loaded boxes  so that we can balance the weight across the ship. \nFor this purpose, let's try to find the  average weight of last three boxes  of each event.   For window processing, we need to modify our query as follows:  @info(name= HelloWorldQuery ) \nfrom CargoStream#window.length(3)\nselect weight, sum(weight) as totalWeight, avg(weight) as averageWeight\ninsert into OutputStream;   from CargoStream#window.length(3)  - Here, we are specifying that the last 3 events should be kept in memory for processing.  avg(weight) as averageWeight  - Here, we are calculating the average of events stored in the window and producing the \naverage value as  \"averageWeight\"  (Note: Now the  sum  also calculates the  totalWeight  based on the last three events).   We also need to modify the  \"OutputStream\"  definition to accommodate the new  \"averageWeight\" .  define stream OutputStream(weight int, totalWeight long, averageWeight double);  The updated Siddhi Application should look as shown below:   Now you can send events using the Event Simulator and observe the log to see the sum and average of the weights of the last three \ncargo events.  It is also notable that the defined  length window  only keeps 3 events in-memory. When the 4th event arrives, the \nfirst event in the window is removed from memory. This ensures that the memory usage does not grow beyond a specific limit. There are also other \nimplementations done in Siddhi  to reduce the memory consumption. For more information, see  Siddhi Architecture .  To learn more about the Siddhi functionality, see  Siddhi Query Guide .  Feel free to try out Siddhi and event simulation to understand Siddhi better.  If you have questions please post them to the  Stackoverflow  with  \"Siddhi\"  tag.", 
            "title": "6. A Bit of Stream Processing - temporal event processing"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/", 
            "text": "Siddhi 5.x Quick Start Guide\n\n\nSiddhi\n is a 100% open source Java library that is thoroughly optimized for high performance. \nIt performs \nStream Processing\n and \nComplex Event Processing\n on real time data streams. \n\n\nSiddhi is used by many companies including Uber and eBay (via Apache Eagle). \nUber processes more than 20 billion \nevents per day using Siddhi\n for fraud analytics, and Siddhi is used in Apache Eagle as a policy enforcement engine.\n\n\nThis quick start guide contains the following six sections:\n\n\n\n\nStream Processing and Complex Event Processing Overview - about the \ndomain\n of Siddhi\n\n\nAn Overview of Siddhi - Explaining the basic \narchitecture\n\n\nUsing Siddhi for the First Time - how to \nset up\n the software\n\n\nSiddhi \u2018Hello World!\u2019 - Your \nFirst Siddhi Application\n\n\nSimulating Events - \nTesting\n your query with simulated events\n\n\nA Bit of Stream Processing - \ntemporal event processing\n\n\n\n\n1. Stream Processing and Complex Event Processing (CEP) Overview\n\n\nBefore diving into using Siddhi, let's first discuss Stream Processing \nand Complex Event Processing in brief so that we can identify the use-cases where Siddhi can be used.\n\n\nFirst let's understand what an event is through an example. \nIf we consider the transactions carried out via an ATM as a data \nstream, one withdrawal from it can be considered an event\n. This event contains data about the amount, time, account number etc. \nMany such transactions form a stream.\n\n\n\n\nForrester\n defines Streaming Analytics as:\n\n\n\n\nSoftware that provides analytical operators to \norchestrate data flow\n, \ncalculate analytics\n, and \ndetect patterns\n on \nevent data \nfrom multiple, disparate live data sources\n to allow developers to build applications that \nsense, think, \nand act in real time\n.\n\n\n\n\nGartner\u2019s IT Glossary\n defines CEP as follows:\n\n\n\n\n\"CEP is a kind of computing in which \nincoming data about events is distilled into more useful, higher level \u201ccomplex\u201d \nevent data\n that provides insight into what is happening.\"\n\n\n\"\nCEP is event-driven\n because the computation is triggered by the receipt of event data. CEP is used for highly \ndemanding, continuous-intelligence applications that enhance situation awareness and support real-time decisions.\"\n\n\n\n\n\n\nBasically, Siddhi receives data event-by-event and processes them in real time to produce meaningful information.\n\n\nSiddhi Can be used in the following use-cases:\n\n\n\n\nFraud Analytics \n\n\nMonitoring \n\n\nAnomaly Detection\n\n\nSentiment Analysis\n\n\nProcessing Customer Behaviour\n\n\n.. etc\n\n\n\n\n2. Overview of Siddhi\n\n\n\n\nAs indicated above, Siddhi can:\n\n\n\n\naccept event inputs from many different types of sources\n\n\nprocess them to generate insights\n\n\npublish them to many types of sinks.\n\n\n\n\nTo use Siddhi, you need to write the processing logic as a \nSiddhi Application\n in the \nSiddhi Streaming SQL\n \nlanguage which is discussed in the 4th section. After writing and starting \na Siddhi application\n, it:\n\n\n\n\nTakes data one-by-one as events\n\n\nProcesses the data in each event\n\n\nGenerates new high level events based on the processing done so far\n\n\nSends newly generated events as the output to streams.\n\n\n\n\n3. Using Siddhi for the First Time\n\n\nIn this section, we will be using the WSO2 Stream Processor(referred to as SP in the rest of this guide)\u200a\u2014\u200aa server version of Siddhi that has a\nsophisticated editor with a GUI (referred to as \n\u201cStream Processor Studio\u201d\n) where you can write your query and simulate events\nas a data stream.\n\n\nStep 1\n\u200a\u2014\u200aInstall \n\nOracle Java SE Development Kit (JDK)\n version 1.8. \n\n\nStep 2\n\u200a\u2014\u200a\nSet the JAVA_HOME\n environment \nvariable. \n\n\nStep 3\n\u200a\u2014\u200aDownload the latest \nWSO2 Stream Processor\n. \n\n\nStep 4\n\u200a\u2014\u200aExtract the downloaded zip and navigate to \nSP_HOME\n/bin\n. \n (\nSP_HOME\n refers to the extracted folder) \n\n\nStep 5\n\u200a\u2014\u200aIssue the following command in the command prompt (Windows) / terminal (Linux) \n\n\nFor Windows: editor.bat\nFor Linux: ./editor.sh\n\n\n\n\n\nFor more details about WSO2 Stream Processor, see its \nQuick Start Guide\n.\n\n\nAfter successfully starting the Stream Processor Studio, the terminal in Linux should look like as shown below:\n\n\n\n\nAfter starting the WSO2 Stream Processor, access the Stream Processor Studio by visiting the following link in your browser.\n\n\nhttp://localhost:9390/editor\n\n\n\n\n\nThis takes you to the Stream Processor Studio landing page.\n\n\n\n\n4. Siddhi \u2018Hello World!\u2019\u200a\u2014\u200aYour First Siddhi Application\n\n\nSiddhi Streaming SQL is a rich, compact, easy-to-learn SQL-like language. \nLet's first learn how to find the total\n of values \ncoming into a data stream and output the current running total value with each event. Siddhi has lot of in-built functions and extensions \navailable for complex analysis, but to get started, let's use a simple one. You can find more information about the Siddhi grammar \nand its functions in the \nSiddhi Query Guide\n.\n\n\nLet's \nconsider a scenario where we are loading cargo boxes into a ship\n. We need to keep track of the total \nweight of the cargo added. \nMeasuring the weight of a cargo box when loading is considered an event\n.\n\n\n\n\nWe can write a Siddhi program for the above scenario which has \n4 parts\n.\n\n\nPart 1\u200a\u2014\u200aGiving our Siddhi application a suitable name.\n This is a Siddhi routine. In this example, let's name our application as \n\n\u201cHelloWorldApp\u201d\n\n\n@App:name(\nHelloWorldApp\n)\n\n\n\n\n\nPart 2\u200a\u2014\u200aDefining the input stream.\n The stream needs to have a name and a schema defining the data that each incoming event should contain.\nThe event data attributes are expressed as name and type pairs. In this example:\n\n\n\n\nThe name of the input stream\u200a\u2014\u200a\n\u201cCargoStream\u201d\n \n\nThis contains only one data attribute:\n\n\nThe name of the data in each event\u200a\u2014\u200a\n\u201cweight\u201d\n\n\nType of the data \n\u201cweight\u201d\n\u200a\u2014\u200aint\n\n\n\n\ndefine stream CargoStream (weight int);\n\n\n\n\n\nPart 3 - Defining the output stream.\n This has the same info as the previous definition with an additional \n\ntotalWeight\n attribute that contains the total weight calculated so far. Here, we need to add a \n\n\"sink\"\n  to log the \nOutputStream\n so that we can observe the output values. (\nSink is the Siddhi way to publish \nstreams to external systems.\n This particular \nlog\n type sink just logs the stream events. To learn more about sinks, see \n\nsink\n)\n\n\n@sink(type=\nlog\n, prefix=\nLOGGER\n)\ndefine stream OutputStream(weight int, totalWeight long);\n\n\n\n\n\nPart 4\u200a\u2014\u200aThe actual Siddhi query.\n Here we need to specify the following:\n\n\n\n\nA name for the query\u200a\u2014\u200a\n\u201cHelloWorldQuery\u201d\n\n\nWhich stream should be taken into processing\u200a\u2014\u200a\n\u201cCargoStream\u201d\n\n\nWhat data we require in the output stream\u200a\u2014\u200a\n\u201cweight\u201d\n, \n\u201ctotalWeight\u201d\n\n\nHow the output should be calculated - by calculating the \nsum\n of the the \nweight\ns  \n\n\nWhich stream should be populated with the output\u200a\u2014\u200a\n\u201cOutputStream\u201d\n\n\n\n\n@info(name=\nHelloWorldQuery\n)\nfrom CargoStream\nselect weight, sum(weight) as totalWeight\ninsert into OutputStream;\n\n\n\n\n\n\n\n5. Simulating Events\n\n\nThe Stream Processor Studio has in-built support to simulate events. You can do it via the \n\u201cEvent Simulator\u201d\n \npanel at the left of the Stream Processor Studio. You should save your \nHelloWorldApp\n by browsing to \nFile\n -\n \n\nSave\n before you run event simulation. Then click  \nEvent Simulator\n and configure it as shown below.\n\n\n\n\nStep 1\u200a\u2014\u200aConfigurations:\n\n\n\n\nSiddhi App Name\u200a\u2014\u200a\n\u201cHelloWorldApp\u201d\n\n\nStream Name\u200a\u2014\u200a\n\u201cCargoStream\u201d\n\n\nTimestamp\u200a\u2014\u200a(Leave it blank)\n\n\nweight\u200a\u2014\u200a2 (or some integer)\n\n\n\n\nStep 2\u200a\u2014\u200aClick \u201cRun\u201d mode and then click \u201cStart\u201d\n. This starts the Siddhi Application. \nIf the Siddhi application is successfully started, the following message is printed in the Stream Processor Studio console:\n\n\n\u201cHelloWorldApp.siddhi Started Successfully!\u201d\n \n\n\nStep 3\u200a\u2014\u200aClick \u201cSend\u201d and observe the terminal\n where you started WSO2 Stream Processor Studio. \nYou can see a log that contains \n\u201coutputData=[2, 2]\u201d\n. Click \nSend\n again and observe a log with \n\n\u201coutputData=[2, 4]\u201d\n. You can change the value of the weight and send it to see how the sum of the weight is updated.\n\n\n\n\nBravo! You have successfully completed creating Siddhi Hello World! \n\n\n6. A Bit of Stream Processing - \ntemporal event processing\n\n\nThis section demonstrates how to carry out \ntemporal window processing\n with Siddhi.\n\n\nUp to this point, we have been carrying out the processing by having only the running sum value in-memory. \nNo events were stored during this process. \n\n\nWindow processing\n\nis a method that allows us to store some events in-memory for a given period so that we can perform operations \nsuch as calculating the average, maximum, etc values within them.\n\n\nLet's imagine that when we are loading cargo boxes into the ship \nwe need to keep track of the average weight of \nthe recently loaded boxes\n so that we can balance the weight across the ship. \nFor this purpose, let's try to find the \naverage weight of last three boxes\n of each event.\n\n\n\n\nFor window processing, we need to modify our query as follows:\n\n\n@info(name=\nHelloWorldQuery\n) \nfrom CargoStream#window.length(3)\nselect weight, sum(weight) as totalWeight, avg(weight) as averageWeight\ninsert into OutputStream;\n\n\n\n\n\n\n\nfrom CargoStream#window.length(3)\n - Here, we are specifying that the last 3 events should be kept in memory for processing.\n\n\navg(weight) as averageWeight\n - Here, we are calculating the average of events stored in the window and producing the \naverage value as \n\"averageWeight\"\n (Note: Now the \nsum\n also calculates the \ntotalWeight\n based on the last three events).\n\n\n\n\nWe also need to modify the \n\"OutputStream\"\n definition to accommodate the new \n\"averageWeight\"\n.\n\n\ndefine stream OutputStream(weight int, totalWeight long, averageWeight double);\n\n\n\n\n\nThe updated Siddhi Application should look as shown below:\n\n\n\n\nNow you can send events using the Event Simulator and observe the log to see the sum and average of the weights of the last three \ncargo events.\n\n\nIt is also notable that the defined \nlength window\n only keeps 3 events in-memory. When the 4th event arrives, the \nfirst event in the window is removed from memory. This ensures that the memory usage does not grow beyond a specific limit. There are also other \nimplementations done in Siddhi  to reduce the memory consumption. For more information, see \nSiddhi Architecture\n.\n\n\nTo learn more about the Siddhi functionality, see \nSiddhi Query Guide\n.\n\n\nFeel free to try out Siddhi and event simulation to understand Siddhi better.\n\n\nIf you have questions please post them to the \nStackoverflow\n with \n\"Siddhi\"\n tag.", 
            "title": "Quick Start Guide"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#siddhi-5x-quick-start-guide", 
            "text": "Siddhi  is a 100% open source Java library that is thoroughly optimized for high performance. \nIt performs  Stream Processing  and  Complex Event Processing  on real time data streams.   Siddhi is used by many companies including Uber and eBay (via Apache Eagle).  Uber processes more than 20 billion \nevents per day using Siddhi  for fraud analytics, and Siddhi is used in Apache Eagle as a policy enforcement engine.  This quick start guide contains the following six sections:   Stream Processing and Complex Event Processing Overview - about the  domain  of Siddhi  An Overview of Siddhi - Explaining the basic  architecture  Using Siddhi for the First Time - how to  set up  the software  Siddhi \u2018Hello World!\u2019 - Your  First Siddhi Application  Simulating Events -  Testing  your query with simulated events  A Bit of Stream Processing -  temporal event processing", 
            "title": "Siddhi 5.x Quick Start Guide"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#1-stream-processing-and-complex-event-processing-cep-overview", 
            "text": "Before diving into using Siddhi, let's first discuss Stream Processing \nand Complex Event Processing in brief so that we can identify the use-cases where Siddhi can be used.  First let's understand what an event is through an example.  If we consider the transactions carried out via an ATM as a data \nstream, one withdrawal from it can be considered an event . This event contains data about the amount, time, account number etc. \nMany such transactions form a stream.   Forrester  defines Streaming Analytics as:   Software that provides analytical operators to  orchestrate data flow ,  calculate analytics , and  detect patterns  on \nevent data  from multiple, disparate live data sources  to allow developers to build applications that  sense, think, \nand act in real time .   Gartner\u2019s IT Glossary  defines CEP as follows:   \"CEP is a kind of computing in which  incoming data about events is distilled into more useful, higher level \u201ccomplex\u201d \nevent data  that provides insight into what is happening.\"  \" CEP is event-driven  because the computation is triggered by the receipt of event data. CEP is used for highly \ndemanding, continuous-intelligence applications that enhance situation awareness and support real-time decisions.\"    Basically, Siddhi receives data event-by-event and processes them in real time to produce meaningful information.  Siddhi Can be used in the following use-cases:   Fraud Analytics   Monitoring   Anomaly Detection  Sentiment Analysis  Processing Customer Behaviour  .. etc", 
            "title": "1. Stream Processing and Complex Event Processing (CEP) Overview"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#2-overview-of-siddhi", 
            "text": "As indicated above, Siddhi can:   accept event inputs from many different types of sources  process them to generate insights  publish them to many types of sinks.   To use Siddhi, you need to write the processing logic as a  Siddhi Application  in the  Siddhi Streaming SQL  \nlanguage which is discussed in the 4th section. After writing and starting  a Siddhi application , it:   Takes data one-by-one as events  Processes the data in each event  Generates new high level events based on the processing done so far  Sends newly generated events as the output to streams.", 
            "title": "2. Overview of Siddhi"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#3-using-siddhi-for-the-first-time", 
            "text": "In this section, we will be using the WSO2 Stream Processor(referred to as SP in the rest of this guide)\u200a\u2014\u200aa server version of Siddhi that has a\nsophisticated editor with a GUI (referred to as  \u201cStream Processor Studio\u201d ) where you can write your query and simulate events\nas a data stream.  Step 1 \u200a\u2014\u200aInstall  Oracle Java SE Development Kit (JDK)  version 1.8.   Step 2 \u200a\u2014\u200a Set the JAVA_HOME  environment \nvariable.   Step 3 \u200a\u2014\u200aDownload the latest  WSO2 Stream Processor .   Step 4 \u200a\u2014\u200aExtract the downloaded zip and navigate to  SP_HOME /bin .   ( SP_HOME  refers to the extracted folder)   Step 5 \u200a\u2014\u200aIssue the following command in the command prompt (Windows) / terminal (Linux)   For Windows: editor.bat\nFor Linux: ./editor.sh  For more details about WSO2 Stream Processor, see its  Quick Start Guide .  After successfully starting the Stream Processor Studio, the terminal in Linux should look like as shown below:   After starting the WSO2 Stream Processor, access the Stream Processor Studio by visiting the following link in your browser.  http://localhost:9390/editor  This takes you to the Stream Processor Studio landing page.", 
            "title": "3. Using Siddhi for the First Time"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#4-siddhi-hello-world-your-first-siddhi-application", 
            "text": "Siddhi Streaming SQL is a rich, compact, easy-to-learn SQL-like language.  Let's first learn how to find the total  of values \ncoming into a data stream and output the current running total value with each event. Siddhi has lot of in-built functions and extensions \navailable for complex analysis, but to get started, let's use a simple one. You can find more information about the Siddhi grammar \nand its functions in the  Siddhi Query Guide .  Let's  consider a scenario where we are loading cargo boxes into a ship . We need to keep track of the total \nweight of the cargo added.  Measuring the weight of a cargo box when loading is considered an event .   We can write a Siddhi program for the above scenario which has  4 parts .  Part 1\u200a\u2014\u200aGiving our Siddhi application a suitable name.  This is a Siddhi routine. In this example, let's name our application as  \u201cHelloWorldApp\u201d  @App:name( HelloWorldApp )  Part 2\u200a\u2014\u200aDefining the input stream.  The stream needs to have a name and a schema defining the data that each incoming event should contain.\nThe event data attributes are expressed as name and type pairs. In this example:   The name of the input stream\u200a\u2014\u200a \u201cCargoStream\u201d   \nThis contains only one data attribute:  The name of the data in each event\u200a\u2014\u200a \u201cweight\u201d  Type of the data  \u201cweight\u201d \u200a\u2014\u200aint   define stream CargoStream (weight int);  Part 3 - Defining the output stream.  This has the same info as the previous definition with an additional  totalWeight  attribute that contains the total weight calculated so far. Here, we need to add a  \"sink\"   to log the  OutputStream  so that we can observe the output values. ( Sink is the Siddhi way to publish \nstreams to external systems.  This particular  log  type sink just logs the stream events. To learn more about sinks, see  sink )  @sink(type= log , prefix= LOGGER )\ndefine stream OutputStream(weight int, totalWeight long);  Part 4\u200a\u2014\u200aThe actual Siddhi query.  Here we need to specify the following:   A name for the query\u200a\u2014\u200a \u201cHelloWorldQuery\u201d  Which stream should be taken into processing\u200a\u2014\u200a \u201cCargoStream\u201d  What data we require in the output stream\u200a\u2014\u200a \u201cweight\u201d ,  \u201ctotalWeight\u201d  How the output should be calculated - by calculating the  sum  of the the  weight s    Which stream should be populated with the output\u200a\u2014\u200a \u201cOutputStream\u201d   @info(name= HelloWorldQuery )\nfrom CargoStream\nselect weight, sum(weight) as totalWeight\ninsert into OutputStream;", 
            "title": "4. Siddhi \u2018Hello World!\u2019\u200a\u2014\u200aYour First Siddhi Application"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#5-simulating-events", 
            "text": "The Stream Processor Studio has in-built support to simulate events. You can do it via the  \u201cEvent Simulator\u201d  \npanel at the left of the Stream Processor Studio. You should save your  HelloWorldApp  by browsing to  File  -   Save  before you run event simulation. Then click   Event Simulator  and configure it as shown below.   Step 1\u200a\u2014\u200aConfigurations:   Siddhi App Name\u200a\u2014\u200a \u201cHelloWorldApp\u201d  Stream Name\u200a\u2014\u200a \u201cCargoStream\u201d  Timestamp\u200a\u2014\u200a(Leave it blank)  weight\u200a\u2014\u200a2 (or some integer)   Step 2\u200a\u2014\u200aClick \u201cRun\u201d mode and then click \u201cStart\u201d . This starts the Siddhi Application. \nIf the Siddhi application is successfully started, the following message is printed in the Stream Processor Studio console:  \u201cHelloWorldApp.siddhi Started Successfully!\u201d    Step 3\u200a\u2014\u200aClick \u201cSend\u201d and observe the terminal  where you started WSO2 Stream Processor Studio. \nYou can see a log that contains  \u201coutputData=[2, 2]\u201d . Click  Send  again and observe a log with  \u201coutputData=[2, 4]\u201d . You can change the value of the weight and send it to see how the sum of the weight is updated.   Bravo! You have successfully completed creating Siddhi Hello World!", 
            "title": "5. Simulating Events"
        }, 
        {
            "location": "/documentation/siddhi-5.x/quckstart-5.x/#6-a-bit-of-stream-processing-temporal-event-processing", 
            "text": "This section demonstrates how to carry out  temporal window processing  with Siddhi.  Up to this point, we have been carrying out the processing by having only the running sum value in-memory. \nNo events were stored during this process.   Window processing \nis a method that allows us to store some events in-memory for a given period so that we can perform operations \nsuch as calculating the average, maximum, etc values within them.  Let's imagine that when we are loading cargo boxes into the ship  we need to keep track of the average weight of \nthe recently loaded boxes  so that we can balance the weight across the ship. \nFor this purpose, let's try to find the  average weight of last three boxes  of each event.   For window processing, we need to modify our query as follows:  @info(name= HelloWorldQuery ) \nfrom CargoStream#window.length(3)\nselect weight, sum(weight) as totalWeight, avg(weight) as averageWeight\ninsert into OutputStream;   from CargoStream#window.length(3)  - Here, we are specifying that the last 3 events should be kept in memory for processing.  avg(weight) as averageWeight  - Here, we are calculating the average of events stored in the window and producing the \naverage value as  \"averageWeight\"  (Note: Now the  sum  also calculates the  totalWeight  based on the last three events).   We also need to modify the  \"OutputStream\"  definition to accommodate the new  \"averageWeight\" .  define stream OutputStream(weight int, totalWeight long, averageWeight double);  The updated Siddhi Application should look as shown below:   Now you can send events using the Event Simulator and observe the log to see the sum and average of the weights of the last three \ncargo events.  It is also notable that the defined  length window  only keeps 3 events in-memory. When the 4th event arrives, the \nfirst event in the window is removed from memory. This ensures that the memory usage does not grow beyond a specific limit. There are also other \nimplementations done in Siddhi  to reduce the memory consumption. For more information, see  Siddhi Architecture .  To learn more about the Siddhi functionality, see  Siddhi Query Guide .  Feel free to try out Siddhi and event simulation to understand Siddhi better.  If you have questions please post them to the  Stackoverflow  with  \"Siddhi\"  tag.", 
            "title": "6. A Bit of Stream Processing - temporal event processing"
        }, 
        {
            "location": "/documentation/siddhi-5.x/user-guide-5.x/", 
            "text": "# Siddhi 5.x User Guide\n\n\nSystem Requirements\n\n\n\n\nMemory\n   - 128 MB (minimum), 500 MB (recommended), higher memory might be needed based on in-memory data stored for processing\n\n\nCores\n    - 2 cores (recommended), use lower number of cores after testing Siddhi Apps for performance\n\n\nJDK\n      - 8 or 11\n\n\nTo build Siddhi from the Source distribution, it is necessary that you have JDK version 8 or 11 and Maven 3.0.4 or later\n\n\n\n\nUsing Siddhi in various environments\n\n\nUsing Siddhi as a Java library\n\n\nSiddhi can be used as a library in any Java program (including OSGi runtimes) just by adding Siddhi and its extension jars as dependencies.\n\n\n\n\n\n\nFind a sample Siddhi project that's implemented as a Java program using Maven \nhere\n, this can be used as a reference for any based implementation.\n\n\n\n\n\n\nFollowing are the mandatory dependencies that need to be added to the Maven \npom.xml\n file (or to the class path).\n\n\n\n\n\n\n   \ndependency\n\n     \ngroupId\nio.siddhi\n/groupId\n\n     \nartifactId\nsiddhi-core\n/artifactId\n\n     \nversion\n5.x.x\n/version\n\n   \n/dependency\n\n   \ndependency\n\n     \ngroupId\nio.siddhi\n/groupId\n\n     \nartifactId\nsiddhi-query-api\n/artifactId\n\n     \nversion\n5.x.x\n/version\n\n   \n/dependency\n\n   \ndependency\n\n     \ngroupId\nio.siddhi\n/groupId\n\n     \nartifactId\nsiddhi-query-compiler\n/artifactId\n\n     \nversion\n5.x.x\n/version\n\n   \n/dependency\n\n   \ndependency\n\n     \ngroupId\nio.siddhi\n/groupId\n\n     \nartifactId\nsiddhi-annotations\n/artifactId\n\n     \nversion\n5.x.x\n/version\n\n   \n/dependency\n   \n\n\n\n\n\n\n\nSample Java class using Siddhi is as follows.\n\n\n\n\n\n\n\nUsing Siddhi as Local Micro Service\n\n\nSiddhi can also run a standalone program by passing the SiddhiApps and required configurations to it.\n\n\n\n\nDownload the the latest Siddhi distribution from \nGithub releases\n.\n\n\nUnzip the siddhi-runner-x.x.x.zip\n\n\nStart SiddhiApps with the runner config by executing the following commands from the distribution directory\n\n  Linux/Mac : \n./bin/runner.sh -Dapps=\nsiddhi-file\n -Dconfig=\nconfig-yaml-file\n\n  Windows : \nbin\\runner.bat -Dapps=\nsiddhi-file\n -Dconfig=\nconfig-yaml-file\n\n\n\n\n\n\nRunning Multiple SiddhiApps in one runner.\n\n\nTo run multiple SiddhiApps in one runtime, have all SiddhiApps in a directory and pass its location through \n-Dapps\n parameter as follows,\n\n\n-Dapps=\nsiddhi-apps-directory\n\n\n\n\n\n\nAlways use \nabsolute path\n for SiddhiApps and runner configs.\n\n\nProviding absolute path of SiddhiApp file, or directory in \n-Dapps\n parameter, and when providing the Siddhi runner config yaml on \n-Dconfig\n parameter while starting Siddhi runner.\n\n\n\n\nSamples\n\n\nRunning Siddhi App\n\n\nFollowing SiddhiApp collects events via HTTP and logs the number of events arrived during last 15 seconds.  \n\n\n\n\n\n\n    \nCopy the above SiddhiApp, and create the SiddhiApp file \nCountOverTime.siddhi\n.\n\n    \nRun the SiddhiApp by executing following commands from the distribution directory\n        \n\n            \nLinux/Mac :\n            \n./bin/runner.sh -Dapps=\n/CountOverTime.siddhi\n\n            \n\n            \nWindows :\n            \nbin\\runner.bat -Dapps=\n\\CountOverTime.siddhi\n\n            \n\n        \n\n    \n\n    \nTest the SiddhiApp by calling the HTTP endpoint using curl or Postman as follows\n        \n\n            \nPublish events with curl command:\n\n            Publish few json to the http endpoint as follows,\n\n\ncurl -X POST http://localhost:8006/production \\\n  --header \"Content-Type:application/json\" \\\n  -d '{\"event\":{\"name\":\"Cake\",\"amount\":20.12}}'\n\n\n            \n\n            \nPublish events with Postman:\n\n              \n\n                \nInstall 'Postman' application from Chrome web store\n\n                \nLaunch the application\n\n                \nMake a 'Post' request to 'http://localhost:8006/production' endpoint. Set the Content-Type to \n'application/json'\n and set the request body in json format as follows,\n\n\n{\n  \"event\": {\n    \"name\": \"Cake\",\n    \"amount\": 20.12\n  }\n}\n\n                \n\n              \n\n            \n\n        \n\n    \n\n    \nRunner logs the total count on the console. Note, how the count increments with every event sent.\n\n\n[2019-04-11 13:36:03,517]  INFO {io.siddhi.core.stream.output.sink.LogSink} - CountOverTime : TotalCountStream : Event{timestamp=1554969963512, data=[1], isExpired=false}\n[2019-04-11 13:36:10,267]  INFO {io.siddhi.core.stream.output.sink.LogSink} - CountOverTime : TotalCountStream : Event{timestamp=1554969970267, data=[2], isExpired=false}\n[2019-04-11 13:36:41,694]  INFO {io.siddhi.core.stream.output.sink.LogSink} - CountOverTime : TotalCountStream : Event{timestamp=1554970001694, data=[1], isExpired=false}\n\n\n    \n\n\n\n\n\nRunning with runner config\n\n\nWhen running SiddhiApps users can optionally provide a config yaml to Siddhi runner to manage configurations such as state persistence, databases connections and secure vault.\n\n\nFollowing SiddhiApp collects events via HTTP and store them in H2 Database.\n\n\n\n\n\nThe runner config can by configured with the relevant datasource information and passed when starting the runner\n\n\n\n\n\n\n    \nCopy the above SiddhiApp, \n&\n config yaml, and create corresponding the SiddhiApp file \nConsumeAndStore.siddhi\n and \nTestDb.yaml\n files.\n\n    \nRun the SiddhiApp by executing following commands from the distribution directory\n        \n\n            \nLinux/Mac :\n            \n./bin/runner.sh -Dapps=\n/ConsumeAndStore.siddhi \\\n  -Dconfig=\n/TestDb.yaml\n\n            \n\n            \nWindows :\n            \nbin\\runner.sh -Dapps=\n\\ConsumeAndStore.siddhi ^\n  -Dconfig=\n\\TestDb.yaml\n\n            \n\n        \n\n    \n\n    \nTest the SiddhiApp by calling the HTTP endpoint using curl or Postman as follows\n        \n\n            \nPublish events with curl command:\n\n            Publish few json to the http endpoint as follows,\n\n\ncurl -X POST http://localhost:8006/production \\\n  --header \"Content-Type:application/json\" \\\n  -d '{\"event\":{\"name\":\"Cake\",\"amount\":20.12}}'\n\n\n            \n\n            \nPublish events with Postman:\n\n              \n\n                \nInstall 'Postman' application from Chrome web store\n\n                \nLaunch the application\n\n                \nMake a 'Post' request to 'http://localhost:8006/production' endpoint. Set the Content-Type to \n'application/json'\n and set the request body in json format as follows,\n\n\n{\n  \"event\": {\n    \"name\": \"Cake\",\n    \"amount\": 20.12\n  }\n}\n\n                \n\n              \n\n            \n\n        \n\n    \n\n    \nQuery Siddhi Store APIs to retrieve 10 records from the table.\n        \n\n            \nQuery stored events with curl command:\n\n            Publish few json to the http endpoint as follows,\n\n\ncurl -X POST https://localhost:9443/stores/query \\\n  -H \"content-type: application/json\" \\\n  -u \"admin:admin\" \\\n  -d '{\"appName\" : \"ConsumeAndStore\", \"query\" : \"from ProductionTable select * limit 10;\" }' -k\n\n\n            \n\n            \nQuery stored events with Postman:\n\n              \n\n                \nInstall 'Postman' application from Chrome web store\n\n                \nLaunch the application\n\n                \nMake a 'Post' request to 'https://localhost:9443/stores/query' endpoint. Set the Content-Type to \n'application/json'\n and set the request body in json format as follows,\n\n\n{\n  \"appName\" : \"ConsumeAndStore\",\n  \"query\" : \"from ProductionTable select * limit 10;\"\n}\n\n                \n\n              \n\n            \n\n        \n\n    \n\n    \nThe results of the query will be as follows,\n\n\n{\n  \"records\":[\n    [\"Cake\",20.12]\n  ]\n}\n\n    \n\n\n\n\n\nRunning with environmental/system variables\n\n\nTemplating SiddhiApps allows users to provide environment/system variables to siddhiApps at runtime. This can help users to migrate SiddhiApps from one environment to another (E.g from dev, test and to prod).\n\n\nFollowing templated SiddhiApp collects events via HTTP, filters them based on \namount\n greater than a given threshold value, and only sends the filtered events via email.\n\n\nHere the \nTHRESHOLD\n value, and \nTO_EMAIL\n are templated in the \nTemplatedFilterAndEmail.siddhi\n SiddhiApp.\n\n\n\n\n\nThe runner config is configured with a gmail account to send email messages in \nEmailConfig.yaml\n by templating sending \nEMAIL_ADDRESS\n, \nEMAIL_USERNAME\n and \nEMAIL_PASSWORD\n.   \n\n\n\n\n\n\n    \nCopy the above SiddhiApp, \n&\n config yaml, and create corresponding the SiddhiApp file \nTemplatedFilterAndEmail.siddhi\n and \nEmailConfig.yaml\n files.\n\n\n    \nSet environment variables by running following in the termial Siddhi is about to run: \n         \n\nexport THRESHOLD=20\nexport TO_EMAIL=\n\nexport EMAIL_ADDRESS=\n\nexport EMAIL_USERNAME=\n\nexport EMAIL_PASSWORD=\n\n         \n\n        Or they can also be passed as system variables by adding \n-DTHRESHOLD=20 -DTO_EMAIL=\n -DEMAIL_ADDRESS=\n -DEMAIL_USERNAME=\n -DEMAIL_PASSWORD=\n\n        to the end of the runner startup script.\n    \n\n        \nRun the SiddhiApp by executing following commands from the distribution directory\n        \n\n            \nLinux/Mac :\n            \n\n./bin/runner.sh -Dapps=\n/TemplatedFilterAndEmail.siddhi \\\n  -Dconfig=\n/EmailConfig.yaml\n\n            \n\n            \nWindows :\n            \n\nbin\\runner.bat -Dapps=\n\\TemplatedFilterAndEmail.siddhi ^\n  -Dconfig=\n\\EmailConfig.yaml\n\n            \n\n        \n\n    \n\n    \nTest the SiddhiApp by calling the HTTP endpoint using curl or Postman as follows\n        \n\n            \nPublish events with curl command:\n\n            Publish few json to the http endpoint as follows,\n\n\ncurl -X POST http://localhost:8006/production \\\n  --header \"Content-Type:application/json\" \\\n  -d '{\"event\":{\"name\":\"Cake\",\"amount\":2000.0}}'\n\n\n            \n\n            \nPublish events with Postman:\n\n              \n\n                \nInstall 'Postman' application from Chrome web store\n\n                \nLaunch the application\n\n                \nMake a 'Post' request to 'http://localhost:8006/production' endpoint. Set the Content-Type to \n'application/json'\n and set the request body in json format as follows,\n\n\n{\n  \"event\": {\n    \"name\": \"Cake\",\n    \"amount\": 2000.0\n  }\n}\n\n                \n\n              \n\n            \n\n        \n\n    \n\n    \nCheck the \nto.email\n for the published email message, which will look as follows,\n\n\nSubject : High Cake production!\n\nHi, \n\nHigh production of Cake, with amount 2000.0 identified. \n\nFor more information please contact production department. \n\nThank you\n\n    \n\n\n\n\n\nUsing Siddhi as Docker Micro Service\n\n\nWIP\n\n\nUsing Siddhi as Kubernetes Micro Service\n\n\nWIP\n\n\nUsing Siddhi as a Python Library\n\n\nWIP", 
            "title": "User Guide"
        }, 
        {
            "location": "/documentation/siddhi-5.x/user-guide-5.x/#system-requirements", 
            "text": "Memory    - 128 MB (minimum), 500 MB (recommended), higher memory might be needed based on in-memory data stored for processing  Cores     - 2 cores (recommended), use lower number of cores after testing Siddhi Apps for performance  JDK       - 8 or 11  To build Siddhi from the Source distribution, it is necessary that you have JDK version 8 or 11 and Maven 3.0.4 or later", 
            "title": "System Requirements"
        }, 
        {
            "location": "/documentation/siddhi-5.x/user-guide-5.x/#using-siddhi-in-various-environments", 
            "text": "", 
            "title": "Using Siddhi in various environments"
        }, 
        {
            "location": "/documentation/siddhi-5.x/user-guide-5.x/#using-siddhi-as-a-java-library", 
            "text": "Siddhi can be used as a library in any Java program (including OSGi runtimes) just by adding Siddhi and its extension jars as dependencies.    Find a sample Siddhi project that's implemented as a Java program using Maven  here , this can be used as a reference for any based implementation.    Following are the mandatory dependencies that need to be added to the Maven  pom.xml  file (or to the class path).        dependency \n      groupId io.siddhi /groupId \n      artifactId siddhi-core /artifactId \n      version 5.x.x /version \n    /dependency \n    dependency \n      groupId io.siddhi /groupId \n      artifactId siddhi-query-api /artifactId \n      version 5.x.x /version \n    /dependency \n    dependency \n      groupId io.siddhi /groupId \n      artifactId siddhi-query-compiler /artifactId \n      version 5.x.x /version \n    /dependency \n    dependency \n      groupId io.siddhi /groupId \n      artifactId siddhi-annotations /artifactId \n      version 5.x.x /version \n    /dependency       Sample Java class using Siddhi is as follows.", 
            "title": "Using Siddhi as a Java library"
        }, 
        {
            "location": "/documentation/siddhi-5.x/user-guide-5.x/#using-siddhi-as-local-micro-service", 
            "text": "Siddhi can also run a standalone program by passing the SiddhiApps and required configurations to it.   Download the the latest Siddhi distribution from  Github releases .  Unzip the siddhi-runner-x.x.x.zip  Start SiddhiApps with the runner config by executing the following commands from the distribution directory \n  Linux/Mac :  ./bin/runner.sh -Dapps= siddhi-file  -Dconfig= config-yaml-file \n  Windows :  bin\\runner.bat -Dapps= siddhi-file  -Dconfig= config-yaml-file    Running Multiple SiddhiApps in one runner.  To run multiple SiddhiApps in one runtime, have all SiddhiApps in a directory and pass its location through  -Dapps  parameter as follows,  -Dapps= siddhi-apps-directory    Always use  absolute path  for SiddhiApps and runner configs.  Providing absolute path of SiddhiApp file, or directory in  -Dapps  parameter, and when providing the Siddhi runner config yaml on  -Dconfig  parameter while starting Siddhi runner.   Samples", 
            "title": "Using Siddhi as Local Micro Service"
        }, 
        {
            "location": "/documentation/siddhi-5.x/user-guide-5.x/#running-siddhi-app", 
            "text": "Following SiddhiApp collects events via HTTP and logs the number of events arrived during last 15 seconds.     \n     Copy the above SiddhiApp, and create the SiddhiApp file  CountOverTime.siddhi . \n     Run the SiddhiApp by executing following commands from the distribution directory\n         \n             Linux/Mac :\n             ./bin/runner.sh -Dapps= /CountOverTime.siddhi \n             \n             Windows :\n             bin\\runner.bat -Dapps= \\CountOverTime.siddhi \n             \n         \n     \n     Test the SiddhiApp by calling the HTTP endpoint using curl or Postman as follows\n         \n             Publish events with curl command: \n            Publish few json to the http endpoint as follows, \ncurl -X POST http://localhost:8006/production \\\n  --header \"Content-Type:application/json\" \\\n  -d '{\"event\":{\"name\":\"Cake\",\"amount\":20.12}}' \n             \n             Publish events with Postman: \n               \n                 Install 'Postman' application from Chrome web store \n                 Launch the application \n                 Make a 'Post' request to 'http://localhost:8006/production' endpoint. Set the Content-Type to  'application/json'  and set the request body in json format as follows, \n{\n  \"event\": {\n    \"name\": \"Cake\",\n    \"amount\": 20.12\n  }\n} \n                 \n               \n             \n         \n     \n     Runner logs the total count on the console. Note, how the count increments with every event sent. \n[2019-04-11 13:36:03,517]  INFO {io.siddhi.core.stream.output.sink.LogSink} - CountOverTime : TotalCountStream : Event{timestamp=1554969963512, data=[1], isExpired=false}\n[2019-04-11 13:36:10,267]  INFO {io.siddhi.core.stream.output.sink.LogSink} - CountOverTime : TotalCountStream : Event{timestamp=1554969970267, data=[2], isExpired=false}\n[2019-04-11 13:36:41,694]  INFO {io.siddhi.core.stream.output.sink.LogSink} - CountOverTime : TotalCountStream : Event{timestamp=1554970001694, data=[1], isExpired=false}", 
            "title": "Running Siddhi App"
        }, 
        {
            "location": "/documentation/siddhi-5.x/user-guide-5.x/#running-with-runner-config", 
            "text": "When running SiddhiApps users can optionally provide a config yaml to Siddhi runner to manage configurations such as state persistence, databases connections and secure vault.  Following SiddhiApp collects events via HTTP and store them in H2 Database.   The runner config can by configured with the relevant datasource information and passed when starting the runner   \n     Copy the above SiddhiApp,  &  config yaml, and create corresponding the SiddhiApp file  ConsumeAndStore.siddhi  and  TestDb.yaml  files. \n     Run the SiddhiApp by executing following commands from the distribution directory\n         \n             Linux/Mac :\n             ./bin/runner.sh -Dapps= /ConsumeAndStore.siddhi \\\n  -Dconfig= /TestDb.yaml \n             \n             Windows :\n             bin\\runner.sh -Dapps= \\ConsumeAndStore.siddhi ^\n  -Dconfig= \\TestDb.yaml \n             \n         \n     \n     Test the SiddhiApp by calling the HTTP endpoint using curl or Postman as follows\n         \n             Publish events with curl command: \n            Publish few json to the http endpoint as follows, \ncurl -X POST http://localhost:8006/production \\\n  --header \"Content-Type:application/json\" \\\n  -d '{\"event\":{\"name\":\"Cake\",\"amount\":20.12}}' \n             \n             Publish events with Postman: \n               \n                 Install 'Postman' application from Chrome web store \n                 Launch the application \n                 Make a 'Post' request to 'http://localhost:8006/production' endpoint. Set the Content-Type to  'application/json'  and set the request body in json format as follows, \n{\n  \"event\": {\n    \"name\": \"Cake\",\n    \"amount\": 20.12\n  }\n} \n                 \n               \n             \n         \n     \n     Query Siddhi Store APIs to retrieve 10 records from the table.\n         \n             Query stored events with curl command: \n            Publish few json to the http endpoint as follows, \ncurl -X POST https://localhost:9443/stores/query \\\n  -H \"content-type: application/json\" \\\n  -u \"admin:admin\" \\\n  -d '{\"appName\" : \"ConsumeAndStore\", \"query\" : \"from ProductionTable select * limit 10;\" }' -k \n             \n             Query stored events with Postman: \n               \n                 Install 'Postman' application from Chrome web store \n                 Launch the application \n                 Make a 'Post' request to 'https://localhost:9443/stores/query' endpoint. Set the Content-Type to  'application/json'  and set the request body in json format as follows, \n{\n  \"appName\" : \"ConsumeAndStore\",\n  \"query\" : \"from ProductionTable select * limit 10;\"\n} \n                 \n               \n             \n         \n     \n     The results of the query will be as follows, \n{\n  \"records\":[\n    [\"Cake\",20.12]\n  ]\n}", 
            "title": "Running with runner config"
        }, 
        {
            "location": "/documentation/siddhi-5.x/user-guide-5.x/#running-with-environmentalsystem-variables", 
            "text": "Templating SiddhiApps allows users to provide environment/system variables to siddhiApps at runtime. This can help users to migrate SiddhiApps from one environment to another (E.g from dev, test and to prod).  Following templated SiddhiApp collects events via HTTP, filters them based on  amount  greater than a given threshold value, and only sends the filtered events via email.  Here the  THRESHOLD  value, and  TO_EMAIL  are templated in the  TemplatedFilterAndEmail.siddhi  SiddhiApp.   The runner config is configured with a gmail account to send email messages in  EmailConfig.yaml  by templating sending  EMAIL_ADDRESS ,  EMAIL_USERNAME  and  EMAIL_PASSWORD .      \n     Copy the above SiddhiApp,  &  config yaml, and create corresponding the SiddhiApp file  TemplatedFilterAndEmail.siddhi  and  EmailConfig.yaml  files. \n\n     Set environment variables by running following in the termial Siddhi is about to run: \n          \nexport THRESHOLD=20\nexport TO_EMAIL= \nexport EMAIL_ADDRESS= \nexport EMAIL_USERNAME= \nexport EMAIL_PASSWORD= \n          \n        Or they can also be passed as system variables by adding  -DTHRESHOLD=20 -DTO_EMAIL=  -DEMAIL_ADDRESS=  -DEMAIL_USERNAME=  -DEMAIL_PASSWORD= \n        to the end of the runner startup script.\n     \n         Run the SiddhiApp by executing following commands from the distribution directory\n         \n             Linux/Mac :\n             \n./bin/runner.sh -Dapps= /TemplatedFilterAndEmail.siddhi \\\n  -Dconfig= /EmailConfig.yaml \n             \n             Windows :\n             \nbin\\runner.bat -Dapps= \\TemplatedFilterAndEmail.siddhi ^\n  -Dconfig= \\EmailConfig.yaml \n             \n         \n     \n     Test the SiddhiApp by calling the HTTP endpoint using curl or Postman as follows\n         \n             Publish events with curl command: \n            Publish few json to the http endpoint as follows, \ncurl -X POST http://localhost:8006/production \\\n  --header \"Content-Type:application/json\" \\\n  -d '{\"event\":{\"name\":\"Cake\",\"amount\":2000.0}}' \n             \n             Publish events with Postman: \n               \n                 Install 'Postman' application from Chrome web store \n                 Launch the application \n                 Make a 'Post' request to 'http://localhost:8006/production' endpoint. Set the Content-Type to  'application/json'  and set the request body in json format as follows, \n{\n  \"event\": {\n    \"name\": \"Cake\",\n    \"amount\": 2000.0\n  }\n} \n                 \n               \n             \n         \n     \n     Check the  to.email  for the published email message, which will look as follows, \nSubject : High Cake production!\n\nHi, \n\nHigh production of Cake, with amount 2000.0 identified. \n\nFor more information please contact production department. \n\nThank you", 
            "title": "Running with environmental/system variables"
        }, 
        {
            "location": "/documentation/siddhi-5.x/user-guide-5.x/#using-siddhi-as-docker-micro-service", 
            "text": "WIP", 
            "title": "Using Siddhi as Docker Micro Service"
        }, 
        {
            "location": "/documentation/siddhi-5.x/user-guide-5.x/#using-siddhi-as-kubernetes-micro-service", 
            "text": "WIP", 
            "title": "Using Siddhi as Kubernetes Micro Service"
        }, 
        {
            "location": "/documentation/siddhi-5.x/user-guide-5.x/#using-siddhi-as-a-python-library", 
            "text": "WIP", 
            "title": "Using Siddhi as a Python Library"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/", 
            "text": "Siddhi 5.x Streaming SQL Guide\n\n\n\n\nInfo\n\n\nPlease find the \nSiddhi 4.x Streaming SQL Guide here\n\n\n\n\nIntroduction\n\n\nSiddhi Streaming SQL is designed to process streams of events. It can be used to\nimplement streaming data integration, streaming analytics, rule based and\nadaptive decision making use cases.\nIt is an evolution of Complex Event Processing (CEP) and Stream Processing\nsystems, hence it can also be used to process stateful computations, detecting\nof complex event patterns, and sending notifications in real-time.\n\n\nSiddhi Streaming SQL uses SQL like syntax, and annotations to consume events\nfrom diverse event sources with various data formats, process then using\nstateful and stateless operators and send outputs to multiple endpoints\naccording to their accepted event formats. It also supports exposing rule based\nand adaptive decision making as service endpoints such that external programs\nand systems can synchronously get decision support form Siddhi.  \n\n\nThe following sections explains how to write processing logic using Siddhi Streaming SQL.\n\n\nSiddhi Application\n\n\nThe processing logic for your program can be written using the Streaming SQL and\nput together as a single file with \n.siddhi\n extension. This file is called as\nthe \nSiddhi Application\n or the \nSiddhiApp\n.\n\n\nSiddhiApps are named by adding \n@app:name('\nname\n')\n annotation on the top of the SiddhiApp file.\nWhen the annotation is not added Siddhi assigns a random UUID as the name of the SiddhiApp.\n\n\nPurpose\n\n\nSiddhiApp provides an isolated execution environment for your processing logic that allows you to\ndeploy and execute processing logic independent of other SiddhiApp in the system.\nTherefore it's always recommended to have a processing logic related to single\nuse case in a single SiddhiApp. This will help you to group\nprocessing logic and easily manage addition and removal of various use cases.\n\n\nThe following diagram depicts some of the key Siddhi Streaming SQL elements of Siddhi Application and\nhow \nevent flows\n through the elements.\n\n\n\n\nBelow table provides brief description of a few key elements in the Siddhi Streaming SQL Language.\n\n\n\n\n\n\n\n\nElements\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStream\n\n\nA logical series of events ordered in time with a uniquely identifiable name, and a defined set of typed attributes defining its schema.\n\n\n\n\n\n\nEvent\n\n\nAn event is a single event object associated with a stream. All events of a stream contains a timestamp and an identical set of typed attributes based on the schema of the stream they belong to.\n\n\n\n\n\n\nTable\n\n\nA structured representation of data stored with a defined schema. Stored data can be backed by \nIn-Memory\n, or external data stores such as \nRDBMs\n, \nMongoDB\n, etc. The tables can be accessed and manipulated at runtime.\n\n\n\n\n\n\nWindow\n\n\nA structured representation of data stored with a defined schema and eviction policy. Window data is stored \nIn-Memory\n and automatically cleared by the defined window constrain. Other siddhi elements can only query the values in windows at runtime but they cannot modify them.\n\n\n\n\n\n\nAggregation\n\n\nA structured representation of data that's incrementally aggregated and stored with a defined schema and aggregation granularity such as seconds, minutes, hours, etc. Aggregation data is stored both \nIn-Memory\nand in external data stores such as \nRDBMs\n. Other siddhi elements can only query the values in windows at runtime but they cannot modify them.\n\n\n\n\n\n\nQuery\n\n\nA logical construct that processes events in streaming manner by by consuming data from one or more streams, tables, windows and aggregations, and publishes output events into a stream, table or a window.\n\n\n\n\n\n\nSource\n\n\nA construct that consumes data from external sources (such as \nTCP\n, \nKafka\n, \nHTTP\n, etc) with various event formats such as \nXML\n, \nJSON\n, \nbinary\n, etc, convert then to Siddhi events, and passes into streams for processing.\n\n\n\n\n\n\nSink\n\n\nA construct that consumes events arriving at a stream, maps them to a predefined data format (such as \nXML\n, \nJSON\n, \nbinary\n, etc), and publishes them to external endpoints (such as \nE-mail\n, \nTCP\n, \nKafka\n, \nHTTP\n, etc).\n\n\n\n\n\n\nInput Handler\n\n\nA mechanism to programmatically inject events into streams.\n\n\n\n\n\n\nStream/Query Callback\n\n\nA mechanism to programmatically consume output events from streams or queries.\n\n\n\n\n\n\nPartition\n\n\nA logical container that isolates the processing of queries based on the partition keys derived from the events.\n\n\n\n\n\n\nInner Stream\n\n\nA positionable stream that connects portioned queries with each other within the partition.\n\n\n\n\n\n\n\n\nGrammar\n\n\nSiddhiApp is a collection of Siddhi Streaming SQL elements composed together as a script.\nHere each Siddhi element must be separated by a semicolon \n( ; )\n.\n\n\nHight level syntax of SiddhiApp is as follows.\n\n\nsiddhi app\n  :\n        \napp annotation\n *\n        ( \nstream definition\n | \ntable definition\n | ... ) +\n        ( \nquery\n | \npartition\n ) +\n        ;\n\n\n\n\n\nExample\n\n\nSiddhi Application with name \nTemperature-Analytics\n defined with a stream named \nTempStream\n and a query\nnamed \n5minAvgQuery\n.\n\n\n@\napp\n:\nname\n(\nTemperature-Analytics\n)\n\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\n@\nname\n(\n5minAvgQuery\n)\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntime\n(\n5\n \nmin\n)\n\n\nselect\n \nroomNo\n,\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n\n  \ngroup\n \nby\n \nroomNo\n\n\ninsert\n \ninto\n \nOutputStream\n;\n\n\n\n\n\n\nStream\n\n\nA stream is a logical series of events ordered in time. Its schema is defined via the \nstream definition\n.\nA stream definition contains the stream name and a set of attributes with specific types and uniquely identifiable names within the stream. All events associated to the stream will have the same schema (i.e., have the same attributes in the same order).\n\n\nPurpose\n\n\nStream groups common types of events together with a schema. This helps in various ways such as, processing all events together in queries and performing data format transformations together when they are consumed and published via sources and sinks.\n\n\nSyntax\n\n\nThe syntax for defining a new stream is as follows.\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n\n                             \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n);\n\n\n\n\n\n\nThe following parameters are used to configure a stream definition.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream name\n\n\nThe name of the stream created. (It is recommended to define a stream name in \nPascalCase\n.)\n\n\n\n\n\n\nattribute name\n\n\nUniquely identifiable name of the stream attribute. (It is recommended to define attribute names in \ncamelCase\n.)\n\n\n\n\n\n\nattribute type\n\n\nThe type of each attribute defined in the schema. \n This can be \nSTRING\n, \nINT\n, \nLONG\n, \nDOUBLE\n, \nFLOAT\n, \nBOOL\n or \nOBJECT\n.\n\n\n\n\n\n\n\n\nTo use and refer stream and attribute names that do not follow \n[a-zA-Z_][a-zA-Z_0-9]*\n format enclose them in \n`\n. E.g. \n`$test(0)`\n.\n\n\nTo make the stream process events in multi-threading and asynchronous way use the \n@Async\n annotation as shown in\n\nMulti-threading and Asynchronous Processing\n configuration section.\n\n\nExample\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\n\n\n\nThe above creates a stream with name \nTempStream\n having the following attributes.\n\n\n\n\ndeviceID\n of type \nlong\n\n\nroomNo\n of type \nint\n\n\ntemp\n of type \ndouble\n\n\n\n\nSource\n\n\nSources receive events via multiple transports and in various data formats, and direct them into streams for processing.\n\n\nA source configuration allows to define a mapping in order to convert each incoming event from its native data format to a Siddhi event. When customizations to such mappings are not provided, Siddhi assumes that the arriving event adheres to the predefined format based on the stream definition and the configured message mapping type.\n\n\nPurpose\n\n\nSource provides a way to consume events from external systems and convert them to be processed by the associated stream.\n\n\nSyntax\n\n\nTo configure a stream that consumes events via a source, add the source configuration to a stream definition by adding the \n@source\n annotation with the required parameter values.\n\n\nThe source syntax is as follows:\n\n\n@\nsource\n(\ntype\n=\nsource type\n,\n \nstatic\n.\nkey\n=\nvalue\n,\n \nstatic\n.\nkey\n=\nvalue\n,\n\n    \n@\nmap\n(\ntype\n=\nmap type\n,\n \nstatic\n.\nkey\n=\nvalue\n,\n \nstatic\n.\nkey\n=\nvalue\n,\n\n        \n@\nattributes\n(\n \nattribute1\n=\nattribute mapping\n,\n \nattributeN\n=\nattribute mapping\n)\n\n    \n)\n\n\n)\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute1\n \ntype\n,\n \nattributeN\n \ntype\n);\n\n\n\n\n\n\nThis syntax includes the following annotations.\n\n\nSource\n\n\nThe \ntype\n parameter of \n@source\n annotation defines the source type that receives events.\nThe other parameters of \n@source\n annotation depends upon the selected source type, and here\nsome of its parameters can be optional.\n\n\nFor detailed information about the supported parameters see the documentation of the relevant source.\n\n\nThe following is the list of source types supported by Siddhi:\n\n\n\n\n\n\n\n\nSource type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIn-memory\n\n\nAllow SiddhiApp to consume events from other SiddhiApps running on the same JVM.\n\n\n\n\n\n\nHTTP\n\n\nExpose an HTTP service to consume messages.\n\n\n\n\n\n\nKafka\n\n\nSubscribe to Kafka topic to consume events.\n\n\n\n\n\n\nTCP\n\n\nExpose a TCP service to consume messages.\n\n\n\n\n\n\nWSO2Event\n\n\nExpose a Thrift and TCP services to consume events formatted as WSO2Events.\n\n\n\n\n\n\nEmail\n\n\nConsume emails via POP3 and IMAP protocols.\n\n\n\n\n\n\nJMS\n\n\nSubscribe to JMS topic or queue to consume events.\n\n\n\n\n\n\nFile\n\n\nReads files by tailing or as a whole to extract events out of them.\n\n\n\n\n\n\nRabbitMQ\n\n\nSubscribe to RabbitMQ topic to consume events.\n\n\n\n\n\n\nMQTT\n\n\nSubscribe to MQTT brokers to consume events.\n\n\n\n\n\n\nWebSocket\n\n\nCreate a web-socket connection or expose a service to consume messages.\n\n\n\n\n\n\nTwitter\n\n\nSubscribe to Twitter to consume tweets.\n\n\n\n\n\n\nAmazon SQS\n\n\nSubscribe to Amazon SQS to consume events.\n\n\n\n\n\n\nCDC\n\n\nPerform change data capture on databases.\n\n\n\n\n\n\nPrometheus\n\n\nConsume data from Prometheus agent.\n\n\n\n\n\n\n\n\nIn-memory\n is the only source inbuilt in Siddhi, and all other source types are implemented as extensions.   \n\n\nSource Mapper\n\n\nEach \n@source\n configuration can have a mapping denoted by the \n@map\n annotation that defines how to convert the incoming event\nformat to Siddhi events.\n\n\nThe \ntype\n parameter of the \n@map\n defines the map type to be used in converting the incoming events. The other parameters\nof \n@map\n annotation depends on the mapper selected, and some of its parameters can be optional.\n\n\nFor detailed information about the parameters see the documentation of the relevant mapper.\n\n\nMap Attributes\n\n\n@attributes\n is an optional annotation used with \n@map\n to define custom mapping. When \n@attributes\n is not provided, each mapper\nassumes that the incoming events adheres to its own default message format and attempt to convert the events from that format.\nBy adding the \n@attributes\n annotation, users can selectively extract data from the incoming message and assign them to the attributes.\n\n\nThere are two ways to configure \n@attributes\n.\n\n\n\n\n\n\nDefine attribute names as keys, and mapping configurations as values:\n\n  \n@attributes( \nattribute1\n='\nmapping\n', \nattributeN\n='\nmapping\n')\n\n\n\n\n\n\nDefine the mapping configurations in the same order as the attributes defined in stream definition:\n\n  \n@attributes( '\nmapping for attribute1\n', '\nmapping for attributeN\n')\n\n\n\n\n\n\nSupported Source Mapping Types\n\n\nThe following is the list of source mapping types supported by Siddhi:\n\n\n\n\n\n\n\n\nSource mapping type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPassThrough\n\n\nOmits data conversion on Siddhi events.\n\n\n\n\n\n\nJSON\n\n\nConverts JSON messages to Siddhi events.\n\n\n\n\n\n\nXML\n\n\nConverts XML messages to Siddhi events.\n\n\n\n\n\n\nTEXT\n\n\nConverts plain text messages to Siddhi events.\n\n\n\n\n\n\nAvro\n\n\nConverts Avro events to Siddhi events.\n\n\n\n\n\n\nWSO2Event\n\n\nConverts WSO2Events to Siddhi events.\n\n\n\n\n\n\nBinary\n\n\nConverts Siddhi specific binary events to Siddhi events.\n\n\n\n\n\n\nKey Value\n\n\nConverts key-value HashMaps to Siddhi events.\n\n\n\n\n\n\nCSV\n\n\nConverts CSV like delimiter separated events to Siddhi events.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nWhen the \n@map\n annotation is not provided \n@map(type='passThrough')\n is used as default, that passes the consumed Siddhi events directly to the streams without any data conversion.\n\n\n\n\nPassThrough\n is the only source mapper inbuilt in Siddhi, and all other source mappers are implemented as extensions.\n\n\nExample 1\n\n\nReceive \nJSON\n messages by exposing an \nHTTP\n service, and direct them to \nInputStream\n stream for processing.\nHere the \nHTTP\n service will be secured with basic authentication, receives events on all network interfaces on port \n8080\n and context \n/foo\n. The service expects the \nJSON\n messages to be on the default data format that's supported by the \nJSON\n mapper as follows.\n\n\n{\n\n  \nname\n:\nPaul\n,\n\n  \nage\n:\n20\n,\n\n  \ncountry\n:\nUK\n\n\n}\n\n\n\n\n\n\nThe configuration of the \nHTTP\n source and \nJSON\n source mapper to achieve the above is as follows.\n\n\n@\nsource\n(\ntype\n=\nhttp\n,\n \nreceiver\n.\nurl\n=\nhttp://0.0.0.0:8080/foo\n,\n\n  \n@\nmap\n(\ntype\n=\njson\n))\n\n\ndefine\n \nstream\n \nInputStream\n \n(\nname\n \nstring\n,\n \nage\n \nint\n,\n \ncountry\n \nstring\n);\n\n\n\n\n\n\nExample 2\n\n\nReceive \nJSON\n messages by exposing an \nHTTP\n service, and direct them to \nStockStream\n stream for processing.\nHere the incoming \nJSON\n, as given bellow, do not adhere to the default data format that's supported by the \nJSON\n mapper.\n\n\n{\n\n  \nportfolio\n:{\n\n    \nstock\n:{\n\n      \nvolume\n:\n100\n,\n\n      \ncompany\n:{\n\n        \nsymbol\n:\nFB\n\n      \n},\n\n      \nprice\n:\n55.6\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe configuration of the \nHTTP\n source and the custom \nJSON\n source mapping to achieve the above is as follows.\n\n\n@\nsource\n(\ntype\n=\nhttp\n,\n \nreceiver\n.\nurl\n=\nhttp://0.0.0.0:8080/foo\n,\n\n  \n@\nmap\n(\ntype\n=\njson\n,\n \nenclosing\n.\nelement\n=\n$.portfolio\n,\n\n    \n@\nattributes\n(\nsymbol\n \n=\n \nstock.company.symbol\n,\n \nprice\n \n=\n \nstock.price\n,\n\n                \nvolume\n \n=\n \nstock.volume\n)))\n\n\ndefine\n \nstream\n \nStockStream\n \n(\nsymbol\n \nstring\n,\n \nprice\n \nfloat\n,\n \nvolume\n \nlong\n);\n\n\n\n\n\n\nThe same can also be configured by omitting the attribute names as bellow.\n\n\n@\nsource\n(\ntype\n=\nhttp\n,\n \nreceiver\n.\nurl\n=\nhttp://0.0.0.0:8080/foo\n,\n\n  \n@\nmap\n(\ntype\n=\njson\n,\n \nenclosing\n.\nelement\n=\n$.portfolio\n,\n\n    \n@\nattributes\n(\nstock.company.symbol\n,\n \nstock.price\n,\n \nstock.volume\n)))\n\n\ndefine\n \nstream\n \nStockStream\n \n(\nsymbol\n \nstring\n,\n \nprice\n \nfloat\n,\n \nvolume\n \nlong\n);\n\n\n\n\n\n\nSink\n\n\nSinks consumes events from streams and publish them via multiple transports to external endpoints in various data formats.\n\n\nA sink configuration allows users to define a mapping to convert the Siddhi events in to the required output data format (such as \nJSON\n, \nTEXT\n, \nXML\n, etc.) and publish the events to the configured endpoints. When customizations to such mappings are not provided, Siddhi converts events to the predefined event format based on the stream definition and the configured message mapper type before publishing the events.\n\n\nPurpose\n\n\nSink provides a way to publish Siddhi events of a stream to external systems by converting events to their supported format.\n\n\nSyntax\n\n\nTo configure a stream to publish events via a sink, add the sink configuration to a stream definition by adding the \n@sink\n\nannotation with the required parameter values.\n\n\nThe sink syntax is as follows:\n\n\n@\nsink\n(\ntype\n=\nsink type\n,\n \nstatic\n.\nkey\n=\nvalue\n,\n \ndynamic\n.\nkey\n=\n{{\nvalue\n}}\n,\n\n    \n@\nmap\n(\ntype\n=\nmap type\n,\n \nstatic\n.\nkey\n=\nvalue\n,\n \ndynamic\n.\nkey\n=\n{{\nvalue\n}}\n,\n\n        \n@\npayload\n(\npayload mapping\n)\n\n    \n)\n\n\n)\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute1\n \ntype\n,\n \nattributeN\n \ntype\n);\n\n\n\n\n\n\n\n\nDynamic Properties\n\n\nThe sink and sink mapper properties that are categorized as \ndynamic\n have the ability to absorb attribute values\ndynamically from the Siddhi events of their associated streams. This can be configured by enclosing the relevant\nattribute names in double curly braces as\n{{...}}\n, and using it within the property values.\n\n\nSome valid dynamic properties values are:\n\n\n\n\n'{{attribute1}}'\n\n\n'This is {{attribute1}}'\n\n\n{{attribute1}} \n {{attributeN}}\n  \n\n\n\n\nHere the attribute names in the double curly braces will be replaced with the values from the events before they are published.\n\n\n\n\nThis syntax includes the following annotations.\n\n\nSink\n\n\nThe \ntype\n parameter of the \n@sink\n annotation defines the sink type that publishes the events.\nThe other parameters of the \n@sink\n annotation depends upon the selected sink type, and here\nsome of its parameters can be optional and/or dynamic.\n\n\nFor detailed information about the supported parameters see documentation of the relevant sink.\n\n\nThe following is a list of sink types supported by Siddhi:\n\n\n\n\n\n\n\n\nSource type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIn-memory\n\n\nAllow SiddhiApp to publish events to other SiddhiApps running on the same JVM.\n\n\n\n\n\n\nLog\n\n\nLogs the events appearing on the streams.\n\n\n\n\n\n\nHTTP\n\n\nPublish events to an HTTP endpoint.\n\n\n\n\n\n\nKafka\n\n\nPublish events to Kafka topic.\n\n\n\n\n\n\nTCP\n\n\nPublish events to a TCP service.\n\n\n\n\n\n\nWSO2Event\n\n\nPublish WSO2Events via Thrift or TCP protocols.\n\n\n\n\n\n\nEmail\n\n\nSend emails via SMTP protocols.\n\n\n\n\n\n\nJMS\n\n\nPublish events to JMS topics or queues.\n\n\n\n\n\n\nFile\n\n\nWrites events to files.\n\n\n\n\n\n\nRabbitMQ\n\n\nPublish events to RabbitMQ topics.\n\n\n\n\n\n\nMQTT\n\n\nPublish events to MQTT topics.\n\n\n\n\n\n\nWebSocket\n\n\nCreate a web-socket connection or expose a service to publish messages.\n\n\n\n\n\n\nAmazon SQS\n\n\nPublish events to Amazon SQS.\n\n\n\n\n\n\nPrometheus\n\n\nExpose data through Prometheus agent.\n\n\n\n\n\n\n\n\nDistributed Sink\n\n\nDistributed Sinks publish events from a defined stream to multiple endpoints using load balancing or partitioning strategies.\n\n\nAny sink can be used as a distributed sink. A distributed sink configuration allows users to define a common mapping to convert\nand send the Siddhi events for all its destination endpoints.\n\n\nPurpose\n\n\nDistributed sink provides a way to publish Siddhi events to multiple endpoints in the configured event format.\n\n\nSyntax\n\n\nTo configure distributed sink add the sink configuration to a stream definition by adding the \n@sink\n\nannotation and add the configuration parameters that are common of all the destination endpoints inside it,\nalong with the common parameters also add the \n@distribution\n annotation specifying the distribution strategy (i.e. \nroundRobin\n or \npartitioned\n) and \n@destination\n annotations providing each endpoint specific configurations.\n\n\nThe distributed sink syntax is as follows:\n\n\nRoundRobin Distributed Sink\n\n\nPublishes events to defined destinations in a round robin manner.\n\n\n@\nsink\n(\ntype\n=\nsink type\n,\n \ncommon\n.\nstatic\n.\nkey\n=\nvalue\n,\n \ncommon\n.\ndynamic\n.\nkey\n=\n{{\nvalue\n}}\n,\n\n    \n@\nmap\n(\ntype\n=\nmap type\n,\n \nstatic\n.\nkey\n=\nvalue\n,\n \ndynamic\n.\nkey\n=\n{{\nvalue\n}}\n,\n\n        \n@\npayload\n(\npayload mapping\n)\n\n    \n)\n\n    \n@\ndistribution\n(\nstrategy\n=\nroundRobin\n,\n\n        \n@\ndestination\n(\ndestination\n.\nspecific\n.\nkey\n=\nvalue\n),\n\n        \n@\ndestination\n(\ndestination\n.\nspecific\n.\nkey\n=\nvalue\n)))\n\n\n)\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute1\n \ntype\n,\n \nattributeN\n \ntype\n);\n\n\n\n\n\n\nPartitioned Distributed Sink\n\n\nPublishes events to defined destinations by partitioning them based on the partitioning key.\n\n\n@\nsink\n(\ntype\n=\nsink type\n,\n \ncommon\n.\nstatic\n.\nkey\n=\nvalue\n,\n \ncommon\n.\ndynamic\n.\nkey\n=\n{{\nvalue\n}}\n,\n\n    \n@\nmap\n(\ntype\n=\nmap type\n,\n \nstatic\n.\nkey\n=\nvalue\n,\n \ndynamic\n.\nkey\n=\n{{\nvalue\n}}\n,\n\n        \n@\npayload\n(\npayload mapping\n)\n\n    \n)\n\n    \n@\ndistribution\n(\nstrategy\n=\npartitioned\n,\n \npartitionKey\n=\npartition key\n,\n\n        \n@\ndestination\n(\ndestination\n.\nspecific\n.\nkey\n=\nvalue\n),\n\n        \n@\ndestination\n(\ndestination\n.\nspecific\n.\nkey\n=\nvalue\n)))\n\n\n)\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute1\n \ntype\n,\n \nattributeN\n \ntype\n);\n\n\n\n\n\n\nSink Mapper\n\n\nEach \n@sink\n configuration can have a mapping denoted by the \n@map\n annotation that defines how to convert Siddhi events to outgoing messages with the defined format.\n\n\nThe \ntype\n parameter of the \n@map\n defines the map type to be used in converting the outgoing events. The other parameters of \n@map\n annotation depends on the mapper selected, and some of its parameters can be optional and/or dynamic.\n\n\nFor detailed information about the parameters see the documentation of the relevant mapper.\n\n\nMap Payload\n\n\n@payload\n is an optional annotation used with \n@map\n to define custom mapping. When the \n@payload\n annotation is not provided, each mapper maps the outgoing events to its own default event format. The \n@payload\n annotation allow users to configure mappers to produce the output payload of their choice, and by using dynamic properties within the payload they can selectively extract and add data from the published Siddhi events.\n\n\nThere are two ways you to configure \n@payload\n annotation.\n\n\n\n\nSome mappers such as \nXML\n, \nJSON\n, and \nTest\n only accept one output payload: \n\n  \n@payload( 'This is a test message from {{user}}.')\n\n\nSome mappers such \nkey-value\n accept series of mapping values: \n\n  \n@payload( key1='mapping_1', 'key2'='user : {{user}}')\n \n\n  Here, the keys of payload mapping can be defined using the dot notation as \na.b.c\n, or using any constant string value as \n'$abc'\n.\n\n\n\n\nSupported Sink Mapping Types\n\n\nThe following is a list of sink mapping types supported by Siddhi:\n\n\n\n\n\n\n\n\nSink mapping type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPassThrough\n\n\nOmits data conversion on outgoing Siddhi events.\n\n\n\n\n\n\nJSON\n\n\nConverts Siddhi events to JSON messages.\n\n\n\n\n\n\nXML\n\n\nConverts Siddhi events to XML messages.\n\n\n\n\n\n\nTEXT\n\n\nConverts Siddhi events to plain text messages.\n\n\n\n\n\n\nAvro\n\n\nConverts Siddhi events to Avro Events.\n\n\n\n\n\n\nWSO2Event\n\n\nConverts Siddhi events to WSO2Event events.\n\n\n\n\n\n\nBinary\n\n\nConverts Siddhi events to Siddhi specific binary events.\n\n\n\n\n\n\nKey Value\n\n\nConverts Siddhi events to key-value HashMaps.\n\n\n\n\n\n\nCSV\n\n\nConverts Siddhi events to CSV like delimiter separated events.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nWhen the \n@map\n annotation is not provided \n@map(type='passThrough')\n is used as default, that passes the outgoing Siddhi events directly to the sinks without any data conversion.\n\n\n\n\nPassThrough\n is the only sink mapper inbuilt in Siddhi, and all other sink mappers are implemented as extensions.\n\n\nExample 1\n\n\nPublishes \nOutputStream\n events by converting them to \nJSON\n messages with the default format, and by sending to an \nHTTP\n endpoint \nhttp://localhost:8005/endpoint1\n, using \nPOST\n method, \nAccept\n header, and basic authentication having \nadmin\n is both username and password.\n\n\nThe configuration of the \nHTTP\n sink and \nJSON\n sink mapper to achieve the above is as follows.\n\n\n@\nsink\n(\ntype\n=\nhttp\n,\n \npublisher\n.\nurl\n=\nhttp://localhost:8005/endpoint\n,\n\n      \nmethod\n=\nPOST\n,\n \nheaders\n=\nAccept-Date:20/02/2017\n,\n\n      \nbasic\n.\nauth\n.\nenabled\n=\ntrue\n,\n \nbasic\n.\nauth\n.\nusername\n=\nadmin\n,\n\n      \nbasic\n.\nauth\n.\npassword\n=\nadmin\n,\n\n      \n@\nmap\n(\ntype\n=\njson\n))\n\n\ndefine\n \nstream\n \nOutputStream\n \n(\nname\n \nstring\n,\n \nage\n \nint\n,\n \ncountry\n \nstring\n);\n\n\n\n\n\n\nThis will publish a \nJSON\n message on the following format:\n\n\n{\n\n  \nevent\n:{\n\n    \nname\n:\nPaul\n,\n\n    \nage\n:\n20\n,\n\n    \ncountry\n:\nUK\n\n  \n}\n\n\n}\n\n\n\n\n\n\nExample 2\n\n\nPublishes \nStockStream\n events by converting them to user defined \nJSON\n messages, and by sending to an \nHTTP\n endpoint \nhttp://localhost:8005/stocks\n.\n\n\nThe configuration of the \nHTTP\n sink and custom \nJSON\n sink mapping to achieve the above is as follows.\n\n\n@\nsink\n(\ntype\n=\nhttp\n,\n \npublisher\n.\nurl\n=\nhttp://localhost:8005/stocks\n,\n\n      \n@\nmap\n(\ntype\n=\njson\n,\n \nvalidate\n.\njson\n=\ntrue\n,\n \nenclosing\n.\nelement\n=\n$.Portfolio\n,\n\n           \n@\npayload\n(\n{\nStockData\n:{ \nSymbol\n:\n{{\nsymbol\n}}\n, \nPrice\n:{{price}} }}\n)))\n\n\ndefine\n \nstream\n \nStockStream\n \n(\nsymbol\n \nstring\n,\n \nprice\n \nfloat\n,\n \nvolume\n \nlong\n);\n\n\n\n\n\n\nThis will publish a single event as the \nJSON\n message on the following format:\n\n\n{\n\n  \nPortfolio\n:{\n\n    \nStockData\n:{\n\n      \nSymbol\n:\nGOOG\n,\n\n      \nPrice\n:\n55.6\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThis can also publish multiple events together as a \nJSON\n message on the following format:\n\n\n{\n\n  \nPortfolio\n:[\n\n    \n{\n\n      \nStockData\n:{\n\n        \nSymbol\n:\nGOOG\n,\n\n        \nPrice\n:\n55.6\n\n      \n}\n\n    \n},\n\n    \n{\n\n      \nStockData\n:{\n\n        \nSymbol\n:\nFB\n,\n\n        \nPrice\n:\n57.0\n\n      \n}\n\n    \n}\n\n  \n]\n  \n\n}\n\n\n\n\n\n\nExample 3\n\n\nPublishes events from the \nOutputStream\n stream to multiple the \nHTTP\n endpoints using a partitioning strategy. Here the events are sent to either \nhttp://localhost:8005/endpoint1\n or \nhttp://localhost:8006/endpoint2\n based on the partitioning key \ncountry\n. It uses default \nJSON\n mapping, \nPOST\n method, and used \nadmin\n as both the username and the password when publishing to both the endpoints.\n\n\nThe configuration of the distributed \nHTTP\n sink and \nJSON\n sink mapper to achieve the above is as follows.\n\n\n@\nsink\n(\ntype\n=\nhttp\n,\n \nmethod\n=\nPOST\n,\n \nbasic\n.\nauth\n.\nenabled\n=\ntrue\n,\n\n      \nbasic\n.\nauth\n.\nusername\n=\nadmin\n,\n \nbasic\n.\nauth\n.\npassword\n=\nadmin\n,\n\n      \n@\nmap\n(\ntype\n=\njson\n),\n\n      \n@\ndistribution\n(\nstrategy\n=\npartitioned\n,\n \npartitionKey\n=\ncountry\n,\n\n        \n@\ndestination\n(\npublisher\n.\nurl\n=\nhttp://localhost:8005/endpoint1\n),\n\n        \n@\ndestination\n(\npublisher\n.\nurl\n=\nhttp://localhost:8006/endpoint2\n)))\n\n\ndefine\n \nstream\n \nOutputStream\n \n(\nname\n \nstring\n,\n \nage\n \nint\n,\n \ncountry\n \nstring\n);\n\n\n\n\n\n\nThis will partition the outgoing events and publish all events with the same country attribute value to the same endpoint. The \nJSON\n message published will be on the following format:\n\n\n{\n\n  \nevent\n:{\n\n    \nname\n:\nPaul\n,\n\n    \nage\n:\n20\n,\n\n    \ncountry\n:\nUK\n\n  \n}\n\n\n}\n\n\n\n\n\n\nError Handling\n\n\nErrors in Siddhi can be handled at the Streams and in Sinks.\n\n\nError Handling at Stream\n\n\nWhen errors are thrown by Siddhi elements subscribed to the stream, the error gets propagated up to the stream that delivered the event to those Siddhi elements. By default the error is logged and dropped at the stream, but this behavior can be altered by by adding \n@OnError\n annotation to the corresponding stream definition.\n\n@OnError\n annotation can help users to capture the error and the associated event, and handle them gracefully by sending them to a fault stream.\n\n\nThe \n@OnError\n annotation and the required \naction\n to be specified as bellow.\n\n\n@\nOnError\n(\naction\n=\non error action\n)\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n\n                             \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n);\n\n\n\n\n\n\nThe \naction\n parameter of the \n@OnError\n annotation defines the action to be executed during failure scenarios.\nThe following actions can be specified to \n@OnError\n annotation to handle erroneous scenarios.\n\n\n\n\nLOG\n : Logs the event with the error, and drops the event. This is the default action performed even when \n@OnError\n annotation is not defined.\n\n\nSTREAM\n: Creates a fault stream and redirects the event and the error to it. The created fault stream will have all the attributes defined in the base stream to capture the error causing event, and in addition it also contains \n_error\n attribute of type \nobject\n to containing the error information. The fault stream can be referred by adding \n!\n in front of the base stream name as \n!\nstream name\n.\n\n\n\n\nExample\n\n\nHandle errors in \nTempStream\n by redirecting the errors to a fault stream.\n\n\nThe configuration of \nTempStream\n stream and \n@OnError\n annotation is as follows.\n\n\n@\nOnError\n(\nname\n=\nSTREAM\n)\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\n\n\n\nSiddhi will infer and automatically defines the fault stream of \nTempStream\n as given bellow.\n\n\ndefine\n \nstream\n \n!\nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n,\n \n_error\n \nobject\n);\n\n\n\n\n\n\nThe SiddhiApp extending the above the use-case by adding failure generation and error handling with the use of \nqueries\n is as follows.\n\n\nNote: Details on writing processing logics via \nqueries\n will be explained in later sections.\n\n\n-- Define fault stream to handle error occurred at TempStream subscribers\n\n\n@\nOnError\n(\nname\n=\nSTREAM\n)\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\n-- Error generation through a custom function `createError()`\n\n\n@\nname\n(\nerror-generation\n)\n\n\nfrom\n \nTempStream\n#\ncustom\n:\ncreateError\n()\n\n\ninsert\n \ninto\n \nIgnoreStream1\n;\n\n\n\n-- Handling error by simply logging the event and error.\n\n\n@\nname\n(\nhandle-error\n)\n\n\nfrom\n \n!\nTempStream\n#\nlog\n(\nError Occurred!\n)\n\n\nselect\n \ndeviceID\n,\n \nroomNo\n,\n \ntemp\n,\n \n_error\n\n\ninsert\n \ninto\n \nIgnoreStream2\n;\n\n\n\n\n\n\nError Handling at Sink\n\n\nThere can be cases where external systems becoming unavailable or coursing errors when the events are published to them. By default sinks log and drop the events causing event losses, and this can be handled gracefully by configuring \non.error\n parameter of the \n@sink\n annotation.\n\n\nThe \non.error\n parameter of the \n@sink\n annotation can be specified as bellow.\n\n\n@\nsink\n(\ntype\n=\nsink type\n,\n \non\n.\nerror\n=\non error action\n,\n \nkey\n=\nvalue\n,\n \n...)\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n\n                             \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n);\n\n\n\n\n\n\nThe following actions can be specified to \non.error\n parameter of \n@sink\n annotation to handle erroneous scenarios.\n\n\n\n\nLOG\n : Logs the event with the error, and drops the event. This is the default action performed even when \non.error\n parameter is not defined on the \n@sink\n annotation.\n\n\nWAIT\n : Publishing threads wait in \nback-off and re-trying\n mode, and only send the events when the connection is re-established. During this time the threads will not consume any new messages causing the systems to introduce back pressure on the systems that publishes to it.\n\n\nSTREAM\n: Pushes the failed events with the corresponding error to the associated fault stream the sink belongs to.\n\n\n\n\nExample 1\n\n\nIntroduce back pressure on the threads who bring events via \nTempStream\n when the system cannot connect to Kafka.\n\n\nThe configuration of \nTempStream\n stream and \n@sink\n Kafka annotation with \non.error\n property is as follows.\n\n\n@\nsink\n(\ntype\n=\nkafka\n,\n \non\n.\nerror\n=\nWAIT\n,\n \ntopic\n=\n{{roomNo}}\n,\n\n      \nbootstrap\n.\nservers\n=\nlocalhost:9092\n,\n\n      \n@\nmap\n(\ntype\n=\nxml\n))\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\n\n\n\nExample 2\n\n\nSend events to the fault stream of \nTempStream\n when the system cannot connect to Kafka.\n\n\nThe configuration of \nTempStream\n stream with associated fault stream, \n@sink\n Kafka annotation with \non.error\n property and a \nqueries\n to handle the error is as follows.\n\n\nNote: Details on writing processing logics via \nqueries\n will be explained in later sections.\n\n\n@\nOnError\n(\nname\n=\nSTREAM\n)\n\n\n@\nsink\n(\ntype\n=\nkafka\n,\n \non\n.\nerror\n=\nSTREAM\n,\n \ntopic\n=\n{{roomNo}}\n,\n\n      \nbootstrap\n.\nservers\n=\nlocalhost:9092\n,\n\n      \n@\nmap\n(\ntype\n=\nxml\n))\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\n-- Handling error by simply logging the event and error.\n\n\n@\nname\n(\nhandle-error\n)\n\n\nfrom\n \n!\nTempStream\n#\nlog\n(\nError Occurred!\n)\n\n\nselect\n \ndeviceID\n,\n \nroomNo\n,\n \ntemp\n,\n \n_error\n\n\ninsert\n \ninto\n \nIgnoreStream\n;\n\n\n\n\n\n\nQuery\n\n\nQuery defines the processing logic in Siddhi. It consumes events from one or more streams, \ndefined-windows\n, \ntables\n, and/or \naggregations\n, process the events in a streaming manner, and generate output events into a \nstream\n, \ndefined-window\n, or \ntable\n.\n\n\nPurpose\n\n\nA query provides a way to process the events in the order they arrive and produce output using both stateful and stateless complex event processing and stream processing operations.\n\n\nSyntax\n\n\nThe high level query syntax for defining processing logics is as follows:\n\n\n@\nname\n(\nquery name\n)\n\n\nfrom\n \ninput\n\n\nprojection\n\n\noutput\n \naction\n\n\n\n\n\n\nThe following parameters are used to configure a stream definition.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nquery name\n\n\nThe name of the query. Since naming the query (i.e the \n@name('\nquery name\n')\n annotation) is optional, when the name is not provided Siddhi assign a system generated name for the query.\n\n\n\n\n\n\ninput\n\n\nDefines the means of event consumption via \nstreams\n, \nnamed-windows\n, \ntables\n, and/or \nnamed-aggregations\n, and defines the processing logic using \nfilters\n, \nwindows\n, \nstream-functions\n, \njoins\n, \npatterns\n and \nsequences\n.\n\n\n\n\n\n\nprojection\n\n\nGenerates output event attributes using \nselect\n, \nfunctions\n, \naggregation-functions\n, and \ngroup by\n operations, and filters the generated the output using \nhaving\n, \nlimit \n offset\n, \norder by\n, and \noutput rate limiting\n operations before sending them out. Here the projection is optional and when it is omitted all the input events will be sent to the output as it is.\n\n\n\n\n\n\noutput action\n\n\nDefines output action (such as \ninsert into\n, \nupdate\n, \ndelete\n, etc) that needs to be performed by the generated events on a \nstream\n, \nnamed-window\n, or \ntable\n\n\n\n\n\n\n\n\nExample\n\n\nA query consumes events from the \nTempStream\n stream and output only the \nroomNo\n and \ntemp\n attributes to the \nRoomTempStream\n stream, from which another query consumes the events and sends all its attributes to \nAnotherRoomTempStream\n stream.\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \nTempStream\n\n\nselect\n \nroomNo\n,\n \ntemp\n\n\ninsert\n \ninto\n \nRoomTempStream\n;\n\n\n\nfrom\n \nRoomTempStream\n\n\ninsert\n \ninto\n \nAnotherRoomTempStream\n;\n\n\n\n\n\n\n\n\nInferred Stream\n\n\nHere, the \nRoomTempStream\n and \nAnotherRoomTempStream\n streams are an inferred streams, which means their stream definitions are inferred from the queries and they can be used same as any other defined stream without any restrictions.  \n\n\n\n\nSelect\n\n\nThe select clause in Siddhi query defines the output event attributes of the query. Following are some basic query projection operations supported by select.\n\n\n\n    \n\n        \nAction\n\n        \nDescription\n\n    \n\n    \n\n        \nSelect specific attributes for projection\n\n        \nOnly select some of the input attributes as query output attributes.\n            \n\n            E.g., Select and output only \nroomNo\n and \ntemp\n attributes from the \nTempStream\n stream.\n            \nfrom TempStream\nselect roomNo, temp\ninsert into RoomTempStream;\n\n        \n\n    \n\n    \n\n        \nSelect all attributes for projection\n\n        \nSelect all input attributes as query output attributes. This can be done by using asterisk (\n * \n) or by omitting the \nselect\n clause itself.\n            \n\n            E.g., Both following queries select all attributes of \nTempStream\n input stream and output all attributes to \nNewTempStream\n stream.\n            \nfrom TempStream\nselect * \ninsert into NewTempStream;\n\n            or\n            \nfrom TempStream\ninsert into NewTempStream;\n\n        \n\n    \n\n    \n\n        \nName attribute\n\n        \nProvide a unique name for each output attribute generated by the query. This can help to rename the selected input attributes or assign an attribute name to a projection operation such as function, aggregate-function, mathematical operation, etc, using \nas\n keyword.\n            \n\n            E.g., Query that renames input attribute \ntemp\n to \ntemperature\n and function \ncurrentTimeMillis()\n as \ntime\n.\n            \nfrom TempStream \nselect roomNo, temp as temperature, currentTimeMillis() as time\ninsert into RoomTempStream;\n\n        \n\n    \n\n    \n\n        \nConstant values as attributes\n\n        \nCreates output attributes with a constant value.\n            \n\n            The constant values can be defined as follows.\n            \n\n                \n\n                    \nAttribute Type\n\n                    \nFormat\n\n                    \nExample\n\n                \n\n                \n\n                    \nint\n\n                    \n+\n\n                    \n123\n, \n-75\n, \n+95\n\n                \n\n                \n\n                    \nlong\n\n                    \n+L\n\n                    \n123000L\n, \n-750l\n, \n+154L\n\n                \n\n                \n\n                    \nfloat\n\n                    \n(\n+)?('.'\n*)?\n(E(-|+)?\n+)?F\n\n                    \n123.0f\n, \n-75.0e-10F\n,\n+95.789f\n\n                \n\n                \n\n                    \ndouble\n\n                    \n(\n+)?('.'\n*)?\n(E(-|+)?\n+)?D?\n\n                    \n123.0\n,\n123.0D\n,\n-75.0e-10D\n,\n+95.789d\n\n                \n\n                \n\n                    \nbool\n\n                    \n(true|false)\n\n                    \ntrue\n, \nfalse\n, \nTRUE\n, \nFALSE\n\n                \n\n                \n\n                    \nstring\n\n                    \n'(\n* !('|\"|\"\"\"|\n line\n))'\n or \n \n\"(\n* !(\"|\"\"\"|\n line\n))\"\n or \n\"\"\"(\n* !(\"\"\"))\"\"\"\n \n\n                    \n'Any text.'\n, \n\"Text with 'single' quotes.\"\n, \n\"\"\"\nText with 'single' quotes,\n\"double\" quotes, and new lines.\n\"\"\"\n\n                \n\n            \n\n\n            E.g., Query specifying \n'C'\n as the constant value for the \nscale\n attribute.\n            \nfrom TempStream\nselect roomNo, temp, 'C' as scale\ninsert into RoomTempStream;\n    \n        \n\n    \n\n    \n\n        \nMathematical and logical expressions in attributes\n\n        \nDefines the mathematical and logical operations that need to be performed to generating output attribute values. These expressions are executed in the precedence order given below.\n            \n\n            \nOperator precedence\n\n            \n\n                \n\n                    \nOperator\n\n                    \nDistribution\n\n                    \nExample\n\n                \n\n                \n\n                    \n()\n\n                    \nScope\n\n                    \n(cost + tax) * 0.05\n\n                \n\n                \n\n                    \nIS NULL\n\n                    \nNull check\n\n                    \ndeviceID is null\n\n                \n\n                \n\n                    \nNOT\n\n                    \nLogical NOT\n\n                    \nnot (price > 10)\n\n                \n\n                \n\n                    \n * \n,\n/\n,\n%\n\n                    \nMultiplication, division, modulus\n\n                    \ntemp * 9/5 + 32\n\n                \n\n                \n\n                    \n+\n,\n-\n\n                    \nAddition, subtraction\n\n                    \ntemp * 9/5 - 32\n\n                \n\n                \n\n                    \n<\n,\n<\n=\n,\n>\n,\n>=\n\n                    \nComparators: less-than, greater-than-equal, greater-than, less-than-equal\n\n                    \ntotalCost >= price * quantity\n\n                \n\n                \n\n                    \n==\n,\n!=\n\n                    \nComparisons: equal, not equal\n\n                    \ntotalCost !=  price * quantity\n\n                \n\n                \n\n                    \nIN\n\n                    \nChecks if value exist in the table\n\n                    \nroomNo in ServerRoomsTable\n\n                \n\n                \n\n                    \nAND\n\n                    \nLogical AND\n\n                    \ntemp \n<\n 40 and humidity \n<\n 40\n\n                \n\n                \n\n                    \nOR\n\n                    \nLogical OR\n\n                    \nhumidity \n<\n 40 or humidity >= 60\n\n                \n\n            \n\n            E.g., Query converts temperature from Celsius to Fahrenheit, and identifies rooms with room number between 10 and 15 as server rooms.\n            \nfrom TempStream\nselect roomNo, temp * 9/5 + 32 as temp, 'F' as scale,\n       roomNo > 10 and roomNo \n<\n 15 as isServerRoom\ninsert into RoomTempStream;\n       \n    \n\n\n\n\n\n\nFunction\n\n\nFunction are pre-configured operations that can consumes zero, or more parameters and always produce a single value as result. It can be used anywhere an attribute can be used.\n\n\nPurpose\n\n\nFunctions encapsulate pre-configured reusable execution logic allowing users to execute the logic anywhere just by calling the function. This also make writing SiddhiApps simple and easy to understand.\n\n\nFunction Parameters\n\n\nFunctions parameters are the input to the function. They can be attributes, constant values, results of other functions, results of mathematical or logical expressions, or time values. The number and type of parameters a function accepts depend on the function itself.\n\n\n\n\nNote\n\n\nFunctions, mathematical expressions, and logical expressions can be used in a nested manner.\n\n\n\n\nTime\n\n\nTime is a special parameter that denotes time using digits and their unit in the format \n(\ndigit\n+ \nunit\n)+\n. During the execution, the time parameters get converted into milliseconds and return as long values.\n\n\n\n    \n\n        \n\n            Unit  \n        \n\n        \n\n            Syntax\n        \n\n    \n\n    \n\n        \n\n            Year\n        \n\n        \n\n            \nyear\n | \nyears\n\n        \n\n    \n\n    \n\n        \n\n            Month\n        \n\n        \n\n            \nmonth\n | \nmonths\n\n        \n\n    \n\n    \n\n        \n\n            Week\n        \n\n        \n\n            \nweek\n | \nweeks\n\n        \n\n    \n\n    \n\n        \n\n            Day\n        \n\n        \n\n            \nday\n | \ndays\n\n        \n\n    \n\n    \n\n        \n\n            Hour\n        \n\n        \n\n           \nhour\n | \nhours\n\n        \n\n    \n\n    \n\n        \n\n           Minutes\n        \n\n        \n\n           \nminute\n | \nminutes\n | \nmin\n\n        \n\n    \n\n    \n\n        \n\n           Seconds\n        \n\n        \n\n           \nsecond\n | \nseconds\n | \nsec\n\n        \n\n    \n\n    \n\n        \n\n           Milliseconds\n        \n\n        \n\n           \nmillisecond\n | \nmilliseconds\n\n        \n\n    \n\n\n\n\n\nE.g. Pass \n1 hour and 25 minutes\n as the input for \ntest()\n function. \n\n\ntest(1 hour 25 min)\n\n\nFollowing are some inbuilt Siddhi functions, for more functions refer \nexecution extensions\n .\n\n\n\n\n\n\n\n\nInbuilt function\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\neventTimestamp\n\n\nReturns event's timestamp.\n\n\n\n\n\n\ncurrentTimeMillis\n\n\nReturns current time of SiddhiApp runtime.\n\n\n\n\n\n\ndefault\n\n\nReturns a default value if the parameter is null.\n\n\n\n\n\n\nifThenElse\n\n\nReturns parameters based on a conditional parameter.\n\n\n\n\n\n\nUUID\n\n\nGenerates a UUID.\n\n\n\n\n\n\ncast\n\n\nCasts parameter type.\n\n\n\n\n\n\nconvert\n\n\nConverts parameter type.\n\n\n\n\n\n\ncoalesce\n\n\nReturns first not null input parameter.\n\n\n\n\n\n\nmaximum\n\n\nReturns the maximum value of all parameters.\n\n\n\n\n\n\nminimum\n\n\nReturns the minimum value of all parameters.\n\n\n\n\n\n\ninstanceOfBoolean\n\n\nChecks if the parameter is an instance of Boolean.\n\n\n\n\n\n\ninstanceOfDouble\n\n\nChecks if the parameter is an instance of Double.\n\n\n\n\n\n\ninstanceOfFloat\n\n\nChecks if the parameter is an instance of Float.\n\n\n\n\n\n\ninstanceOfInteger\n\n\nChecks if the parameter is an instance of Integer.\n\n\n\n\n\n\ninstanceOfLong\n\n\nChecks if the parameter is an instance of Long.\n\n\n\n\n\n\ninstanceOfString\n\n\nChecks if the parameter is an instance of String.\n\n\n\n\n\n\ncreateSet\n\n\nCreates  HashSet with given input parameters.\n\n\n\n\n\n\nsizeOfSet\n\n\nReturns number of items in the HashSet, that's passed as a parameter.\n\n\n\n\n\n\n\n\nExample\n\n\nQuery that converts the \nroomNo\n to \nstring\n using \nconvert\n function, finds the maximum temperature reading with \nmaximum\n function, and adds a unique \nmessageID\n using the \nUUID\n function.\n\n\nfrom\n \nTempStream\n\n\nselect\n \nconvert\n(\nroomNo\n,\n \nstring\n)\n \nas\n \nroomNo\n,\n \nmaximum\n(\ntempReading1\n,\n \ntempReading2\n)\n \nas\n \ntemp\n,\n \nUUID\n()\n \nas\n \nmessageID\n\n\ninsert\n \ninto\n \nRoomTempStream\n;\n\n\n\n\n\n\nFilter\n\n\nFilters are included in queries to filter information from input streams based on a specified condition.\n\n\nPurpose\n\n\nA filter allows you to separate events that match a specific condition as the output, or for further processing.\n\n\nSyntax\n\n\nFilter conditions should be defined in square brackets next to the input stream name as shown below.\n\n\nfrom\n \ninput\n \nstream\n[\nfilter\n \ncondition\n]\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nExample\n\n\nThis query filters all server rooms of which the room number is within the range of 100-210, and having temperature greater than 40 degrees\nfrom the \nTempStream\n stream, and inserts the results into the \nHighTempStream\n stream.\n\n\nfrom\n \nTempStream\n[(\nroomNo\n \n=\n \n100\n \nand\n \nroomNo\n \n \n210\n)\n \nand\n \ntemp\n \n \n40\n]\n\n\nselect\n \nroomNo\n,\n \ntemp\n\n\ninsert\n \ninto\n \nHighTempStream\n;\n\n\n\n\n\n\nWindow\n\n\nWindows allow you to capture a subset of events based on a specific criterion from an input stream for calculation.\nEach input stream can only have a maximum of one window.\n\n\nPurpose\n\n\nTo create subsets of events within a stream based on time duration, number of events, etc for processing.\nA window can operate in a sliding or tumbling (batch) manner.\n\n\nSyntax\n\n\nThe \n#window\n prefix should be inserted next to the relevant stream in order to use a window.\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\nparameter\n,\n \nparameter\n,\n \n...\n \n)\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \nevent\n \ntype\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\nNote\n\n\nFilter condition can be applied both before and/or after the window\n\n\n\n\nExample\n\n\nIf you want to identify the maximum temperature out of the last 10 events, you need to define a \nlength\n window of 10 events.\n This window operates in a sliding mode where the following 3 subsets are calculated when a list of 12 events are received in a sequential order.\n\n\n\n\n\n\n\n\nSubset\n\n\nEvent Range\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1-10\n\n\n\n\n\n\n2\n\n\n2-11\n\n\n\n\n\n\n3\n\n\n3-12\n\n\n\n\n\n\n\n\nThe following query finds the maximum temperature out of \nlast 10 events\n from the \nTempStream\n stream,\nand inserts the results into the \nMaxTempStream\n stream.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\nlength\n(\n10\n)\n\n\nselect\n \nmax\n(\ntemp\n)\n \nas\n \nmaxTemp\n\n\ninsert\n \ninto\n \nMaxTempStream\n;\n\n\n\n\n\n\nIf you define the maximum temperature reading out of every 10 events, you need to define a \nlengthBatch\n window of 10 events.\nThis window operates as a batch/tumbling mode where the following 3 subsets are calculated when a list of 30 events are received in a sequential order.\n\n\n\n\n\n\n\n\nSubset\n\n\nEvent Range\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1-10\n\n\n\n\n\n\n2\n\n\n11-20\n\n\n\n\n\n\n3\n\n\n21-30\n\n\n\n\n\n\n\n\nThe following query finds the maximum temperature out of \nevery 10 events\n from the \nTempStream\n stream,\nand inserts the results into the \nMaxTempStream\n stream.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\nlengthBatch\n(\n10\n)\n\n\nselect\n \nmax\n(\ntemp\n)\n \nas\n \nmaxTemp\n\n\ninsert\n \ninto\n \nMaxTempStream\n;\n\n\n\n\n\n\n\n\nNote\n\n\nSimilar operations can be done based on time via \ntime\n windows and \ntimeBatch\n windows and for others.\nCode segments such as \n#window.time(10 min)\n considers events that arrive during the last 10 minutes in a sliding manner, and the \n#window.timeBatch(2 min)\n considers events that arrive every 2 minutes in a tumbling manner.\n\n\n\n\nFollowing are some inbuilt windows shipped with Siddhi. For more window types, see execution \nextensions\n.\n\n\n\n\ntime\n\n\ntimeBatch\n\n\nbatch\n\n\ntimeLength\n\n\nlength\n\n\nlengthBatch\n\n\nsort\n\n\nfrequent\n\n\nlossyFrequent\n\n\nsession\n\n\ncron\n\n\nexternalTime\n\n\nexternalTimeBatch\n\n\ndelay\n\n\n\n\nOutput event types\n\n\nProjection of the query depends on the output event types such as, \ncurrent\n and \nexpired\n event types.\n By default all queries produce \ncurrent\n events and only queries with windows produce \nexpired\n events\n when events expire from the window. You can specify whether the output of a query should be only current events, only expired events or both current and expired events.\n\n\nNote!\n Controlling the output event types does not alter the execution within the query, and it does not affect the accuracy of the query execution.  \n\n\nThe following keywords can be used with the output stream to manipulate output.\n\n\n\n\n\n\n\n\nOutput event types\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncurrent events\n\n\nOutputs events when incoming events arrive to be processed by the query. \n This is default when no specific output event type is specified.\n\n\n\n\n\n\nexpired events\n\n\nOutputs events when events expires from the window.\n\n\n\n\n\n\nall events\n\n\nOutputs events when incoming events arrive to be processed by the query as well as \n when events expire from the window.\n\n\n\n\n\n\n\n\nThe output event type keyword can be used between \ninsert\n and \ninto\n as shown in the following example.\n\n\nExample\n\n\nThis query delays all events in a stream by 1 minute.  \n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntime\n(\n1\n \nmin\n)\n\n\nselect\n \n*\n\n\ninsert\n \nexpired\n \nevents\n \ninto\n \nDelayedTempStream\n\n\n\n\n\n\nAggregate function\n\n\nAggregate functions perform aggregate calculations in the query.\nWhen a window is defined the aggregation is restricted within that window. If no window is provided aggregation is performed from the start of the Siddhi application.\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\nparameter\n,\n \nparameter\n,\n \n...\n \n)\n\n\nselect\n \naggregate\n \nfunction\n(\nparameter\n,\n \nparameter\n,\n \n...\n \n)\n \nas\n \nattribute\n \nname\n,\n \nattribute2\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nAggregate Parameters\n\n\nAggregate parameters can be attributes, constant values, results of other functions or aggregates, results of mathematical or logical expressions, or time parameters.\nAggregate parameters configured in a query  depends on the aggregate function being called.\n\n\nExample\n\n\nThe following query calculates the average value for the \ntemp\n attribute of the \nTempStream\n stream. This calculation is done for the last 10 minutes in a sliding manner, and the result is output as \navgTemp\n to the \nAvgTempStream\n output stream.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntime\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n,\n \ndeviceID\n\n\ninsert\n \ninto\n \nAvgTempStream\n;\n\n\n\n\n\n\nFollowing are some inbuilt aggregation functions shipped with Siddhi, for more aggregation functions, see execution \nextensions\n.\n\n\n\n\navg\n\n\nsum\n\n\nmax\n\n\nmin\n\n\ncount\n\n\ndistinctCount\n\n\nmaxForever\n\n\nminForever\n\n\nstdDev\n\n\n\n\nGroup By\n\n\nGroup By allows you to group the aggregate based on specified attributes.\n\n\nSyntax\n\nThe syntax for the Group By aggregate function is as follows:\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(...)\n\n\nselect\n \naggregate\n \nfunction\n(\n \nparameter\n,\n \nparameter\n,\n \n...)\n \nas\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n,\n \n...\n\n\ngroup\n \nby\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nExample\n\nThe following query calculates the average temperature per \nroomNo\n and \ndeviceID\n combination, for events that arrive at the \nTempStream\n stream\nfor a sliding time window of 10 minutes.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntime\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n,\n \ndeviceID\n\n\ngroup\n \nby\n \nroomNo\n,\n \ndeviceID\n\n\ninsert\n \ninto\n \nAvgTempStream\n;\n\n\n\n\n\n\nHaving\n\n\nHaving allows you to filter events after processing the \nselect\n statement.\n\n\nPurpose\n\nThis allows you to filter the aggregation output.\n\n\nSyntax\n\nThe syntax for the Having clause is as follows:\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\n \n...\n \n)\n\n\nselect\n \naggregate\n \nfunction\n(\n \nparameter\n,\n \nparameter\n,\n \n...)\n \nas\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n,\n \n...\n\n\ngroup\n \nby\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n \n...\n\n\nhaving\n \ncondition\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nExample\n\n\nThe following query calculates the average temperature per room for the last 10 minutes, and alerts if it exceeds 30 degrees.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntime\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n\n\ngroup\n \nby\n \nroomNo\n\n\nhaving\n \navgTemp\n \n \n30\n\n\ninsert\n \ninto\n \nAlertStream\n;\n\n\n\n\n\n\nOrder By\n\n\nOrder By allows you to order the aggregated result in ascending and/or descending order based on specified attributes. By default ordering will be done in\nascending manner. User can use 'desc' keyword to order in descending manner.\n\n\nSyntax\n\nThe syntax for the Order By clause is as follows:\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\n \n...\n \n)\n\n\nselect\n \naggregate\n \nfunction\n(\n \nparameter\n,\n \nparameter\n,\n \n...)\n \nas\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n,\n \n...\n\n\ngroup\n \nby\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n \n...\n\n\nhaving\n \ncondition\n\n\norder\n \nby\n \nattribute1\n \nname\n \n(\nasc\n \n|\n \ndesc\n)\n?\n,\n \nattribute2\n \nname\n \n(\nascend\n/\ndescend\n)\n?\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nExample\n\n\nThe following query calculates the average temperature per \nroomNo\n and \ndeviceID\n combination for every 10 minutes, and generate output events\nby ordering them in the ascending order of the room's avgTemp and then by the descending order of roomNo.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntimeBatch\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n,\n \ndeviceID\n\n\ngroup\n \nby\n \nroomNo\n,\n \ndeviceID\n\n\norder\n \nby\n \navgTemp\n,\n \nroomNo\n \ndesc\n\n\ninsert\n \ninto\n \nAvgTempStream\n;\n\n\n\n\n\n\nLimit \n Offset\n\n\nWhen events are emitted as a batch, offset allows you to offset beginning of the output event batch and limit allows you to limit the number of events in the batch from the defined offset.\nWith this users can specify which set of events need be emitted.\n\n\nSyntax\n\nThe syntax for the Limit \n Offset clause is as follows:\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\n \n...\n \n)\n\n\nselect\n \naggregate\n \nfunction\n(\n \nparameter\n,\n \nparameter\n,\n \n...)\n \nas\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n,\n \n...\n\n\ngroup\n \nby\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n \n...\n\n\nhaving\n \ncondition\n\n\norder\n \nby\n \nattribute1\n \nname\n \n(\nasc\n \n|\n \ndesc\n)\n?\n,\n \nattribute2\n \nname\n \n(\nascend\n/\ndescend\n)\n?\n,\n \n...\n\n\nlimit\n \npositive\n \ninterger\n?\n\n\noffset\n \npositive\n \ninterger\n?\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nHere both \nlimit\n and \noffset\n are optional where \nlimit\n by default output all the events and \noffset\n by default set to \n0\n.\n\n\nExample\n\nThe following query calculates the average temperature per \nroomNo\n and \ndeviceID\n combination, for events that arrive at the \nTempStream\n stream\nfor every 10 minutes and emits two events with highest average temperature.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntimeBatch\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n,\n \ndeviceID\n\n\ngroup\n \nby\n \nroomNo\n,\n \ndeviceID\n\n\norder\n \nby\n \navgTemp\n \ndesc\n\n\nlimit\n \n2\n\n\ninsert\n \ninto\n \nHighestAvgTempStream\n;\n\n\n\n\n\n\nThe following query calculates the average temperature per \nroomNo\n and \ndeviceID\n combination, for events that arrive at the \nTempStream\n stream\nfor every 10 minutes and emits third, forth and fifth events when sorted in descending order based on their average temperature.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntimeBatch\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n,\n \ndeviceID\n\n\ngroup\n \nby\n \nroomNo\n,\n \ndeviceID\n\n\norder\n \nby\n \navgTemp\n \ndesc\n\n\nlimit\n \n3\n\n\noffset\n \n2\n\n\ninsert\n \ninto\n \nHighestAvgTempStream\n;\n\n\n\n\n\n\nJoin (Stream)\n\n\nJoins allow you to get a combined result from two streams in real-time based on a specified condition.\n\n\nPurpose\n\nStreams are stateless. Therefore, in order to join two streams, they need to be connected to a window so that there is a pool of events that can be used for joining. Joins also accept conditions to join the appropriate events from each stream.\n\n\nDuring the joining process each incoming event of each stream is matched against all the events in the other\nstream's window based on the given condition, and the output events are generated for all the matching event pairs.\n\n\n\n\nNote\n\n\nJoin can also be performed with \nstored data\n, \naggregation\n or externally \ndefined windows\n.\n\n\n\n\nSyntax\n\n\nThe syntax for a join is as follows:\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\nparameter\n,\n \n...\n \n)\n \n{\nunidirectional\n}\n \n{\nas\n \nreference\n}\n\n         \njoin\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\nparameter\n,\n  \n...\n \n)\n \n{\nunidirectional\n}\n \n{\nas\n \nreference\n}\n\n    \non\n \njoin\n \ncondition\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nHere, the \njoin condition\n allows you to match the attributes from both the streams.\n\n\nUnidirectional join operation\n\n\nBy default, events arriving at either stream can trigger the joining process. However, if you want to control the\njoin execution, you can add the \nunidirectional\n keyword next to a stream in the join definition as depicted in the\nsyntax in order to enable that stream to trigger the join operation. Here, events arriving at other stream only update the\n window of that stream, and this stream does not trigger the join operation.\n\n\n\n\nNote\n\n\nThe \nunidirectional\n keyword cannot be applied to both the input streams because the default behaviour already allows both streams to trigger the join operation.\n\n\n\n\nExample\n\n\nAssuming that the temperature of regulators are updated every minute.\nFollowing is a Siddhi App that controls the temperature regulators if they are not already \non\n for all the rooms with a room temperature greater than 30 degrees.  \n\n\ndefine\n \nstream\n \nTempStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\ndefine\n \nstream\n \nRegulatorStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \nisOn\n \nbool\n);\n\n\n\nfrom\n \nTempStream\n[\ntemp\n \n \n30\n.\n0\n]\n#\nwindow\n.\ntime\n(\n1\n \nmin\n)\n \nas\n \nT\n\n  \njoin\n \nRegulatorStream\n[\nisOn\n \n==\n \nfalse\n]\n#\nwindow\n.\nlength\n(\n1\n)\n \nas\n \nR\n\n  \non\n \nT\n.\nroomNo\n \n==\n \nR\n.\nroomNo\n\n\nselect\n \nT\n.\nroomNo\n,\n \nR\n.\ndeviceID\n,\n \nstart\n \nas\n \naction\n\n\ninsert\n \ninto\n \nRegulatorActionStream\n;\n\n\n\n\n\n\nSupported join types\n\n\nFollowing are the supported operations of a join clause.\n\n\n\n\n\n\nInner join (join)\n\n\nThis is the default behaviour of a join operation. \njoin\n is used as the keyword to join both the streams. The output is generated only if there is a matching event in both the streams.\n\n\n\n\n\n\nLeft outer join\n\n\nThe \nleft outer join\n operation allows you to join two streams to be merged based on a condition. \nleft outer join\n is used as the keyword to join both the streams.\n\n\nHere, it returns all the events of left stream even if there are no matching events in the right stream by\nhaving null values for the attributes of the right stream.\n\n\nExample\n\n\nThe following query generates output events for all events from the \nStockStream\n stream regardless of whether a matching\nsymbol exists in the \nTwitterStream\n stream or not.\n\n\n\nfrom StockStream#window.time(1 min) as S\n  left outer join TwitterStream#window.length(1) as T\n  on S.symbol== T.symbol\nselect S.symbol as symbol, T.tweet, S.price\ninsert into outputStream ;    \n\n\n\n\n\n\nRight outer join\n\n\nThis is similar to a left outer join. \nRight outer join\n is used as the keyword to join both the streams.\nIt returns all the events of the right stream even if there are no matching events in the left stream.\n\n\n\n\n\n\nFull outer join\n\n\nThe full outer join combines the results of left outer join and right outer join. \nfull outer join\n is used as the keyword to join both the streams.\nHere, output event are generated for each incoming event even if there are no matching events in the other stream.\n\n\nExample\n\n\nThe following query generates output events for all the incoming events of each stream regardless of whether there is a\nmatch for the \nsymbol\n attribute in the other stream or not.\n\n\n\nfrom StockStream#window.time(1 min) as S\n  full outer join TwitterStream#window.length(1) as T\n  on S.symbol== T.symbol\nselect S.symbol as symbol, T.tweet, S.price\ninsert into outputStream ;    \n\n\n\n\n\n\nPattern\n\n\nThis is a state machine implementation that allows you to detect patterns in the events that arrive over time. This can correlate events within a single stream or between multiple streams.\n\n\nPurpose\n\n\nPatterns allow you to identify trends in events over a time period.\n\n\nSyntax\n\n\nThe following is the syntax for a pattern query:\n\n\nfrom\n \n(\nevery\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n]\n \n-\n\n    \n(\nevery\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n \n[\nfilter\n \ncondition\n]\n \n-\n\n    \n...\n\n    \n(\nwithin\n \ntime\n \ngap\n)\n?\n     \n\nselect\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\n\n\n\n\nItems\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-\n\n\nThis is used to indicate an event that should be following another event. The subsequent event does not necessarily have to occur immediately after the preceding event. The condition to be met by the preceding event should be added before the sign, and the condition to be met by the subsequent event should be added after the sign.\n\n\n\n\n\n\nevent reference\n\n\nThis allows you to add a reference to the the matching event so that it can be accessed later for further processing.\n\n\n\n\n\n\n(within \ntime gap\n)?\n\n\nThe \nwithin\n clause is optional. It defines the time duration within which all the matching events should occur.\n\n\n\n\n\n\nevery\n\n\nevery\n is an optional keyword. This defines whether the event matching should be triggered for every event arrival in the specified stream with the matching condition. \n When this keyword is not used, the matching is carried out only once.\n\n\n\n\n\n\n\n\nSiddhi also supports pattern matching with counting events and matching events in a logical order such as (\nand\n, \nor\n, and \nnot\n). These are described in detail further below in this guide.\n\n\nExample\n\n\nThis query sends an alert if the temperature of a room increases by 5 degrees within 10 min.\n\n\nfrom\n \nevery\n(\n \ne1\n=\nTempStream\n \n)\n \n-\n \ne2\n=\nTempStream\n[\n \ne1\n.\nroomNo\n \n==\n \nroomNo\n \nand\n \n(\ne1\n.\ntemp\n \n+\n \n5\n)\n \n=\n \ntemp\n \n]\n\n    \nwithin\n \n10\n \nmin\n\n\nselect\n \ne1\n.\nroomNo\n,\n \ne1\n.\ntemp\n \nas\n \ninitialTemp\n,\n \ne2\n.\ntemp\n \nas\n \nfinalTemp\n\n\ninsert\n \ninto\n \nAlertStream\n;\n\n\n\n\n\n\nHere, the matching process begins for each event in the \nTempStream\n stream (because \nevery\n is used with \ne1=TempStream\n),\nand if  another event arrives within 10 minutes with a value for the \ntemp\n attribute that is greater than or equal to \ne1.temp + 5\n\nof the event e1, an output is generated via the \nAlertStream\n.\n\n\nCounting Pattern\n\n\nCounting patterns allow you to match multiple events that may have been received for the same matching condition.\nThe number of events matched per condition can be limited via condition postfixes.\n\n\nSyntax\n\n\nEach matching condition can contain a collection of events with the minimum and maximum number of events to be matched as shown in the syntax below.\n\n\nfrom\n \n(\nevery\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n]\n \n(\nmin\n \ncount\n:\nmax\n \ncount\n)\n?\n \n-\n  \n    \n...\n\n    \n(\nwithin\n \ntime\n \ngap\n)\n?\n     \n\nselect\n \nevent\n \nreference\n([\nevent\n \nindex\n])\n?\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\n\n\n\n\nPostfix\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nn1:n2\n\n\nThis matches \nn1\n to \nn2\n events (including \nn1\n and not more than \nn2\n).\n\n\n1:4\n matches 1 to 4 events.\n\n\n\n\n\n\nn:\n\n\nThis matches \nn\n or more events (including \nn\n).\n\n\n2:\n matches 2 or more events.\n\n\n\n\n\n\n:n\n\n\nThis matches up to \nn\n events (excluding \nn\n).\n\n\n:5\n matches up to 5 events.\n\n\n\n\n\n\nn\n\n\nThis matches exactly \nn\n events.\n\n\n5\n matches exactly 5 events.\n\n\n\n\n\n\n\n\nSpecific occurrences of the event in a collection can be retrieved by using an event index with its reference.\nSquare brackets can be used to indicate the event index where \n1\n can be used as the index of the first event and \nlast\n can be used as the index\n for the \nlast\n available event in the event collection. If you provide an index greater then the last event index,\n the system returns \nnull\n. The following are some valid examples.\n\n\n\n\ne1[3]\n refers to the 3rd event.\n\n\ne1[last]\n refers to the last event.\n\n\ne1[last - 1]\n refers to the event before the last event.\n\n\n\n\nExample\n\n\nThe following Siddhi App calculates the temperature difference between two regulator events.\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\ndefine\n \nstream\n \nRegulatorStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntempSet\n \ndouble\n,\n \nisOn\n \nbool\n);\n\n\n\nfrom\n \nevery\n(\n \ne1\n=\nRegulatorStream\n)\n \n-\n \ne2\n=\nTempStream\n[\ne1\n.\nroomNo\n==\nroomNo\n]\n1\n:\n \n-\n \ne3\n=\nRegulatorStream\n[\ne1\n.\nroomNo\n==\nroomNo\n]\n\n\nselect\n \ne1\n.\nroomNo\n,\n \ne2\n[\n0\n].\ntemp\n \n-\n \ne2\n[\nlast\n].\ntemp\n \nas\n \ntempDiff\n\n\ninsert\n \ninto\n \nTempDiffStream\n;\n\n\n\n\n\n\nLogical Patterns\n\n\nLogical patterns match events that arrive in temporal order and correlate them with logical relationships such as \nand\n,\n\nor\n and \nnot\n.\n\n\nSyntax\n\n\nfrom\n \n(\nevery\n)\n?\n \n(\nnot\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n]\n\n          \n((\nand\n|\nor\n)\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n])\n?\n \n(\nwithin\n \ntime\n \ngap\n)\n?\n \n-\n  \n    \n...\n\n\nselect\n \nevent\n \nreference\n([\nevent\n \nindex\n])\n?\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nKeywords such as \nand\n, \nor\n, or \nnot\n can be used to illustrate the logical relationship.\n\n\n\n\n\n\n\n\nKey Word\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nand\n\n\nThis allows both conditions of \nand\n to be matched by two events in any order.\n\n\n\n\n\n\nor\n\n\nThe state succeeds if either condition of \nor\n is satisfied. Here the event reference of the other condition is \nnull\n.\n\n\n\n\n\n\nnot \ncondition1\n and \ncondition2\n\n\nWhen \nnot\n is included with \nand\n, it identifies the events that match \n arriving before any event that match \n.\n\n\n\n\n\n\nnot \ncondition\n for \ntime period\n\n\nWhen \nnot\n is included with \nfor\n, it allows you to identify a situation where no event that matches \ncondition1\n arrives during the specified \ntime period\n.  e.g.,\nfrom not TemperatureStream[temp \n 60] for 5 sec\n.\n\n\n\n\n\n\n\n\nHere the \nnot\n pattern can be followed by either an \nand\n clause or the effective period of \nnot\n can be concluded after a given \ntime period\n. Further in Siddhi more than two streams cannot be matched with logical conditions using \nand\n, \nor\n, or \nnot\n clauses at this point.\n\n\nDetecting Non-occurring Events\n\n\nSiddhi allows you to detect non-occurring events via multiple combinations of the key words specified above as shown in the table below.\n\n\nIn the patterns listed, P* can be either a regular event pattern, an absent event pattern or a logical pattern.\n\n\n\n\n\n\n\n\nPattern\n\n\nDetected Scenario\n\n\n\n\n\n\n\n\n\n\nnot A for \ntime period\n\n\nThe non-occurrence of event A within \ntime period\n after system start up.\n e.g., Generating an alert if a taxi has not reached its destination within 30 minutes, to indicate that the passenger might be in danger.\n\n\n\n\n\n\nnot A for \ntime period\n and B\n\n\nAfter system start up, event A does not occur within \ntime period\n, but event B occurs at some point in time. \n e.g., Generating an alert if a taxi has not reached its destination within 30 minutes, and the passenger marked that he/she is in danger at some point in time.\n\n\n\n\n\n\nnot A for \ntime period 1\n and not B for \ntime period 2\n\n\nAfter system start up, event A doess not occur within \ntime period 1\n, and event B also does not occur within \ntime period 2\n. \n e.g., Generating an alert if the driver of a taxi has not reached the destination within 30 minutes, and the passenger has not marked himself/herself to be in danger within that same time period.\n\n\n\n\n\n\nnot A for \ntime period\n or B\n\n\nAfter system start up, either event A does not occur within \ntime period\n, or event B occurs at some point in time. \n e.g., Generating an alert if the taxi has not reached its destination within 30 minutes, or if the passenger has marked that he/she is in danger at some point in time.\n\n\n\n\n\n\nnot A for \ntime period 1\n or not B for \ntime period 2\n\n\nAfter system start up, either event A does not occur within \ntime period 1\n, or event B occurs within \ntime period 2\n. \n e.g., Generating an alert to indicate that the driver is not on an expected route if the taxi has not reached destination A within 20 minutes, or reached destination B within 30 minutes.\n\n\n\n\n\n\nA \u2192 not B for \ntime period\n\n\nEvent B does not occur within \ntime period\n after the occurrence of event A. e.g., Generating an alert if the taxi has reached its destination, but this was not followed by a payment record.\n\n\n\n\n\n\nP* \u2192 not A for \ntime period\n and B\n\n\nAfter the occurrence of P*, event A does not occur within \ntime period\n, and event B occurs at some point in time. \n\n\n\n\n\n\nP* \u2192 not A for \ntime period 1\n and not B for \ntime period 2\n\n\nAfter the occurrence of P*, event A does not occur within \ntime period 1\n, and event B does not occur within \ntime period 2\n.\n\n\n\n\n\n\nP* \u2192 not A for \ntime period\n or B\n\n\nAfter the occurrence of P*, either event A does not occur within \ntime period\n, or event B occurs at some point in time.\n\n\n\n\n\n\nP* \u2192 not A for \ntime period 1\n or not B for \ntime period 2\n\n\nAfter the occurrence of P*, either event A does not occur within \ntime period 1\n, or event B does not occur within \ntime period 2\n.\n\n\n\n\n\n\nnot A for \ntime period\n \u2192 B\n\n\nEvent A does occur within \ntime period\n after the system start up, but event B occurs after that \ntime period\n has elapsed.\n\n\n\n\n\n\nnot A for \ntime period\n and B \u2192 P*\n\n\nEvent A does not occur within \ntime period\n, and event B occurs at some point in time. Then P* occurs after the \ntime period\n has elapsed, and after B has occurred.\n\n\n\n\n\n\nnot A for \ntime period 1\n and not B for \ntime period 2\n \u2192 P*\n\n\nAfter system start up, event A does not occur within \ntime period 1\n, and event B does not occur within \ntime period 2\n. However, P* occurs after both A and B.\n\n\n\n\n\n\nnot A for \ntime period\n or B \u2192 P*\n\n\nAfter system start up, event A does not occur within \ntime period\n or event B occurs at some point in time. The P* occurs after \ntime period\n has elapsed, or after B has occurred.\n\n\n\n\n\n\nnot A for \ntime period 1\n or not B for \ntime period 2\n \u2192 P*\n\n\nAfter system start up, either event A does not occur within \ntime period 1\n, or event B does not occur within \ntime period 2\n. Then P*  occurs after both \ntime period 1\n and \ntime period 2\n have elapsed.\n\n\n\n\n\n\nnot A and B\n\n\nEvent A does not occur before event B.\n\n\n\n\n\n\nA and not B\n\n\nEvent B does not occur before event A.\n\n\n\n\n\n\n\n\nExample\n\n\nFollowing Siddhi App, sends the \nstop\n control action to the regulator when the key is removed from the hotel room.\n\n\ndefine\n \nstream\n \nRegulatorStateChangeStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntempSet\n \ndouble\n,\n \naction\n \nstring\n);\n\n\ndefine\n \nstream\n \nRoomKeyStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \naction\n \nstring\n);\n\n\n\n\nfrom\n \nevery\n(\n \ne1\n=\nRegulatorStateChangeStream\n[\n \naction\n \n==\n \non\n \n]\n \n)\n \n-\n\n      \ne2\n=\nRoomKeyStream\n[\n \ne1\n.\nroomNo\n \n==\n \nroomNo\n \nand\n \naction\n \n==\n \nremoved\n \n]\n \nor\n \ne3\n=\nRegulatorStateChangeStream\n[\n \ne1\n.\nroomNo\n \n==\n \nroomNo\n \nand\n \naction\n \n==\n \noff\n]\n\n\nselect\n \ne1\n.\nroomNo\n,\n \nifThenElse\n(\n \ne2\n \nis\n \nnull\n,\n \nnone\n,\n \nstop\n \n)\n \nas\n \naction\n\n\nhaving\n \naction\n \n!=\n \nnone\n\n\ninsert\n \ninto\n \nRegulatorActionStream\n;\n\n\n\n\n\n\nThis Siddhi Application generates an alert if we have switch off the regulator before the temperature reaches 12 degrees.  \n\n\ndefine\n \nstream\n \nRegulatorStateChangeStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntempSet\n \ndouble\n,\n \naction\n \nstring\n);\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \ne1\n=\nRegulatorStateChangeStream\n[\naction\n \n==\n \nstart\n]\n \n-\n \nnot\n \nTempStream\n[\ne1\n.\nroomNo\n \n==\n \nroomNo\n \nand\n \ntemp\n \n \n12\n]\n \nand\n \ne2\n=\nRegulatorStateChangeStream\n[\naction\n \n==\n \noff\n]\n\n\nselect\n \ne1\n.\nroomNo\n \nas\n \nroomNo\n\n\ninsert\n \ninto\n \nAlertStream\n;\n\n\n\n\n\n\nThis Siddhi Application generates an alert if the temperature does not reduce to 12 degrees within 5 minutes of switching on the regulator.  \n\n\ndefine\n \nstream\n \nRegulatorStateChangeStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntempSet\n \ndouble\n,\n \naction\n \nstring\n);\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \ne1\n=\nRegulatorStateChangeStream\n[\naction\n \n==\n \nstart\n]\n \n-\n \nnot\n \nTempStream\n[\ne1\n.\nroomNo\n \n==\n \nroomNo\n \nand\n \ntemp\n \n \n12\n]\n \nfor\n \n5 min\n\n\nselect\n \ne1\n.\nroomNo\n \nas\n \nroomNo\n\n\ninsert\n \ninto\n \nAlertStream\n;\n\n\n\n\n\n\nSequence\n\n\nSequence is a state machine implementation that allows you to detect the sequence of event occurrences over time.\nHere \nall matching events need to arrive consecutively\n to match the sequence condition, and there cannot be any non-matching events arriving within a matching sequence of events.\nThis can correlate events within a single stream or between multiple streams.\n\n\nPurpose\n\n\nThis allows you to detect a specified event sequence over a specified time period.\n\n\nSyntax\n\n\nThe syntax for a sequence query is as follows:\n\n\nfrom\n \n(\nevery\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n],\n\n    \nevent\n \nreference\n=\ninput\n \nstream\n \n[\nfilter\n \ncondition\n],\n\n    \n...\n\n    \n(\nwithin\n \ntime\n \ngap\n)\n?\n     \n\nselect\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\n\n\n\n\nItems\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n,\n\n\nThis represents the immediate next event i.e., when an event that matches the first condition arrives, the event that arrives immediately after it should match the second condition.\n\n\n\n\n\n\nevent reference\n\n\nThis allows you to add a reference to the the matching event so that it can be accessed later for further processing.\n\n\n\n\n\n\n(within \ntime gap\n)?\n\n\nThe \nwithin\n clause is optional. It defines the time duration within which all the matching events should occur.\n\n\n\n\n\n\nevery\n\n\nevery\n is an optional keyword. This defines whether the matching event should be triggered for every event that arrives at the specified stream with the matching condition. \n When this keyword is not used, the matching is carried out only once.\n\n\n\n\n\n\n\n\nExample\n\n\nThis query generates an alert if the increase in the temperature between two consecutive temperature events exceeds one degree.\n\n\nfrom\n \nevery\n \ne1\n=\nTempStream\n,\n \ne2\n=\nTempStream\n[\ne1\n.\ntemp\n \n+\n \n1\n \n \ntemp\n]\n\n\nselect\n \ne1\n.\ntemp\n \nas\n \ninitialTemp\n,\n \ne2\n.\ntemp\n \nas\n \nfinalTemp\n\n\ninsert\n \ninto\n \nAlertStream\n;\n\n\n\n\n\n\nCounting Sequence\n\n\nCounting sequences allow you to match multiple events for the same matching condition.\nThe number of events matched per condition can be limited via condition postfixes such as \nCounting Patterns\n, or by using the\n\n*\n, \n+\n, and \n?\n operators.\n\n\nThe matching events can also be retrieved using event indexes, similar to how it is done in \nCounting Patterns\n.\n\n\nSyntax\n\n\nEach matching condition in a sequence can contain a collection of events as shown below.\n\n\nfrom\n \n(\nevery\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n](\n+|*|?\n)\n?\n,\n\n    \nevent\n \nreference\n=\ninput\n \nstream\n \n[\nfilter\n \ncondition\n](\n+|*|?\n)\n?\n,\n\n    \n...\n\n    \n(\nwithin\n \ntime\n \ngap\n)\n?\n     \n\nselect\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\n\n\n\n\nPostfix symbol\n\n\nRequired/Optional\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n+\n\n\nOptional\n\n\nThis matches \none or more\n events to the given condition.\n\n\n\n\n\n\n*\n\n\nOptional\n\n\nThis matches \nzero or more\n events to the given condition.\n\n\n\n\n\n\n?\n\n\nOptional\n\n\nThis matches \nzero or one\n events to the given condition.\n\n\n\n\n\n\n\n\nExample\n\n\nThis Siddhi application identifies temperature peeks.\n\n\ndefine\n \nstream\n \nTempStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \nevery\n \ne1\n=\nTempStream\n,\n \ne2\n=\nTempStream\n[\ne1\n.\ntemp\n \n=\n \ntemp\n]\n+\n,\n \ne3\n=\nTempStream\n[\ne2\n[\nlast\n].\ntemp\n \n \ntemp\n]\n\n\nselect\n \ne1\n.\ntemp\n \nas\n \ninitialTemp\n,\n \ne2\n[\nlast\n].\ntemp\n \nas\n \npeakTemp\n\n\ninsert\n \ninto\n \nPeekTempStream\n;\n\n\n\n\n\n\nLogical Sequence\n\n\nLogical sequences identify logical relationships using \nand\n, \nor\n and \nnot\n on consecutively arriving events.\n\n\nSyntax\n\nThe syntax for a logical sequence is as follows:\n\n\nfrom\n \n(\nevery\n)\n?\n \n(\nnot\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n]\n\n          \n((\nand\n|\nor\n)\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n])\n?\n \n(\nwithin\n \ntime\n \ngap\n)\n?\n,\n\n    \n...\n\n\nselect\n \nevent\n \nreference\n([\nevent\n \nindex\n])\n?\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nKeywords such as \nand\n, \nor\n, or \nnot\n can be used to illustrate the logical relationship, similar to how it is done in \nLogical Patterns\n.\n\n\nExample\n\n\nThis Siddhi application notifies the state when a regulator event is immediately followed by both temperature and humidity events.\n\n\ndefine\n \nstream\n \nTempStream\n(\ndeviceID\n \nlong\n,\n \ntemp\n \ndouble\n);\n\n\ndefine\n \nstream\n \nHumidStream\n(\ndeviceID\n \nlong\n,\n \nhumid\n \ndouble\n);\n\n\ndefine\n \nstream\n \nRegulatorStream\n(\ndeviceID\n \nlong\n,\n \nisOn\n \nbool\n);\n\n\n\nfrom\n \nevery\n \ne1\n=\nRegulatorStream\n,\n \ne2\n=\nTempStream\n \nand\n \ne3\n=\nHumidStream\n\n\nselect\n \ne2\n.\ntemp\n,\n \ne3\n.\nhumid\n\n\ninsert\n \ninto\n \nStateNotificationStream\n;\n\n\n\n\n\n\nOutput rate limiting\n\n\nOutput rate limiting allows queries to output events periodically based on a specified condition.\n\n\nPurpose\n\n\nThis allows you to limit the output to avoid overloading the subsequent executions, and to remove unnecessary information.\n\n\nSyntax\n\n\nThe syntax of an output rate limiting configuration is as follows:\n\n\nfrom\n \ninput\n \nstream\n \n...\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\noutput\n \nrate\n \nlimiting\n \nconfiguration\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nSiddhi supports three types of output rate limiting configurations as explained in the following table:\n\n\n\n\n\n\n\n\nRate limiting configuration\n\n\nSyntax\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBased on time\n\n\noutput event\n every \ntime interval\n\n\nThis outputs \noutput event\n every \ntime interval\n time interval.\n\n\n\n\n\n\nBased on number of events\n\n\noutput event\n every \nevent interval\n events\n\n\nThis outputs \noutput event\n for every \nevent interval\n number of events.\n\n\n\n\n\n\nSnapshot based output\n\n\nsnapshot every \ntime interval\n\n\nThis outputs all events in the window (or the last event if no window is defined in the query) for every given \ntime interval\n time interval.\n\n\n\n\n\n\n\n\nHere the \noutput event\n specifies the event(s) that should be returned as the output of the query.\nThe possible values are as follows:\n\n \nfirst\n : Only the first event processed by the query during the specified time interval/sliding window is emitted.\n\n \nlast\n : Only the last event processed by the query during the specified time interval/sliding window is emitted.\n* \nall\n : All the events processed by the query during the specified time interval/sliding window are emitted. \nWhen no \noutput event\n is defined, \nall\n is used by default.\n\n\nExamples\n\n\n\n\n\n\nReturning events based on the number of events\n\n\nHere, events are emitted every time the specified number of events arrive. You can also specify whether to emit only the first event/last event, or all the events out of the events that arrived.\n\n\nIn this example, the last temperature per sensor is emitted for every 10 events.\n\n\n\nfrom TempStreamselect\nselect temp, deviceID\ngroup by deviceID\noutput last every 10 events\ninsert into LowRateTempStream;    \n\n\n\n\n\n\nReturning events based on time\n\n\nHere events are emitted for every predefined time interval. You can also specify whether to emit only the first event, last event, or all events out of the events that arrived during the specified time interval.\n\n\nIn this example, emits all temperature events every 10 seconds  \n\n\n\nfrom TempStreamoutput\noutput every 10 sec\ninsert into LowRateTempStream;    \n\n\n\n\n\n\nReturning a periodic snapshot of events\n\n\nThis method works best with windows. When an input stream is connected to a window, snapshot rate limiting emits all the current events that have arrived and do not have corresponding expired events for every predefined time interval.\nIf the input stream is not connected to a window, only the last current event for each predefined time interval is emitted.\n\n\nThis query emits a snapshot of the events in a time window of 5 seconds every 1 second.\n\n\n\nfrom TempStream#window.time(5 sec)\noutput snapshot every 1 sec\ninsert into SnapshotTempStream;    \n\n\n\n\n\n\nPartition\n\n\nPartitions divide streams and queries into isolated groups in  order to process them in parallel and in isolation.\nA partition can contain one or more queries and there can be multiple instances where the same queries and streams are replicated for each partition.\nEach partition is tagged with a partition key. Those partitions only process the events that match the corresponding partition key.\n\n\nPurpose\n\n\nPartitions allow you to process the events groups in isolation so that event processing can be performed using the same set of queries for each group.\n\n\nPartition key generation\n\n\nA partition key can be generated in the following two methods:\n\n\n\n\n\n\nPartition by value\n\n\nThis is created by generating unique values using input stream attributes.\n\n\nSyntax\n\n\n\npartition with ( \nexpression\n of \nstream name\n, \nexpression\n of \nstream name\n, ... )\nbegin\n    \nquery\n\n    \nquery\n\n    ...\nend; \n\n\nExample\n\n\nThis query calculates the maximum temperature recorded within the last 10 events per \ndeviceID\n.\n\n\n\npartition with ( deviceID of TempStream )\nbegin\n    from TempStream#window.length(10)\n    select roomNo, deviceID, max(temp) as maxTemp\n    insert into DeviceTempStream;\nend;\n\n\n\n\n\n\n\nPartition by range\n\n\nThis is created by mapping each partition key to a range condition of the input streams numerical attribute.\n\n\nSyntax\n\n\n\npartition with ( \ncondition\n as \npartition key\n or \ncondition\n as \npartition key\n or ... of \nstream name\n, ... )\nbegin\n    \nquery\n\n    \nquery\n\n    ...\nend;\n\n\n\nExample\n\n\nThis query calculates the average temperature for the last 10 minutes per office area.\n\n\n\npartition with ( roomNo \n= 1030 as 'serverRoom' or\n                 roomNo \n 1030 and roomNo \n= 330 as 'officeRoom' or\n                 roomNo \n 330 as 'lobby' of TempStream)\nbegin\n    from TempStream#window.time(10 min)\n    select roomNo, deviceID, avg(temp) as avgTemp\n    insert into AreaTempStream\nend;\n\n  \n\n\n\n\n\n\nInner Stream\n\n\nQueries inside a partition block can use inner streams to communicate with each other while preserving partition isolation.\nInner streams are denoted by a \"#\" placed before the stream name, and these streams cannot be accessed outside a partition block.\n\n\nPurpose\n\n\nInner streams allow you to connect queries within the partition block so that the output of a query can be used as an input only by another query\nwithin the same partition. Therefore, you do not need to repartition the streams if they are communicating within the partition.\n\n\nExample\n\n\nThis partition calculates the average temperature of every 10 events for each sensor, and sends an output to the \nDeviceTempIncreasingStream\n stream if the consecutive average temperature values increase by more than\n5 degrees.\n\n\n\npartition with ( deviceID of TempStream )\nbegin\n    from TempStream#window.lengthBatch(10)\n    select roomNo, deviceID, avg(temp) as avgTemp\n    insert into #AvgTempStream\n\n    from every (e1=#AvgTempStream),e2=#AvgTempStream[e1.avgTemp + 5 \n<\n avgTemp]\n    select e1.deviceID, e1.avgTemp as initialAvgTemp, e2.avgTemp as finalAvgTemp\n    insert into DeviceTempIncreasingStream\nend;\n\n\n\n\nTable\n\n\nA table is a stored version of an stream or a table of events. Its schema is defined via the \ntable definition\n that is\nsimilar to a stream definition. These events are by default stored \nin-memory\n, but Siddhi also provides store extensions to work with data/events stored in various data stores through the\ntable abstraction.\n\n\nPurpose\n\n\nTables allow Siddhi to work with stored events. By defining a schema for tables Siddhi enables them to be processed by queries using their defined attributes with the streaming data. You can also interactively query the state of the stored events in the table.\n\n\nSyntax\n\n\nThe syntax for a new table definition is as follows:\n\n\ndefine\n \ntable\n \ntable\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n);\n\n\n\n\n\n\nThe following parameters are configured in a table definition:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntable name\n\n\nThe name of the table defined. (\nPascalCase\n is used for table name as a convention.)\n\n\n\n\n\n\nattribute name\n\n\nThe schema of the table is defined by its attributes with uniquely identifiable attribute names (\ncamelCase\n is used for attribute names as a convention.)\n\n\n\n\n\n\nattribute type\n\n\nThe type of each attribute defined in the schema. \n This can be \nSTRING\n, \nINT\n, \nLONG\n, \nDOUBLE\n, \nFLOAT\n, \nBOOL\n or \nOBJECT\n.\n\n\n\n\n\n\n\n\nExample\n\n\nThe following defines a table named \nRoomTypeTable\n with \nroomNo\n and \ntype\n attributes of data types \nint\n and \nstring\n respectively.\n\n\ndefine\n \ntable\n \nRoomTypeTable\n \n(\n \nroomNo\n \nint\n,\n \ntype\n \nstring\n \n);\n\n\n\n\n\n\nPrimary Keys\n\n\nTables can be configured with primary keys to avoid the duplication of data.\n\n\nPrimary keys are configured by including the \n@PrimaryKey( 'key1', 'key2' )\n annotation to the table definition.\nEach event table configuration can have only one \n@PrimaryKey\n annotation.\nThe number of attributes supported differ based on the table implementations. When more than one attribute\n is used for the primary key, the uniqueness of the events stored in the table is determined based on the combination of values for those attributes.\n\n\nExamples\n\n\nThis query creates an event table with the \nsymbol\n attribute as the primary key.\nTherefore each entry in this table must have a unique value for \nsymbol\n attribute.\n\n\n@\nPrimaryKey\n(\nsymbol\n)\n\n\ndefine\n \ntable\n \nStockTable\n \n(\nsymbol\n \nstring\n,\n \nprice\n \nfloat\n,\n \nvolume\n \nlong\n);\n\n\n\n\n\n\nIndexes\n\n\nIndexes allow tables to be searched/modified much faster.\n\n\nIndexes are configured by including the \n@Index( 'key1', 'key2' )\n annotation to the table definition.\n Each event table configuration can have 0-1 \n@Index\n annotations.\n Support for the \n@Index\n annotation and the number of attributes supported differ based on the table implementations.\n When more then one attribute is used for index, each one of them is used to index the table for fast access of the data.\n Indexes can be configured together with primary keys.\n\n\nExamples\n\n\nThis query creates an indexed event table named \nRoomTypeTable\n with the \nroomNo\n attribute as the index key.\n\n\n@\nIndex\n(\nroomNo\n)\n\n\ndefine\n \ntable\n \nRoomTypeTable\n \n(\nroomNo\n \nint\n,\n \ntype\n \nstring\n);\n\n\n\n\n\n\nStore\n\n\nStore is a table that refers to data/events stored in data stores outside of Siddhi such as RDBMS, Cassandra, etc.\nStore is defined via the \n@store\n annotation, and the store schema is defined via a \ntable definition\n associated with it.\n\n\nPurpose\n\n\nStore allows Siddhi to search, retrieve and manipulate data stored in external data stores through Siddhi queries.\n\n\nSyntax\n\n\nThe syntax for a defining store and it's associated table definition is as follows:\n\n\n@\nstore\n(\ntype\n=\nstore_type\n,\n \nstatic\n.\noption\n.\nkey1\n=\nstatic_option_value1\n,\n \nstatic\n.\noption\n.\nkeyN\n=\nstatic_option_valueN\n)\n\n\ndefine\n \ntable\n \nTableName\n \n(\nattribute1\n \nType1\n,\n \nattributeN\n \nTypeN\n);\n\n\n\n\n\n\nExample\n\n\nThe following defines a RDBMS data store pointing to a MySQL database with name \nhotel\n hosted in \nloacalhost:3306\n\nhaving a table \nRoomTypeTable\n with columns \nroomNo\n of \nINTEGER\n and \ntype\n of \nVARCHAR(255)\n mapped to Siddhi data types \nint\n and \nstring\n respectively.\n\n\n@\nStore\n(\ntype\n=\nrdbms\n,\n \njdbc\n.\nurl\n=\njdbc:mysql://localhost:3306/hotel\n,\n \nusername\n=\nsiddhi\n,\n \npassword\n=\n123\n,\n\n       \njdbc\n.\ndriver\n.\nname\n=\ncom.mysql.jdbc.Driver\n)\n\n\ndefine\n \ntable\n \nRoomTypeTable\n \n(\n \nroomNo\n \nint\n,\n \ntype\n \nstring\n \n);\n\n\n\n\n\n\nSupported Store Types\n\n\nThe following is a list of currently supported store types:\n\n\n\n\nRDBMS (MySQL, Oracle, SQL Server, PostgreSQL, DB2, H2)\n\n\nSolr\n\n\nMongoDB\n\n\nHBase\n\n\nRedis\n\n\nCassandra\n\n\n\n\nOperators on Table (and Store)\n\n\nThe following operators can be performed on tables (and stores).\n\n\nInsert\n\n\nThis allows events to be inserted into tables. This is similar to inserting events into streams.\n\n\n\n\nWarning\n\n\nIf the table is defined with primary keys, and if you insert duplicate data, primary key constrain violations can occur.\nIn such cases use the \nupdate or insert into\n operation.\n\n\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \ntable\n\n\n\n\n\n\nSimilar to streams, you need to use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword between \ninsert\n and \ninto\n keywords in order to insert only the specific output event types.\nFor more information, see \noutput event type\n\n\nExample\n\n\nThis query inserts all the events from the \nTempStream\n stream to the \nTempTable\n table.\n\n\nfrom\n \nTempStream\n\n\nselect\n \n*\n\n\ninsert\n \ninto\n \nTempTable\n;\n\n\n\n\n\n\nJoin (Table)\n\n\nThis allows a stream to retrieve information from a table in a streaming manner.\n\n\n\n\nNote\n\n\nJoins can also be performed with \ntwo streams\n, \naggregation\n or against externally \ndefined windows\n.\n\n\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n \njoin\n \ntable\n\n    \non\n \ncondition\n\n\nselect\n \n(\ninput\n \nstream\n|\ntable\n).\nattribute\n \nname\n,\n \n(\ninput\n \nstream\n|\ntable\n).\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\nNote\n\n\nA table can only be joint with a stream. Two tables cannot be joint because there must be at least one active\nentity to trigger the join operation.\n\n\n\n\nExample\n\n\nThis Siddhi App performs a join to retrieve the room type from \nRoomTypeTable\n table based on the room number, so that it can filter the events related to \nserver-room\ns.\n\n\ndefine\n \ntable\n \nRoomTypeTable\n \n(\nroomNo\n \nint\n,\n \ntype\n \nstring\n);\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \nTempStream\n \njoin\n \nRoomTypeTable\n\n    \non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \nTempStream\n.\nroomNo\n\n\nselect\n \ndeviceID\n,\n \nRoomTypeTable\n.\ntype\n \nas\n \nroomType\n,\n \ntype\n,\n \ntemp\n\n    \nhaving\n \nroomType\n \n==\n \nserver-room\n\n\ninsert\n \ninto\n \nServerRoomTempStream\n;\n\n\n\n\n\n\nSupported join types\n\n\nTable join supports following join operations.\n\n\n\n\n\n\nInner join (join)\n\n\nThis is the default behaviour of a join operation. \njoin\n is used as the keyword to join the stream with the table. The output is generated only if there is a matching event in both the stream and the table.\n\n\n\n\n\n\nLeft outer join\n\n\nThe \nleft outer join\n operation allows you to join a stream on left side with a table on the right side based on a condition.\nHere, it returns all the events of left stream even if there are no matching events in the right table by\nhaving null values for the attributes of the right table.\n\n\n\n\n\n\nRight outer join\n\n\nThis is similar to a \nleft outer join\n. \nright outer join\n is used as the keyword to join a stream on right side with a table on the left side based on a condition.\nIt returns all the events of the right stream even if there are no matching events in the left table.\n\n\n\n\n\n\nDelete\n\n\nTo delete selected events that are stored in a table.\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ndelete\n \ntable\n \n(\nfor\n \noutput\n \nevent\n \ntype\n)\n?\n\n    \non\n \ncondition\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected to be deleted.\nWhen specifying the condition, table attributes should be referred to with the table name.\n\n\nTo execute delete for specific output event types, use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword with \nfor\n as shown\nin the syntax. For more information, see \noutput event type\n\n\n\n\nNote\n\n\nTable attributes must be always referred to with the table name as follows:\n\ntable name\n.\nattibute name\n\n\n\n\nExample\n\n\nIn this example, the script deletes a record in the \nRoomTypeTable\n table if it has a value for the \nroomNo\n attribute that matches the value for the \nroomNumber\n attribute of an event in the \nDeleteStream\n stream.\n\n\ndefine\n \ntable\n \nRoomTypeTable\n \n(\nroomNo\n \nint\n,\n \ntype\n \nstring\n);\n\n\n\ndefine\n \nstream\n \nDeleteStream\n \n(\nroomNumber\n \nint\n);\n\n\n\nfrom\n \nDeleteStream\n\n\ndelete\n \nRoomTypeTable\n\n    \non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \nroomNumber\n;\n\n\n\n\n\n\nUpdate\n\n\nThis operator updates selected event attributes stored in a table based on a condition.\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\nupdate\n \ntable\n \n(\nfor\n \noutput\n \nevent\n \ntype\n)\n?\n\n    \nset\n \ntable\n.\nattribute\n \nname\n \n=\n \n(\nattribute\n \nname\n|\nexpression\n)\n?\n,\n \ntable\n.\nattribute\n \nname\n \n=\n \n(\nattribute\n \nname\n|\nexpression\n)\n?\n,\n \n...\n\n    \non\n \ncondition\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected to be updated.\nWhen specifying the \ncondition\n, table attributes must be referred to with the table name.\n\n\nYou can use the \nset\n keyword to update selected attributes from the table. Here, for each assignment, the attribute specified in the left must be the table attribute, and the one specified in the right can be a stream/table attribute a mathematical operation, or other. When the \nset\n clause is not provided, all the attributes in the table are updated.\n\n\nTo execute an update for specific output event types use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword with \nfor\n as shown\nin the syntax. For more information, see \noutput event type\n.\n\n\n\n\nNote\n\n\nTable attributes must be always referred to with the table name as shown below:\n \ntable name\n.\nattibute name\n.\n\n\n\n\nExample\n\n\nThis Siddhi application updates the room occupancy in the \nRoomOccupancyTable\n table for each room number based on new arrivals and exits from the \nUpdateStream\n stream.\n\n\ndefine\n \ntable\n \nRoomOccupancyTable\n \n(\nroomNo\n \nint\n,\n \npeople\n \nint\n);\n\n\ndefine\n \nstream\n \nUpdateStream\n \n(\nroomNumber\n \nint\n,\n \narrival\n \nint\n,\n \nexit\n \nint\n);\n\n\n\nfrom\n \nUpdateStream\n\n\nselect\n \n*\n\n\nupdate\n \nRoomOccupancyTable\n\n    \nset\n \nRoomOccupancyTable\n.\npeople\n \n=\n \nRoomOccupancyTable\n.\npeople\n \n+\n \narrival\n \n-\n \nexit\n\n    \non\n \nRoomOccupancyTable\n.\nroomNo\n \n==\n \nroomNumber\n;\n\n\n\n\n\n\nUpdate or Insert\n\n\nThis allows you update if the event attributes already exist in the table based on a condition, or\nelse insert the entry as a new attribute.\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\nupdate\n \nor\n \ninsert\n \ninto\n \ntable\n \n(\nfor\n \noutput\n \nevent\n \ntype\n)\n?\n\n    \nset\n \ntable\n.\nattribute\n \nname\n \n=\n \nexpression\n,\n \ntable\n.\nattribute\n \nname\n \n=\n \nexpression\n,\n \n...\n\n    \non\n \ncondition\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected for update.\nWhen specifying the \ncondition\n, table attributes should be referred to with the table name.\nIf a record that matches the condition does not already exist in the table, the arriving event is inserted into the table.\n\n\nThe \nset\n clause is only used when an update is performed during the insert/update operation.\nWhen \nset\n clause is used, the attribute to the left is always a table attribute, and the attribute to the right can be a stream/table attribute, mathematical\noperation or other. The attribute to the left (i.e., the attribute in the event table) is updated with the value of the attribute to the right if the given condition is met. When the \nset\n clause is not provided, all the attributes in the table are updated.\n\n\n\n\nNote\n\n\nWhen the attribute to the right is a table attribute, the operations supported differ based on the database type.\n\n\n\n\nTo execute update upon specific output event types use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword with \nfor\n as shown\nin the syntax. To understand more see \noutput event type\n.\n\n\n\n\nNote\n\n\nTable attributes should be always referred to with the table name as \ntable name\n.\nattibute name\n.\n\n\n\n\nExample\n\n\nThe following query update for events in the \nUpdateTable\n event table that have room numbers that match the same in the \nUpdateStream\n stream. When such events are found in the event table, they are updated. When a room number available in the stream is not found in the event table, it is inserted from the stream.\n\n\ndefine\n \ntable\n \nRoomAssigneeTable\n \n(\nroomNo\n \nint\n,\n \ntype\n \nstring\n,\n \nassignee\n \nstring\n);\n\n\ndefine\n \nstream\n \nRoomAssigneeStream\n \n(\nroomNumber\n \nint\n,\n \ntype\n \nstring\n,\n \nassignee\n \nstring\n);\n\n\n\nfrom\n \nRoomAssigneeStream\n\n\nselect\n \nroomNumber\n \nas\n \nroomNo\n,\n \ntype\n,\n \nassignee\n\n\nupdate\n \nor\n \ninsert\n \ninto\n \nRoomAssigneeTable\n\n    \nset\n \nRoomAssigneeTable\n.\nassignee\n \n=\n \nassignee\n\n    \non\n \nRoomAssigneeTable\n.\nroomNo\n \n==\n \nroomNo\n;\n\n\n\n\n\n\nIn\n\n\nThis allows the stream to check whether the expected value exists in the table as a part of a conditional operation.\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n[\ncondition\n \nin\n \ntable\n]\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected to be compared.\nWhen constructing the \ncondition\n, the table attribute must be always referred to with the table name as shown below:\n\ntable\n.\nattibute name\n.\n\n\nExample\n\n\nThis Siddhi application filters only room numbers that are listed in the \nServerRoomTable\n table.\n\n\ndefine\n \ntable\n \nServerRoomTable\n \n(\nroomNo\n \nint\n);\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \nTempStream\n[\nServerRoomTable\n.\nroomNo\n \n==\n \nroomNo\n \nin\n \nServerRoomTable\n]\n\n\ninsert\n \ninto\n \nServerRoomTempStream\n;\n\n\n\n\n\n\nIncremental Aggregation\n\n\nIncremental aggregation allows you to obtain aggregates in an incremental manner for a specified set of time periods.\n\n\nThis not only allows you to calculate aggregations with varied time granularity, but also allows you to access them in an interactive\n manner for reports, dashboards, and for further processing. Its schema is defined via the \naggregation definition\n.\n\n\nIncremental aggregation granularity data holders are automatically purged every 15 minutes. When carrying out data purging, the retention period you have specified for each granularity in the incremental aggregation query is taken into account. The retention period defined for a granularity needs to be greater than or equal to its minimum retention period as specified in the table below. If no valid retention period is defined for a granularity, the default retention period (as specified in the table below) is applied.\n\n\n\n\n\n\n\n\nGranularity\n\n\nDefault retention\n\n\nMinimum retention\n\n\n\n\n\n\n\n\n\n\nsecond\n\n\n120\n seconds\n\n\n120\n seconds\n\n\n\n\n\n\nminute\n\n\n24\n  hours\n\n\n120\n minutes\n\n\n\n\n\n\nhour\n\n\n30\n  days\n\n\n25\n  hours\n\n\n\n\n\n\nday\n\n\n1\n   year\n\n\n32\n  days\n\n\n\n\n\n\nmonth\n\n\nAll\n\n\n13\n  month\n\n\n\n\n\n\nyear\n\n\nAll\n\n\nnone\n\n\n\n\n\n\n\n\nPurpose\n\n\nIncremental aggregation allows you to retrieve the aggregate values for different time durations.\nThat is, it allows you to obtain aggregates such as \nsum\n, \ncount\n, \navg\n, \nmin\n, \nmax\n, \ncount\n and \ndistinctCount\n\nof stream attributes for durations such as \nsec\n, \nmin\n, \nhour\n, etc.\n\n\nThis is of considerable importance in many Analytics scenarios because aggregate values are often needed for several time periods.\nFurthermore, this ensures that the aggregations are not lost due to unexpected system failures because aggregates can be stored in different persistence \nstores\n.\n\n\nSyntax\n\n\n@\nstore\n(\ntype\n=\nstore type\n,\n \n...)\n\n\n@\npurge\n(\nenable\n=\ntrue or false\n,\ninterval\n=\npurging\n \ninterval\n,\n@\nretentionPeriod\n(\ngranularity\n \n=\n \nretention\n \nperiod\n,\n \n...)\n \n)\n\n\ndefine\n \naggregation\n \naggregator\n \nname\n\n\nfrom\n \ninput\n \nstream\n\n\nselect\n \nattribute\n \nname\n,\n \naggregate\n \nfunction\n(\nattribute\n \nname\n)\n \nas\n \nattribute\n \nname\n,\n \n...\n\n    \ngroup\n \nby\n \nattribute\n \nname\n\n    \naggregate\n \nby\n \ntimestamp\n \nattribute\n \nevery\n \ntime\n \nperiods\n \n;\n\n\n\n\n\n\nThe above syntax includes the following:\n\n\n\n\n\n\n\n\nItem\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n@BufferSize\n\n\nDEPRECIATED FROM V4.2.0\n. This identifies the number of expired events to retain in a buffer in order\nto handle out of order event processing. This is an optional\nparameter that is applicable only if aggregation is based on external\ntimestamps (because events aggregated based on event arrival\ntime cannot be out of order). Siddhi determines whether an event is expired or not\nbased on the timestamp of the latest event and the most granular duration for\nwhich aggregation is calculated.\n e.g., If the aggregation is calculated for \nsec\u2026year\n, the most granular duration is seconds. Therefore, if the buffer size is \n3\n and events arrive during 51st, 52nd, 53rd and 54th seconds, all of the older aggregations (i.e., for 51st, 52nd and 53rd seconds) are kept in the buffer because the latest event arrived during the 54th second. \nThe default value is \n0\n.\n\n\n\n\n\n\n@IgnoreEventsOlderThanBuffer\n\n\nDEPRECIATED FROM V4.2.0\n.This annotation specifies whether or not to aggregate events older than the \nbuffer. If this parameter is set to \nfalse\n (which is default), any event \nolder than the buffer is aggregated with the oldest event in buffer. If \nthis parameter is set to \ntrue\n, any event older than the buffer is dropped. This is an optional annotation.\n\n\n\n\n\n\n@store\n\n\nThis annotation is used to refer to the data store where the calculated \naggregate results are stored. This annotation is optional. When \nno annotation is provided, the data is stored in the \nin-memory\n store.\n\n\n\n\n\n\n@purge\n\n\nThis annotation is used to configure purging in aggregation granularities.\n If this annotation is not provided, the default purging mentioned above is applied.\n If you want to disable automatic data purging, you can use this annotation as follows:\n'@purge(enable=false)\n/You should disable data purging if the aggregation query in included in the Siddhi application for read-only purposes.\n\n\n\n\n\n\n@retentionPeriod\n\n\nThis annotation is used to specify the length of time the data needs to be retained when carrying out data purging.\n If this annotation is not provided, the default retention period is applied.\n\n\n\n\n\n\naggregator name\n\n\nThis specifies a unique name for the aggregation so that it can be referred \nwhen accessing aggregate results.\n\n\n\n\n\n\ninput stream\n\n\nThe stream that feeds the aggregation. \nNote! this stream should be \nalready defined.\n\n\n\n\n\n\ngroup by \nattribute name\n\n\nThe \ngroup by\n clause is optional. If it is included in a Siddhi application, aggregate values \n are calculated per each \ngroup by\n attribute. If it is not used, all the\n events are aggregated together.\n\n\n\n\n\n\nby \ntimestamp attribute\n\n\nThis clause is optional. This defines the attribute that should be used as\n the timestamp. If this clause is not used, the event time is used by default.\n The timestamp could be given as either a \nstring\n or a \nlong\n value. If it is a \nlong\n value,\n the unix timestamp in milliseconds is expected (e.g. \n1496289950000\n). If it is \na \nstring\n value, the supported formats are \nyyyy\n-\nMM\n-\ndd\n \nHH\n:\nmm\n:\nss\n \n(if time is in GMT) and  \nyyyy\n-\nMM\n-\ndd\n \nHH\n:\nmm\n:\nss\n \nZ\n (if time is \nnot in GMT), here the ISO 8601 UTC offset must be provided for \nZ\n .\n(e.g., \n+05:30\n, \n-11:00\n).\n\n\n\n\n\n\ntime periods\n\n\nTime periods can be specified as a range where the minimum and the maximum value are separated by three dots, or as comma-separated values. \n e.g., A range can be specified as sec...year where aggregation is done per second, minute, hour, day, month and year. Comma-separated values can be specified as min, hour. \n Skipping time durations (e.g., min, day where the hour duration is skipped) when specifying comma-separated values is supported only from v4.1.1 onwards\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nFrom V4.2.0 onwards, aggregation is carried out at calendar start times for each granularity with the GMT timezone\n\n\n\n\n\n\nNote\n\n\nFrom V4.2.6 onwards, the same aggregation can be defined in multiple Siddhi apps for joining, however, \nonly one siddhi app should carry out the processing\n (i.e. the aggregation input stream should only feed events to one aggregation definition).\n\n\n\n\nExample\n\n\nThis Siddhi Application defines an aggregation named \nTradeAggregation\n to calculate the average and sum for the \nprice\n attribute of events arriving at the \nTradeStream\n stream. These aggregates are calculated per every time granularity in the second-year range.\n\n\ndefine\n \nstream\n \nTradeStream\n \n(\nsymbol\n \nstring\n,\n \nprice\n \ndouble\n,\n \nvolume\n \nlong\n,\n \ntimestamp\n \nlong\n);\n\n\n\n@\npurge\n(\nenable\n=\ntrue\n,\n \ninterval\n=\n10 sec\n,\n@\nretentionPeriod\n(\nsec\n=\n120 sec\n,\nmin\n=\n24 hours\n,\nhours\n=\n30 days\n,\ndays\n=\n1 year\n,\nmonths\n=\nall\n,\nyears\n=\nall\n))\n\n\ndefine\n \naggregation\n \nTradeAggregation\n\n  \nfrom\n \nTradeStream\n\n  \nselect\n \nsymbol\n,\n \navg\n(\nprice\n)\n \nas\n \navgPrice\n,\n \nsum\n(\nprice\n)\n \nas\n \ntotal\n\n    \ngroup\n \nby\n \nsymbol\n\n    \naggregate\n \nby\n \ntimestamp\n \nevery\n \nsec\n \n...\n \nyear\n;\n\n\n\n\n\n\nDistributed Aggregation\n\n\n\n\nNote\n\n\nDistributed Aggregation is only supported after v4.3.0\n\n\n\n\nDistributed Aggregation allows you to partially process aggregations in different shards. This allows Siddhi\napp in one shard to be responsible only for processing a part of the aggregation.\nHowever for this, all aggregations must be based on a common physical database(@store).\n\n\nSyntax\n\n\n@\nstore\n(\ntype\n=\nstore type\n,\n \n...)\n\n\n@\nPartitionById\n\n\ndefine\n \naggregation\n \naggregator\n \nname\n\n\nfrom\n \ninput\n \nstream\n\n\nselect\n \nattribute\n \nname\n,\n \naggregate\n \nfunction\n(\nattribute\n \nname\n)\n \nas\n \nattribute\n \nname\n,\n \n...\n\n    \ngroup\n \nby\n \nattribute\n \nname\n\n    \naggregate\n \nby\n \ntimestamp\n \nattribute\n \nevery\n \ntime\n \nperiods\n \n;\n\n\n\n\n\n\nFollowing table includes the \nannotation\n to be used to enable distributed aggregation,\n\n\n\n\n\n\n\n\nItem\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n@PartitionById\n\n\nIf the annotation is given, then the distributed aggregation is enabled. Further this can be disabled by using \nenable\n element, \n@PartitionById(enable='false')\n.\n\n\n\n\n\n\n\n\nFurther, following system properties are also available,\n\n\n\n\n\n\n\n\nSystem Property\n\n\nDescription\n\n\nPossible Values\n\n\nOptional\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nshardId\n\n\nThe id of the shard one of the distributed aggregation is running in. This should be unique to a single shard\n\n\nAny string\n\n\nNo\n\n\n\n\n\n\n\n\npartitionById\n\n\nThis allows user to enable/disable distributed aggregation for all aggregations running in one siddhi manager .(Available from v4.3.3)\n\n\ntrue/false\n\n\nYesio\n\n\nfalse\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nShardIds should not be changed after the first configuration in order to keep data consistency.\n\n\n\n\nJoin (Aggregation)\n\n\nThis allows a stream to retrieve calculated aggregate values from the aggregation.\n\n\n\n\nNote\n\n\nA join can also be performed with \ntwo streams\n, with a \ntable\n and a stream, or with a stream against externally \ndefined windows\n.\n\n\n\n\nSyntax\n\n\nA join with aggregation is similer to the join with \ntable\n, but with additional \nwithin\n and \nper\n clauses.\n\n\nfrom\n \ninput\n \nstream\n \njoin\n \naggrigation\n\n  \non\n \njoin\n \ncondition\n\n  \nwithin\n \ntime\n \nrange\n\n  \nper\n \ntime\n \ngranularity\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nApart from constructs of \ntable join\n this includes the following. Please note that the 'on' condition is optional :\n\n\n\n\n\n\n\n\nItem\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwithin  \ntime range\n\n\nThis allows you to specify the time interval for which the aggregate values need to be retrieved. This can be specified by providing the start and end time separated by a comma as \nstring\n or \nlong\n values, or by using the wildcard \nstring\n specifying the data range. For details refer examples.\n\n\n\n\n\n\nper \ntime granularity\n\n\nThis specifies the time granularity by which the aggregate values must be grouped and returned. e.g., If you specify \ndays\n, the retrieved aggregate values are grouped for each day within the selected time interval.\n\n\n\n\n\n\nAGG_TIMESTAMP\n\n\nThis specifies the start time of the aggregations and can be used in the select clause.\n\n\n\n\n\n\n\n\nwithin\n and \nper\n clauses also accept attribute values from the stream.\n\n\n\n\nNote\n\n\nThe timestamp of the aggregations can be accessed through the \nAGG_TIMESTAMP\n attribute.\n\n\n\n\nExample\n\n\nFollowing aggregation definition will be used for the examples.\n\n\ndefine\n \nstream\n \nTradeStream\n \n(\nsymbol\n \nstring\n,\n \nprice\n \ndouble\n,\n \nvolume\n \nlong\n,\n \ntimestamp\n \nlong\n);\n\n\n\ndefine\n \naggregation\n \nTradeAggregation\n\n  \nfrom\n \nTradeStream\n\n  \nselect\n \nAGG_TIMESTAMP\n,\n \nsymbol\n,\n \navg\n(\nprice\n)\n \nas\n \navgPrice\n,\n \nsum\n(\nprice\n)\n \nas\n \ntotal\n\n    \ngroup\n \nby\n \nsymbol\n\n    \naggregate\n \nby\n \ntimestamp\n \nevery\n \nsec\n \n...\n \nyear\n;\n\n\n\n\n\n\nThis query retrieves daily aggregations within the time range \n\"2014-02-15 00:00:00 +05:30\", \"2014-03-16 00:00:00 +05:30\"\n (Please note that +05:30 can be omitted if timezone is GMT)\n\n\ndefine\n \nstream\n \nStockStream\n \n(\nsymbol\n \nstring\n,\n \nvalue\n \nint\n);\n\n\n\nfrom\n \nStockStream\n \nas\n \nS\n \njoin\n \nTradeAggregation\n \nas\n \nT\n\n  \non\n \nS\n.\nsymbol\n \n==\n \nT\n.\nsymbol\n\n  \nwithin\n \n2014-02-15 00:00:00 +05:30\n,\n \n2014-03-16 00:00:00 +05:30\n\n  \nper\n \ndays\n\n\nselect\n \nS\n.\nsymbol\n,\n \nT\n.\ntotal\n,\n \nT\n.\navgPrice\n\n\ninsert\n \ninto\n \nAggregateStockStream\n;\n\n\n\n\n\n\nThis query retrieves hourly aggregations within the day \n2014-02-15\n.\n\n\ndefine\n \nstream\n \nStockStream\n \n(\nsymbol\n \nstring\n,\n \nvalue\n \nint\n);\n\n\n\nfrom\n \nStockStream\n \nas\n \nS\n \njoin\n \nTradeAggregation\n \nas\n \nT\n\n  \non\n \nS\n.\nsymbol\n \n==\n \nT\n.\nsymbol\n\n  \nwithin\n \n2014-02-15 **:**:** +05:30\n\n  \nper\n \nhours\n\n\nselect\n \nS\n.\nsymbol\n,\n \nT\n.\ntotal\n,\n \nT\n.\navgPrice\n\n\ninsert\n \ninto\n \nAggregateStockStream\n;\n\n\n\n\n\n\nThis query retrieves all aggregations per \nperValue\n stream attribute within the time period\nbetween timestamps \n1496200000000\n and \n1596434876000\n.\n\n\ndefine\n \nstream\n \nStockStream\n \n(\nsymbol\n \nstring\n,\n \nvalue\n \nint\n,\n \nperValue\n \nstring\n);\n\n\n\nfrom\n \nStockStream\n \nas\n \nS\n \njoin\n \nTradeAggregation\n \nas\n \nT\n\n  \non\n \nS\n.\nsymbol\n \n==\n \nT\n.\nsymbol\n\n  \nwithin\n \n1496200000000\nL\n,\n \n1596434876000\nL\n\n  \nper\n \nS\n.\nperValue\n\n\nselect\n \nS\n.\nsymbol\n,\n \nT\n.\ntotal\n,\n \nT\n.\navgPrice\n\n\ninsert\n \ninto\n \nAggregateStockStream\n;\n\n\n\n\n\n\nSupported join types\n\n\nAggregation join supports following join operations.\n\n\n\n\n\n\nInner join (join)\n\n\nThis is the default behaviour of a join operation. \njoin\n is used as the keyword to join the stream with the aggregation. The output is generated only if there is a matching event in the stream and the aggregation.\n\n\n\n\n\n\nLeft outer join\n\n\nThe \nleft outer join\n operation allows you to join a stream on left side with a aggregation on the right side based on a condition.\nHere, it returns all the events of left stream even if there are no matching events in the right aggregation by\nhaving null values for the attributes of the right aggregation.\n\n\n\n\n\n\nRight outer join\n\n\nThis is similar to a \nleft outer join\n. \nright outer join\n is used as the keyword to join a stream on right side with a aggregation on the left side based on a condition.\nIt returns all the events of the right stream even if there are no matching events in the left aggregation.\n\n\n\n\n\n\n(Defined)\n Window\n\n\nA defined window is a window that can be shared across multiple queries.\nEvents can be inserted to a defined window from one or more queries and it can produce output events based on the defined window type.\n\n\nSyntax\n\n\nThe syntax for a defined window is as follows:\n\n\ndefine\n \nwindow\n \nwindow\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n)\n \nwindow\n \ntype\n(\nparameter\n,\n \nparameter\n,\n \n\u2026\n)\n \noutput\n \nevent\n \ntype\n;\n\n\n\n\n\n\nThe following parameters are configured in a table definition:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwindow name\n\n\nThe name of the window defined. (\nPascalCase\n is used for window names as a convention.)\n\n\n\n\n\n\nattribute name\n\n\nThe schema of the window is defined by its attributes with uniquely identifiable attribute names (\ncamelCase\n is used for attribute names as a convention.)\n\n\n\n\n\n\nattribute type\n\n\nThe type of each attribute defined in the schema. \n This can be \nSTRING\n, \nINT\n, \nLONG\n, \nDOUBLE\n, \nFLOAT\n, \nBOOL\n or \nOBJECT\n.\n\n\n\n\n\n\nwindow type\n(\nparameter\n, ...)\n\n\nThe window type associated with the window and its parameters.\n\n\n\n\n\n\noutput \noutput event type\n\n\nThis is optional. Keywords such as \ncurrent events\n, \nexpired events\n and \nall events\n (the default) can be used to specify when the window output should be exposed. For more information, see \noutput event type\n.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\nReturning all output when events arrive and when events expire from the window.\n\n\nIn this query, the output event type is not specified. Therefore, it returns both current and expired events as the output.\n\n\n\n\n\n\n  \ndefine\n \nwindow\n \nSensorWindow\n \n(\nname\n \nstring\n,\n \nvalue\n \nfloat\n,\n \nroomNo\n \nint\n,\n \ndeviceID\n \nstring\n)\n \ntimeBatch\n(\n1\n \nsecond\n);\n\n\n\n\n\n\n\n\n\n\nReturning an output only when events expire from the window.\n\n\nIn this query, the output event type of the window is \nexpired events\n. Therefore, it only returns the events that have expired from the window as the output.\n\n\n\n\n\n\n  \ndefine\n \nwindow\n \nSensorWindow\n \n(\nname\n \nstring\n,\n \nvalue\n \nfloat\n,\n \nroomNo\n \nint\n,\n \ndeviceID\n \nstring\n)\n \ntimeBatch\n(\n1\n \nsecond\n)\n \noutput\n \nexpired\n \nevents\n;\n\n\n\n\n\n\nOperators on Defined Windows\n\n\nThe following operators can be performed on defined windows.\n\n\nInsert\n\n\nThis allows events to be inserted into windows. This is similar to inserting events into streams.\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \nwindow\n\n\n\n\n\n\nTo insert only events of a specific output event type, add the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword between \ninsert\n and \ninto\n keywords (similar to how it is done for streams).\n\n\nFor more information, see \noutput event type\n.\n\n\nExample\n\n\nThis query inserts all events from the \nTempStream\n stream to the \nOneMinTempWindow\n window.\n\n\ndefine\n \nstream\n \nTempStream\n(\ntempId\n \nstring\n,\n \ntemp\n \ndouble\n);\n\n\ndefine\n \nwindow\n \nOneMinTempWindow\n(\ntempId\n \nstring\n,\n \ntemp\n \ndouble\n)\n \ntime\n(\n1\n \nmin\n);\n\n\n\nfrom\n \nTempStream\n\n\nselect\n \n*\n\n\ninsert\n \ninto\n \nOneMinTempWindow\n;\n\n\n\n\n\n\nJoin (Window)\n\n\nTo allow a stream to retrieve information from a window based on a condition.\n\n\n\n\nNote\n\n\nA join can also be performed with \ntwo streams\n, \naggregation\n or with tables \ntables\n.\n\n\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n \njoin\n \nwindow\n\n    \non\n \ncondition\n\n\nselect\n \n(\ninput\n \nstream\n|\nwindow\n).\nattribute\n \nname\n,\n \n(\ninput\n \nstream\n|\nwindow\n).\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nExample\n\n\nThis Siddhi Application performs a join count the number of temperature events having more then 40 degrees\n within the last 2 minutes.\n\n\ndefine\n \nwindow\n \nTwoMinTempWindow\n \n(\nroomNo\n \nint\n,\n \ntemp\n \ndouble\n)\n \ntime\n(\n2\n \nmin\n);\n\n\ndefine\n \nstream\n \nCheckStream\n \n(\nrequestId\n \nstring\n);\n\n\n\nfrom\n \nCheckStream\n \nas\n \nC\n \njoin\n \nTwoMinTempWindow\n \nas\n \nT\n\n    \non\n \nT\n.\ntemp\n \n \n40\n\n\nselect\n \nrequestId\n,\n \ncount\n(\nT\n.\ntemp\n)\n \nas\n \ncount\n\n\ninsert\n \ninto\n \nHighTempCountStream\n;\n\n\n\n\n\n\nSupported join types\n\n\nWindow join supports following operations of a join clause.\n\n\n\n\n\n\nInner join (join)\n\n\nThis is the default behaviour of a join operation. \njoin\n is used as the keyword to join two windows or a stream with a window. The output is generated only if there is a matching event in both stream/window.\n\n\n\n\n\n\nLeft outer join\n\n\nThe \nleft outer join\n operation allows you to join two windows or a stream with a window to be merged based on a condition.\nHere, it returns all the events of left stream/window even if there are no matching events in the right stream/window by\nhaving null values for the attributes of the right stream/window.\n\n\n\n\n\n\nRight outer join\n\n\nThis is similar to a left outer join. \nRight outer join\n is used as the keyword to join two windows or a stream with a window.\nIt returns all the events of the right stream/window even if there are no matching events in the left stream/window.\n\n\n\n\n\n\nFull outer join\n\n\nThe full outer join combines the results of \nleft outer join\n and \nright outer join\n. \nfull outer join\n is used as the keyword to join two windows or a stream with a window.\nHere, output event are generated for each incoming event even if there are no matching events in the other stream/window.\n\n\n\n\n\n\nFrom\n\n\nA window can be an input to a query, similar to streams.\n\n\nNote !!!\n     When window is used as an input to a query, another window cannot be applied on top of this.\n\n\nSyntax\n\n\nfrom\n \nwindow\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nExample\n\nThis Siddhi Application calculates the maximum temperature within the last 5 minutes.\n\n\ndefine\n \nwindow\n \nFiveMinTempWindow\n \n(\nroomNo\n \nint\n,\n \ntemp\n \ndouble\n)\n \ntime\n(\n5\n \nmin\n);\n\n\n\n\nfrom\n \nFiveMinTempWindow\n\n\nselect\n \nmax\n(\ntemp\n)\n \nas\n \nmaxValue\n,\n \nroomNo\n\n\ninsert\n \ninto\n \nMaxSensorReadingStream\n;\n\n\n\n\n\n\nTrigger\n\n\nTriggers allow events to be periodically generated. \nTrigger definition\n can be used to define a trigger.\nA trigger also works like a stream with a predefined schema.\n\n\nPurpose\n\n\nFor some use cases the system should be able to periodically generate events based on a specified time interval to perform\nsome periodic executions.\n\n\nA trigger can be performed for a \n'start'\n operation, for a given \ntime interval\n, or for a given \n'\ncron expression\n'\n.\n\n\nSyntax\n\n\nThe syntax for a trigger definition is as follows.\n\n\ndefine\n \ntrigger\n \ntrigger\n \nname\n \nat\n \n(\nstart\n|\n \nevery\n \ntime\n \ninterval\n|\n \ncron expression\n);\n\n\n\n\n\n\nSimilar to streams, triggers can be used as inputs. They adhere to the following stream definition and produce the \ntriggered_time\n attribute of the \nlong\n type.\n\n\ndefine\n \nstream\n \ntrigger\n \nname\n \n(\ntriggered_time\n \nlong\n);\n\n\n\n\n\n\nThe following types of triggeres are currently supported:\n\n\n\n\n\n\n\n\nTrigger type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n'start'\n\n\nAn event is triggered when Siddhi is started.\n\n\n\n\n\n\nevery \ntime interval\n\n\nAn event is triggered periodically at the given time interval.\n\n\n\n\n\n\n'\ncron expression\n'\n\n\nAn event is triggered periodically based on the given cron expression. For configuration details, see \nquartz-scheduler\n.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\nTriggering events regularly at specific time intervals\n\n\nThe following query triggers events every 5 minutes.\n\n\n\n\n\n\n     \ndefine\n \ntrigger\n \nFiveMinTriggerStream\n \nat\n \nevery\n \n5\n \nmin\n;\n\n\n\n\n\n\n\n\n\n\nTriggering events at a specific time on specified days\n\n\nThe following query triggers an event at 10.15 AM on every weekdays.\n\n\n\n\n\n\n     \ndefine\n \ntrigger\n \nFiveMinTriggerStream\n \nat\n \n0 15 10 ? * MON-FRI\n;\n\n\n\n\n\n\nScript\n\n\nScripts allow you to write functions in other programming languages and execute them within Siddhi queries.\nFunctions defined via scripts can be accessed in queries similar to any other inbuilt function.\n\nFunction definitions\n can be used to define these scripts.\n\n\nFunction parameters are passed into the function logic as \nObject[]\n and with the name \ndata\n .\n\n\nPurpose\n\n\nScripts allow you to define a function operation that is not provided in Siddhi core or its extension. It is not required to write an extension to define the function logic.\n\n\nSyntax\n\n\nThe syntax for a Script definition is as follows.\n\n\ndefine\n \nfunction\n \nfunction\n \nname\n[\nlanguage\n \nname\n]\n \nreturn\n \nreturn\n \ntype\n \n{\n\n    \noperation\n \nof\n \nthe\n \nfunction\n\n\n}\n;\n\n\n\n\n\n\nThe following parameters are configured when defining a script.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunction name\n\n\nThe name of the function (\ncamelCase\n is used for the function name) as a convention.\n\n\n\n\n\n\nlanguage name\n\n\nThe name of the programming language used to define the script, such as \njavascript\n, \nr\n and \nscala\n.\n\n\n\n\n\n\nreturn type\n\n\nThe attribute type of the function\u2019s return. This can be \nint\n, \nlong\n, \nfloat\n, \ndouble\n, \nstring\n, \nbool\n or \nobject\n. Here the function implementer should be responsible for returning the output attribute on the defined return type for proper functionality.\n\n\n\n\n\n\noperation of the function\n\n\nHere, the execution logic of the function is added. This logic should be written in the language specified under the \nlanguage name\n, and it should return the output in the data type specified via the \nreturn type\n parameter.\n\n\n\n\n\n\n\n\nExamples\n\n\nThis query performs concatenation using JavaScript, and returns the output as a string.\n\n\ndefine\n \nfunction\n \nconcatFn\n[\njavascript\n]\n \nreturn\n \nstring\n \n{\n\n    \nvar\n \nstr1\n \n=\n \ndata\n[\n0\n];\n\n    \nvar\n \nstr2\n \n=\n \ndata\n[\n1\n];\n\n    \nvar\n \nstr3\n \n=\n \ndata\n[\n2\n];\n\n    \nvar\n \nresponce\n \n=\n \nstr1\n \n+\n \nstr2\n \n+\n \nstr3\n;\n\n    \nreturn\n \nresponce\n;\n\n\n}\n;\n\n\n\ndefine\n \nstream\n \nTempStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \nTempStream\n\n\nselect\n \nconcatFn\n(\nroomNo\n,\n-\n,\ndeviceID\n)\n \nas\n \nid\n,\n \ntemp\n\n\ninsert\n \ninto\n \nDeviceTempStream\n;\n\n\n\n\n\n\nStore Query\n\n\nSiddhi store queries are a set of on-demand queries that can be used to perform operations on Siddhi tables, windows, and aggregators.\n\n\nPurpose\n\n\nStore queries allow you to execute the following operations on Siddhi tables, windows, and aggregators without the intervention of streams.\n\n\nQueries supported for tables:\n\n\n\n\nSELECT\n\n\nINSERT\n\n\nDELETE\n\n\nUPDATE\n\n\nUPDATE OR INSERT\n\n\n\n\nQueries supported for windows and aggregators:\n\n\n\n\nSELECT\n\n\n\n\nThis is be done by submitting the store query to the Siddhi application runtime using its \nquery()\n method.\n\n\nIn order to execute store queries, the Siddhi application of the Siddhi application runtime you are using, should have\n a store defined, which contains the table that needs to be queried.\n\n\nExample\n\n\nIf you need to query the table named \nRoomTypeTable\n the it should have been defined in the Siddhi application.\n\n\nIn order to execute a store query on \nRoomTypeTable\n, you need to submit the store query using \nquery()\n\nmethod of \nSiddhiAppRuntime\n instance as below.\n\n\nsiddhiAppRuntime\n.\nquery\n(\nstore\n \nquery\n);\n\n\n\n\n\n\n(Table/Window)\n Select\n\n\nThe \nSELECT\n store query retrieves records from the specified table or window, based on the given condition.\n\n\nSyntax\n\n\nfrom\n \ntable\n/\nwindow\n\n\non\n \ncondition\n?\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ngroup\n \nby\n?\n\n\nhaving\n?\n\n\norder\n \nby\n?\n\n\nlimit\n?\n\n\n\n\n\n\nExample\n\n\nThis query retrieves room numbers and types of the rooms starting from room no 10.\n\n\nfrom\n \nroomTypeTable\n\n\non\n \nroomNo\n \n=\n \n10\n;\n\n\nselect\n \nroomNo\n,\n \ntype\n\n\n\n\n\n\n(Aggregation)\n Select\n\n\nThe \nSELECT\n store query retrieves records from the specified aggregation, based on the given condition, time range,\nand granularity.\n\n\nSyntax\n\n\nfrom\n \naggregation\n\n\non\n \ncondition\n?\n\n\nwithin\n \ntime\n \nrange\n\n\nper\n \ntime\n \ngranularity\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ngroup\n \nby\n?\n\n\nhaving\n?\n\n\norder\n \nby\n?\n\n\nlimit\n?\n\n\n\n\n\n\nExample\n\n\nFollowing aggregation definition will be used for the examples.\n\n\ndefine\n \nstream\n \nTradeStream\n \n(\nsymbol\n \nstring\n,\n \nprice\n \ndouble\n,\n \nvolume\n \nlong\n,\n \ntimestamp\n \nlong\n);\n\n\n\ndefine\n \naggregation\n \nTradeAggregation\n\n  \nfrom\n \nTradeStream\n\n  \nselect\n \nsymbol\n,\n \navg\n(\nprice\n)\n \nas\n \navgPrice\n,\n \nsum\n(\nprice\n)\n \nas\n \ntotal\n\n    \ngroup\n \nby\n \nsymbol\n\n    \naggregate\n \nby\n \ntimestamp\n \nevery\n \nsec\n \n...\n \nyear\n;\n\n\n\n\n\n\nThis query retrieves daily aggregations within the time range \n\"2014-02-15 00:00:00 +05:30\", \"2014-03-16 00:00:00 +05:30\"\n (Please note that +05:30 can be omitted if timezone is GMT)\n\n\nfrom\n \nTradeAggregation\n\n  \nwithin\n \n2014-02-15 00:00:00 +05:30\n,\n \n2014-03-16 00:00:00 +05:30\n\n  \nper\n \ndays\n\n\nselect\n \nsymbol\n,\n \ntotal\n,\n \navgPrice\n \n;\n\n\n\n\n\n\nThis query retrieves hourly aggregations of \"FB\" symbol within the day \n2014-02-15\n.\n\n\nfrom\n \nTradeAggregation\n\n  \non\n \nsymbol\n \n==\n \nFB\n\n  \nwithin\n \n2014-02-15 **:**:** +05:30\n\n  \nper\n \nhours\n\n\nselect\n \nsymbol\n,\n \ntotal\n,\n \navgPrice\n;\n\n\n\n\n\n\nInsert\n\n\nThis allows you to insert a new record to the table with the attribute values you define in the \nselect\n section.\n\n\nSyntax\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \ntable\n;\n\n\n\n\n\n\nExample\n\n\nThis store query inserts a new record to the table \nRoomOccupancyTable\n, with the specified attribute values.\n\n\nselect\n \n10\n \nas\n \nroomNo\n,\n \n2\n \nas\n \npeople\n\n\ninsert\n \ninto\n \nRoomOccupancyTable\n\n\n\n\n\n\nDelete\n\n\nThe \nDELETE\n store query deletes selected records from a specified table.\n\n\nSyntax\n\n\nselect\n?\n  \n\ndelete\n \ntable\n  \n\non\n \nconditional\n \nexpresssion\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which records are selected to be deleted.\n\n\n\n\nNote\n\n\nTable attributes must always be referred to with the table name as shown below: \n\n \ntable name\n.\nattibute name\n.\n\n\n\n\nExample\n\n\nIn this example, query deletes a record in the table named \nRoomTypeTable\n if it has value for the \nroomNo\n\nattribute that matches the value for the \nroomNumber\n attribute of the selection which has 10 as the actual value.\n\n\nselect\n \n10\n \nas\n \nroomNumber\n\n\ndelete\n \nRoomTypeTable\n\n\non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \nroomNumber\n;\n\n\n\n\n\n\ndelete\n \nRoomTypeTable\n\n\non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \n10\n;\n\n\n\n\n\n\nUpdate\n\n\nThe \nUPDATE\n store query updates selected attributes stored in a specific table, based on a given condition.\n\n\nSyntax\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n?\n\n\nupdate\n \ntable\n\n    \nset\n \ntable\n.\nattribute\n \nname\n \n=\n \n(\nattribute\n \nname\n|\nexpression\n)\n?\n,\n \ntable\n.\nattribute\n \nname\n \n=\n \n(\nattribute\n \nname\n|\nexpression\n)\n?\n,\n \n...\n\n    \non\n \ncondition\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which records are selected to be updated.\nWhen specifying the \ncondition\n, table attributes must be referred to with the table name.\n\n\nYou can use the \nset\n keyword to update selected attributes from the table. Here, for each assignment, the attribute specified in the left must be the table attribute, and the one specified in the right can be a stream/table attribute a mathematical operation, or other. When the \nset\n clause is not provided, all the attributes in the table are updated.\n\n\n\n\nNote\n\n\nTable attributes must always be referred to with the table name as shown below: \n\n \ntable name\n.\nattibute name\n.\n\n\n\n\nExample\n\n\nThe following query updates the room occupancy by increasing the value of \npeople\n by 1, in the \nRoomOccupancyTable\n\ntable for each room number greater than 10.\n\n\nselect\n \n10\n \nas\n \nroomNumber\n,\n \n1\n \nas\n \narrival\n\n\nupdate\n \nRoomTypeTable\n\n    \nset\n \nRoomTypeTable\n.\npeople\n \n=\n \nRoomTypeTable\n.\npeople\n \n+\n \narrival\n\n    \non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \nroomNumber\n;\n\n\n\n\n\n\nupdate\n \nRoomTypeTable\n\n    \nset\n \nRoomTypeTable\n.\npeople\n \n=\n \nRoomTypeTable\n.\npeople\n \n+\n \n1\n\n    \non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \n10\n;\n\n\n\n\n\n\nUpdate or Insert\n\n\nThis allows you to update selected attributes if a record that meets the given conditions already exists in the specified  table.\nIf a matching record does not exist, the entry is inserted as a new record.\n\n\nSyntax\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\nupdate\n \nor\n \ninsert\n \ninto\n \ntable\n\n    \nset\n \ntable\n.\nattribute\n \nname\n \n=\n \nexpression\n,\n \ntable\n.\nattribute\n \nname\n \n=\n \nexpression\n,\n \n...\n\n    \non\n \ncondition\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which records are selected for update.\nWhen specifying the \ncondition\n, table attributes should be referred to with the table name.\nIf a record that matches the condition does not already exist in the table, the arriving event is inserted into the table.\n\n\nThe \nset\n clause is only used when an update is performed during the insert/update operation.\nWhen \nset\n clause is used, the attribute to the left is always a table attribute, and the attribute to the right can be a stream/table attribute, mathematical\noperation or other. The attribute to the left (i.e., the attribute in the event table) is updated with the value of the attribute to the right if the given condition is met. When the \nset\n clause is not provided, all the attributes in the table are updated.\n\n\n\n\nNote\n\n\nTable attributes must always be referred to with the table name as shown below: \n\n \ntable name\n.\nattibute name\n.\n\n\n\n\nExample\n\n\nThe following query tries to update the records in the \nRoomAssigneeTable\n table that have room numbers that match the\n same in the selection. If such records are not found, it inserts a new record based on the values provided in the selection.\n\n\nselect\n \n10\n \nas\n \nroomNo\n,\n \nsingle\n \nas\n \ntype\n,\n \nabc\n \nas\n \nassignee\n\n\nupdate\n \nor\n \ninsert\n \ninto\n \nRoomAssigneeTable\n\n    \nset\n \nRoomAssigneeTable\n.\nassignee\n \n=\n \nassignee\n\n    \non\n \nRoomAssigneeTable\n.\nroomNo\n \n==\n \nroomNo\n;\n\n\n\n\n\n\nExtensions\n\n\nSiddhi supports an extension architecture to enhance its functionality by incorporating other libraries in a seamless manner.\n\n\nPurpose\n\n\nExtensions are supported because, Siddhi core cannot have all the functionality that's needed for all the use cases, mostly use cases require\ndifferent type of functionality, and for some cases there can be gaps and you need to write the functionality by yourself.\n\n\nAll extensions have a namespace. This is used to identify the relevant extensions together, and to let you specifically call the extension.\n\n\nSyntax\n\n\nExtensions follow the following syntax;\n\n\nnamespace\n:\nfunction\n \nname\n(\nparameter\n,\n \nparameter\n,\n \n...\n \n)\n\n\n\n\n\n\nThe following parameters are configured when referring a script function.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnamespace\n\n\nAllows Siddhi to identify the extension without conflict\n\n\n\n\n\n\nfunction name\n\n\nThe name of the function referred.\n\n\n\n\n\n\nparameter\n\n\nThe function input parameter for function execution.\n\n\n\n\n\n\n\n\n\n\nExtension Types\n\n\nSiddhi supports following extension types:\n\n\n\n\n\n\nFunction\n\n\nFor each event, it consumes zero or more parameters as input parameters and returns a single attribute. This can be used to manipulate existing event attributes to generate new attributes like any Function operation.\n\n\nThis is implemented by extending \nio.siddhi.core.executor.function.FunctionExecutor\n.\n\n\nExample :\n\n\nmath:sin(x)\n\n\nHere, the \nsin\n function of \nmath\n extension returns the sin value for the \nx\n parameter.\n\n\n\n\n\n\nAggregate Function\n\n\nFor each event, it consumes zero or more parameters as input parameters and returns a single attribute with aggregated results. This can be used in conjunction with a window in order to find the aggregated results based on the given window like any Aggregate Function operation.\n\n\nThis is implemented by extending \nio.siddhi.core.query.selector.attribute.aggregator.AttributeAggregatorExecutor\n.\n\n\nExample :\n\n\ncustom:std(x)\n\n\nHere, the \nstd\n aggregate function of \ncustom\n extension returns the standard deviation of the \nx\n value based on its assigned window query.\n\n\n\n\n\n\nWindow\n\n\nThis allows events to be \ncollected, generated, dropped and expired anytime\n \nwithout altering\n the event format based on the given input parameters, similar to any other Window operator.\n\n\nThis is implemented by extending \nio.siddhi.core.query.processor.stream.window.WindowProcessor\n.\n\n\nExample :\n\n\ncustom:unique(key)\n\n\nHere, the \nunique\n window of the \ncustom\n extension retains one event for each unique \nkey\n parameter.\n\n\n\n\n\n\nStream Function\n\n\nThis allows events to be  \ngenerated or dropped only during event arrival\n and \naltered\n by adding one or more attributes to it.\n\n\nThis is implemented by extending  \nio.siddhi.core.query.processor.stream.function.StreamFunctionProcessor\n.\n\n\nExample :  \n\n\ncustom:pol2cart(theta,rho)\n\n\nHere, the \npol2cart\n function of the \ncustom\n extension returns all the events by calculating the cartesian coordinates \nx\n \n \ny\n and adding them as new attributes to the events.\n\n\n\n\n\n\nStream Processor\n\n\nThis allows events to be \ncollected, generated, dropped and expired anytime\n by \naltering\n the event format by adding one or more attributes to it based on the given input parameters.\n\n\nImplemented by extending \nio.siddhi.core.query.processor.stream.StreamProcessor\n.\n\n\nExample :  \n\n\ncustom:perMinResults(\nparameter\n, \nparameter\n, ...)\n\n\nHere, the \nperMinResults\n function of the \ncustom\n extension returns all events by adding one or more attributes to the events based on the conversion logic. Altered events are output every minute regardless of event arrivals.\n\n\n\n\n\n\nSink\n\n\nSinks provide a way to \npublish Siddhi events to external systems\n in the preferred data format. Sinks publish events from the streams via multiple transports to external endpoints in various data formats.\n\n\nImplemented by extending \nio.siddhi.core.stream.output.sink.Sink\n.\n\n\nExample :\n\n\n@sink(type='sink_type', static_option_key1='static_option_value1')\n\n\nTo configure a stream to publish events via a sink, add the sink configuration to a stream definition by adding the @sink annotation with the required parameter values. The sink syntax is as above\n\n\n\n\n\n\nSource\n\n\nSource allows Siddhi to \nconsume events from external systems\n, and map the events to adhere to the associated stream. Sources receive events via multiple transports and in various data formats, and direct them into streams for processing.\n\n\nImplemented by extending \nio.siddhi.core.stream.input.source.Source\n.\n\n\nExample :\n\n\n@source(type='source_type', static.option.key1='static_option_value1')\n\n\nTo configure a stream that consumes events via a source, add the source configuration to a stream definition by adding the @source annotation with the required parameter values. The source syntax is as above\n\n\n\n\n\n\nStore\n\n\nYou can use Store extension type to work with data/events \nstored in various data stores through the table abstraction\n. You can find more information about these extension types under the heading 'Extension types' in this document.\n\n\nImplemented by extending \nio.siddhi.core.table.record.AbstractRecordTable\n.\n\n\n\n\n\n\nScript\n\n\nScripts allow you to \ndefine a function\n operation that is not provided in Siddhi core or its extension. It is not required to write an extension to define the function logic. Scripts allow you to write functions in other programming languages and execute them within Siddhi queries. Functions defined via scripts can be accessed in queries similar to any other inbuilt function.\n\n\nImplemented by extending \nio.siddhi.core.function.Script\n.\n\n\n\n\n\n\nSource Mapper\n\n\nEach \n@source\n configuration has a mapping denoted by the \n@map\n annotation that \nconverts the incoming messages format to Siddhi events\n.The type parameter of the @map defines the map type to be used to map the data. The other parameters to be configured depends on the mapper selected. Some of these parameters are optional.\n\n\nImplemented by extending \nio.siddhi.core.stream.output.sink.SourceMapper\n.\n\n\nExample :\n\n\n@map(type='map_type', static_option_key1='static_option_value1')\n\n\n\n\n\n\nSink Mapper\n\n\nEach \n@sink\n configuration has a mapping denoted by the \n@map\n annotation that \nconverts the outgoing Siddhi events to configured messages format\n.The type parameter of the @map defines the map type to be used to map the data. The other parameters to be configured depends on the mapper selected. Some of these parameters are optional.\n\n\nImplemented by extending \nio.siddhi.core.stream.output.sink.SinkMapper\n.\n\n\nExample :\n\n\n@map(type='map_type', static_option_key1='static_option_value1')\n\n\n\n\n\n\nExample\n\n\nA window extension created with namespace \nfoo\n and function name \nunique\n can be referred as follows:\n\n\nfrom\n \nStockExchangeStream\n[\nprice\n \n=\n \n20\n]\n#\nwindow\n.\nfoo\n:\nunique\n(\nsymbol\n)\n\n\nselect\n \nsymbol\n,\n \nprice\n\n\ninsert\n \ninto\n \nStockQuote\n\n\n\n\n\n\nAvailable Extensions\n\n\nSiddhi currently has several pre written extensions that are available \nhere\n\n\nWe value your contribution on improving Siddhi and its extensions further.\n\n\nWriting Custom Extensions\n\n\nCustom extensions can be written in order to cater use case specific logic that are not available in Siddhi out of the box or as an existing extension.\n\n\nThere are five types of Siddhi extensions that you can write to cater your specific use cases. These\nextension types and the related maven archetypes are given below. You can use these archetypes to generate Maven projects for each\nextension type.\n\n\n\n\nFollow the procedure for the required archetype, based on your project:\n\n\n\n\n\n\nNote\n\n\nWhen using the generated archetype please make sure you uncomment @Extension annotation and complete the\nannotation with proper values. This annotation will be used to identify and document the extension, hence your\nextension will not work without @Extension annotation.\n\n\n\n\nsiddhi-execution\n\n\nSiddhi-execution provides following extension types:\n\n\n\n\nFunction\n\n\nAggregate Function\n\n\nStream Function\n\n\nStream Processor\n\n\nWindow\n\n\n\n\nYou can use one or more from above mentioned extension types and implement according to your requirement.\n\n\nFor more information about these extension types, see \nExtension Types\n.\n\n\nTo install and implement the siddhi-io extension archetype, follow the procedure below:\n\n\n\n\n\n\nIssue the following command from your CLI.\n\n\n        mvn archetype:generate\n            -DarchetypeGroupId=io.siddhi.extension.archetype\n            -DarchetypeArtifactId=siddhi-archetype-execution\n            -DgroupId=io.extension.siddhi.execution\n            -Dversion=1.0.0-SNAPSHOT\n\n\n\n\n\n\n\n\n\nEnter the required execution name in the message that pops up as shown in the example below.\n\n\n    Define value for property \nexecutionType\n: ML\n\n\n\n\n\n\n\n\n\nTo confirm that all property values are correct, type \nY\n in the console. If not, press \nN\n.\n\n\n\n\n\n\nsiddhi-io\n\n\nSiddhi-io provides following extension types:\n\n\n\n\nSink\n\n\nSource\n\n\n\n\nYou can use one or more from above mentioned extension types and implement according to your requirement. siddhi-io is generally used to work with IO operations as follows:\n * The Source extension type gets inputs to your Siddhi application.\n * The Sink extension publishes outputs from your Siddhi application.\n\n\nFor more information about these extension types, see \nExtension Types\n.\n\n\nTo implement the siddhi-io extension archetype, follow the procedure below:\n\n\n\n\n\n\nIssue the following command from your CLI.\n\n\n       mvn archetype:generate\n           -DarchetypeGroupId=io.siddhi.extension.archetype\n           -DarchetypeArtifactId=siddhi-archetype-io\n           -DgroupId=io.extension.siddhi.io\n           -Dversion=1.0.0-SNAPSHOT\n\n\n\n\n\n\n\n\n\nEnter the required execution name (the transport type in this scenario) in the message that pops up as shown in the example below.\n\n\n Define value for property \ntypeOf_IO\n: http\n\n\n\n\n\n\n\n\n\nTo confirm that all property values are correct, type \nY\n in the console. If not, press \nN\n.\n\n\n\n\n\n\nsiddhi-map\n\n\nSiddhi-map provides following extension types,\n\n\n\n\nSink Mapper\n\n\nSource Mapper\n\n\n\n\nYou can use one or more from above mentioned extension types and implement according to your requirement as follows.\n\n\n\n\nThe Source Mapper maps events to a predefined data format (such as XML, JSON, binary, etc), and publishes them to external endpoints (such as E-mail, TCP, Kafka, HTTP, etc).\n\n\nThe Sink Mapper also maps events to a predefined data format, but it does it at the time of publishing events from a Siddhi application.\n\n\n\n\nFor more information about these extension types, see \nExtension Types\n.\n\n\nTo implement the siddhi-map extension archetype, follow the procedure below:\n\n\n\n\n\n\nIssue the following command from your CLI.                \n\n\n        mvn archetype:generate\n            -DarchetypeGroupId=io.siddhi.extension.archetype\n            -DarchetypeArtifactId=siddhi-archetype-map\n            -DgroupId=io.extension.siddhi.map\n            -Dversion=1.0.0-SNAPSHOT\n\n\n\n\n\n\n\n\n\nEnter the required execution name (the map type in this scenario) in the message that pops up as shown in the example below.\n\n\n    Define value for property \nmapType\n:CSV\n\n\n\n\n\n\n\n\n\nTo confirm that all property values are correct, type \nY\n in the console. If not, press \nN\n.\n\n\n\n\n\n\nsiddhi-script\n\n\nSiddhi-script provides the \nScript\n extension type.\n\n\nThe script extension type allows you to write functions in other programming languages and execute them within Siddhi queries. Functions defined via scripts can be accessed in queries similar to any other inbuilt function.\n\n\nFor more information about these extension types, see \nExtension Types\n.\n\n\nTo implement the siddhi-script extension archetype, follow the procedure below:\n\n\n\n\n\n\nIssue the following command from your CLI.                   \n\n\n       mvn archetype:generate\n           -DarchetypeGroupId=io.siddhi.extension.archetype\n           -DarchetypeArtifactId=siddhi-archetype-script\n           -DgroupId=io.extension.siddhi.script\n           -Dversion=1.0.0-SNAPSHOT\n\n\n\n\n\n\n\n\n\nEnter the required execution name in the message that pops up as shown in the example below.\n\n\n Define value for property \ntypeOfScript\n:\n\n\n\n\n\n\n\n\n\nTo confirm that all property values are correct, type \nY\n in the console. If not, press \nN\n.\n\n\n\n\n\n\nsiddhi-store\n\n\nSiddhi-store provides the \nStore\n extension type.\n\n\nThe Store extension type allows you to work with data/events stored in various data stores through the table abstraction.\n\n\nFor more information about these extension types, see \nExtension Types\n.\n\n\nTo implement the siddhi-store extension archetype, follow the procedure below:\n\n\n\n\n\n\nIssue the following command from your CLI.                      \n\n\n       mvn archetype:generate\n          -DarchetypeGroupId=io.siddhi.extension.archetype\n          -DarchetypeArtifactId=siddhi-archetype-store\n          -DgroupId=io.extension.siddhi.store\n          -Dversion=1.0.0-SNAPSHOT\n\n\n\n\n\n\n\n\n\nEnter the required execution name in the message that pops up as shown in the example below.\n\n\n  Define value for property \nstoreType\n: RDBMS\n\n\n\n\n\n\n\n\n\nTo confirm that all property values are correct, type \nY\n in the console. If not, press \nN\n.\n\n\n\n\n\n\nConfiguring and Monitoring Siddhi Applications\n\n\nMulti-threading and Asynchronous Processing\n\n\nWhen \n@Async\n annotation is added to the Streams it enable the Streams to introduce asynchronous and multi-threading\nbehaviour.\n\n\n@\nAsync\n(\nbuffer\n.\nsize\n=\n256\n,\n \nworkers\n=\n2\n,\n \nbatch\n.\nsize\n.\nmax\n=\n5\n)\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n);\n\n\n\n\n\n\nThe following elements are configured with this annotation.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nDescription\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nbuffer.size\n\n\nThe size of the event buffer that will be used to handover the execution to other threads.\n\n\n-\n\n\n\n\n\n\nworkers\n\n\nNumber of worker threads that will be be used to process the buffered events.\n\n\n1\n\n\n\n\n\n\nbatch.size.max\n\n\nThe maximum number of events that will be processed together by a worker thread at a given time.\n\n\nbuffer.size\n\n\n\n\n\n\n\n\nStatistics\n\n\nUse \n@app:statistics\n app level annotation to evaluate the performance of an application, you can enable the statistics of a Siddhi application to be published. This is done via the \n@app:statistics\n annotation that can be added to a Siddhi application as shown in the following example.\n\n\n@\napp\n:\nstatistics\n(\nreporter\n \n=\n \nconsole\n)\n\n\n\n\n\n\nThe following elements are configured with this annotation.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nDescription\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nreporter\n\n\nThe interface in which statistics for the Siddhi application are published. Possible values are as follows:\n \nconsole\n \njmx\n\n\nconsole\n\n\n\n\n\n\ninterval\n\n\nThe time interval (in seconds) at  which the statistics for the Siddhi application are reported.\n\n\n60\n\n\n\n\n\n\ninclude\n\n\nIf this parameter is added, only the types of metrics you specify are included in the reporting. The required metric types can be specified as a comma-separated list. It is also possible to use wild cards\n\n\nAll (\n.\n)\n\n\n\n\n\n\n\n\nThe metrics are reported in the following format.\n\nio.siddhi.SiddhiApps.\nSiddhiAppName\n.Siddhi.\nComponent Type\n.\nComponent Name\n. \nMetrics name\n\n\nThe following table lists the types of metrics supported for different Siddhi application component types.\n\n\n\n\n\n\n\n\nComponent Type\n\n\nMetrics Type\n\n\n\n\n\n\n\n\n\n\nStream\n\n\nThroughput\nThe size of the buffer if parallel processing is enabled via the @async annotation.\n\n\n\n\n\n\nTrigger\n\n\nThroughput (Trigger and Stream)\n\n\n\n\n\n\nSource\n\n\nThroughput\n\n\n\n\n\n\nSink\n\n\nThroughput\n\n\n\n\n\n\nMapper\n\n\nLatency\nInput/output throughput\n\n\n\n\n\n\nTable\n\n\nMemory\nThroughput (For all operations)\nThroughput (For all operations)\n\n\n\n\n\n\nQuery\n\n\nMemory\nLatency\n\n\n\n\n\n\nWindow\n\n\nThroughput (For all operations)\nLatency (For all operation)\n\n\n\n\n\n\nPartition\n\n\nThroughput (For all operations)\nLatency (For all operation)\n\n\n\n\n\n\n\n\ne.g., the following is a Siddhi application that includes the \n@app\n annotation to report performance statistics.\n\n\n@\nApp\n:\nname\n(\nTestMetrics\n)\n\n\n@\nApp\n:\nStatistics\n(\nreporter\n \n=\n \nconsole\n)\n\n\n\ndefine\n \nstream\n \nTestStream\n \n(\nmessage\n \nstring\n);\n\n\n\n@\ninfo\n(\nname\n=\nlogQuery\n)\n\n\nfrom\n \nTestSream\n#\nlog\n(\nMessage:\n)\n\n\ninsert\n \ninto\n \nTempSream\n;\n\n\n\n\n\n\nStatistics are reported for this Siddhi application as shown in the extract below.\n\n\n\n  \nClick to view the extract\n\n11/26/17 8:01:20 PM ============================================================\n\n\n-- Gauges ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Queries.logQuery.memory\n              value = 5760\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TestStream.size\n              value = 0\n\n\n-- Meters ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Sources.TestStream.http.throughput\n              count = 0\n          mean rate = 0.00 events/second\n      1-minute rate = 0.00 events/second\n      5-minute rate = 0.00 events/second\n     15-minute rate = 0.00 events/second\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TempSream.throughput\n              count = 2\n          mean rate = 0.04 events/second\n      1-minute rate = 0.03 events/second\n      5-minute rate = 0.01 events/second\n     15-minute rate = 0.00 events/second\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TestStream.throughput\n              count = 2\n          mean rate = 0.04 events/second\n      1-minute rate = 0.03 events/second\n      5-minute rate = 0.01 events/second\n     15-minute rate = 0.00 events/second\n\n\n-- Timers ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Queries.logQuery.latency\n              count = 2\n          mean rate = 0.11 calls/second\n      1-minute rate = 0.34 calls/second\n      5-minute rate = 0.39 calls/second\n     15-minute rate = 0.40 calls/second\n                min = 0.61 milliseconds\n                max = 1.08 milliseconds\n               mean = 0.84 milliseconds\n             stddev = 0.23 milliseconds\n             median = 0.61 milliseconds\n               75% \n= 1.08 milliseconds\n               95% \n= 1.08 milliseconds\n               98% \n= 1.08 milliseconds\n               99% \n= 1.08 milliseconds\n             99.9% \n= 1.08 milliseconds\n\n\n\n\nEvent Playback\n\n\nWhen \n@app:playback\n annotation is added to the app, the timestamp of the event (specified via an attribute) is treated as the current time. This results in events being processed faster.\nThe following elements are configured with this annotation.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nidle.time\n\n\nIf no events are received during a time interval specified (in milliseconds) via this element, the Siddhi system time is incremented by a number of seconds specified via the \nincrement\n element.\n\n\n\n\n\n\nincrement\n\n\nThe number of seconds by which the Siddhi system time must be incremented if no events are received during the time interval specified via the \nidle.time\n element.\n\n\n\n\n\n\n\n\ne.g., In the following example, the Siddhi system time is incremented by two seconds if no events arrive for a time interval of 100 milliseconds.\n\n\n@app:playback(idle.time = '100 millisecond', increment = '2 sec')", 
            "title": "Siddhi Query Guide"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#siddhi-5x-streaming-sql-guide", 
            "text": "Info  Please find the  Siddhi 4.x Streaming SQL Guide here", 
            "title": "Siddhi 5.x Streaming SQL Guide"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#introduction", 
            "text": "Siddhi Streaming SQL is designed to process streams of events. It can be used to\nimplement streaming data integration, streaming analytics, rule based and\nadaptive decision making use cases.\nIt is an evolution of Complex Event Processing (CEP) and Stream Processing\nsystems, hence it can also be used to process stateful computations, detecting\nof complex event patterns, and sending notifications in real-time.  Siddhi Streaming SQL uses SQL like syntax, and annotations to consume events\nfrom diverse event sources with various data formats, process then using\nstateful and stateless operators and send outputs to multiple endpoints\naccording to their accepted event formats. It also supports exposing rule based\nand adaptive decision making as service endpoints such that external programs\nand systems can synchronously get decision support form Siddhi.    The following sections explains how to write processing logic using Siddhi Streaming SQL.", 
            "title": "Introduction"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#siddhi-application", 
            "text": "The processing logic for your program can be written using the Streaming SQL and\nput together as a single file with  .siddhi  extension. This file is called as\nthe  Siddhi Application  or the  SiddhiApp .  SiddhiApps are named by adding  @app:name(' name ')  annotation on the top of the SiddhiApp file.\nWhen the annotation is not added Siddhi assigns a random UUID as the name of the SiddhiApp.  Purpose  SiddhiApp provides an isolated execution environment for your processing logic that allows you to\ndeploy and execute processing logic independent of other SiddhiApp in the system.\nTherefore it's always recommended to have a processing logic related to single\nuse case in a single SiddhiApp. This will help you to group\nprocessing logic and easily manage addition and removal of various use cases.  The following diagram depicts some of the key Siddhi Streaming SQL elements of Siddhi Application and\nhow  event flows  through the elements.   Below table provides brief description of a few key elements in the Siddhi Streaming SQL Language.     Elements  Description      Stream  A logical series of events ordered in time with a uniquely identifiable name, and a defined set of typed attributes defining its schema.    Event  An event is a single event object associated with a stream. All events of a stream contains a timestamp and an identical set of typed attributes based on the schema of the stream they belong to.    Table  A structured representation of data stored with a defined schema. Stored data can be backed by  In-Memory , or external data stores such as  RDBMs ,  MongoDB , etc. The tables can be accessed and manipulated at runtime.    Window  A structured representation of data stored with a defined schema and eviction policy. Window data is stored  In-Memory  and automatically cleared by the defined window constrain. Other siddhi elements can only query the values in windows at runtime but they cannot modify them.    Aggregation  A structured representation of data that's incrementally aggregated and stored with a defined schema and aggregation granularity such as seconds, minutes, hours, etc. Aggregation data is stored both  In-Memory and in external data stores such as  RDBMs . Other siddhi elements can only query the values in windows at runtime but they cannot modify them.    Query  A logical construct that processes events in streaming manner by by consuming data from one or more streams, tables, windows and aggregations, and publishes output events into a stream, table or a window.    Source  A construct that consumes data from external sources (such as  TCP ,  Kafka ,  HTTP , etc) with various event formats such as  XML ,  JSON ,  binary , etc, convert then to Siddhi events, and passes into streams for processing.    Sink  A construct that consumes events arriving at a stream, maps them to a predefined data format (such as  XML ,  JSON ,  binary , etc), and publishes them to external endpoints (such as  E-mail ,  TCP ,  Kafka ,  HTTP , etc).    Input Handler  A mechanism to programmatically inject events into streams.    Stream/Query Callback  A mechanism to programmatically consume output events from streams or queries.    Partition  A logical container that isolates the processing of queries based on the partition keys derived from the events.    Inner Stream  A positionable stream that connects portioned queries with each other within the partition.     Grammar  SiddhiApp is a collection of Siddhi Streaming SQL elements composed together as a script.\nHere each Siddhi element must be separated by a semicolon  ( ; ) .  Hight level syntax of SiddhiApp is as follows.  siddhi app   :\n         app annotation  *\n        (  stream definition  |  table definition  | ... ) +\n        (  query  |  partition  ) +\n        ;  Example  Siddhi Application with name  Temperature-Analytics  defined with a stream named  TempStream  and a query\nnamed  5minAvgQuery .  @ app : name ( Temperature-Analytics )  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  @ name ( 5minAvgQuery )  from   TempStream # window . time ( 5   min )  select   roomNo ,   avg ( temp )   as   avgTemp \n   group   by   roomNo  insert   into   OutputStream ;", 
            "title": "Siddhi Application"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#stream", 
            "text": "A stream is a logical series of events ordered in time. Its schema is defined via the  stream definition .\nA stream definition contains the stream name and a set of attributes with specific types and uniquely identifiable names within the stream. All events associated to the stream will have the same schema (i.e., have the same attributes in the same order).  Purpose  Stream groups common types of events together with a schema. This helps in various ways such as, processing all events together in queries and performing data format transformations together when they are consumed and published via sources and sinks.  Syntax  The syntax for defining a new stream is as follows.  define   stream   stream   name   ( attribute   name   attribute   type , \n                              attribute   name   attribute   type ,   ...   );   The following parameters are used to configure a stream definition.     Parameter  Description      stream name  The name of the stream created. (It is recommended to define a stream name in  PascalCase .)    attribute name  Uniquely identifiable name of the stream attribute. (It is recommended to define attribute names in  camelCase .)    attribute type  The type of each attribute defined in the schema.   This can be  STRING ,  INT ,  LONG ,  DOUBLE ,  FLOAT ,  BOOL  or  OBJECT .     To use and refer stream and attribute names that do not follow  [a-zA-Z_][a-zA-Z_0-9]*  format enclose them in  ` . E.g.  `$test(0)` .  To make the stream process events in multi-threading and asynchronous way use the  @Async  annotation as shown in Multi-threading and Asynchronous Processing  configuration section.  Example  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );   The above creates a stream with name  TempStream  having the following attributes.   deviceID  of type  long  roomNo  of type  int  temp  of type  double", 
            "title": "Stream"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#source", 
            "text": "Sources receive events via multiple transports and in various data formats, and direct them into streams for processing.  A source configuration allows to define a mapping in order to convert each incoming event from its native data format to a Siddhi event. When customizations to such mappings are not provided, Siddhi assumes that the arriving event adheres to the predefined format based on the stream definition and the configured message mapping type.  Purpose  Source provides a way to consume events from external systems and convert them to be processed by the associated stream.  Syntax  To configure a stream that consumes events via a source, add the source configuration to a stream definition by adding the  @source  annotation with the required parameter values.  The source syntax is as follows:  @ source ( type = source type ,   static . key = value ,   static . key = value , \n     @ map ( type = map type ,   static . key = value ,   static . key = value , \n         @ attributes (   attribute1 = attribute mapping ,   attributeN = attribute mapping ) \n     )  )  define   stream   stream   name   ( attribute1   type ,   attributeN   type );   This syntax includes the following annotations.  Source  The  type  parameter of  @source  annotation defines the source type that receives events.\nThe other parameters of  @source  annotation depends upon the selected source type, and here\nsome of its parameters can be optional.  For detailed information about the supported parameters see the documentation of the relevant source.  The following is the list of source types supported by Siddhi:     Source type  Description      In-memory  Allow SiddhiApp to consume events from other SiddhiApps running on the same JVM.    HTTP  Expose an HTTP service to consume messages.    Kafka  Subscribe to Kafka topic to consume events.    TCP  Expose a TCP service to consume messages.    WSO2Event  Expose a Thrift and TCP services to consume events formatted as WSO2Events.    Email  Consume emails via POP3 and IMAP protocols.    JMS  Subscribe to JMS topic or queue to consume events.    File  Reads files by tailing or as a whole to extract events out of them.    RabbitMQ  Subscribe to RabbitMQ topic to consume events.    MQTT  Subscribe to MQTT brokers to consume events.    WebSocket  Create a web-socket connection or expose a service to consume messages.    Twitter  Subscribe to Twitter to consume tweets.    Amazon SQS  Subscribe to Amazon SQS to consume events.    CDC  Perform change data capture on databases.    Prometheus  Consume data from Prometheus agent.     In-memory  is the only source inbuilt in Siddhi, and all other source types are implemented as extensions.", 
            "title": "Source"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#source-mapper", 
            "text": "Each  @source  configuration can have a mapping denoted by the  @map  annotation that defines how to convert the incoming event\nformat to Siddhi events.  The  type  parameter of the  @map  defines the map type to be used in converting the incoming events. The other parameters\nof  @map  annotation depends on the mapper selected, and some of its parameters can be optional.  For detailed information about the parameters see the documentation of the relevant mapper.  Map Attributes  @attributes  is an optional annotation used with  @map  to define custom mapping. When  @attributes  is not provided, each mapper\nassumes that the incoming events adheres to its own default message format and attempt to convert the events from that format.\nBy adding the  @attributes  annotation, users can selectively extract data from the incoming message and assign them to the attributes.  There are two ways to configure  @attributes .    Define attribute names as keys, and mapping configurations as values: \n   @attributes(  attribute1 =' mapping ',  attributeN =' mapping ')    Define the mapping configurations in the same order as the attributes defined in stream definition: \n   @attributes( ' mapping for attribute1 ', ' mapping for attributeN ')    Supported Source Mapping Types  The following is the list of source mapping types supported by Siddhi:     Source mapping type  Description      PassThrough  Omits data conversion on Siddhi events.    JSON  Converts JSON messages to Siddhi events.    XML  Converts XML messages to Siddhi events.    TEXT  Converts plain text messages to Siddhi events.    Avro  Converts Avro events to Siddhi events.    WSO2Event  Converts WSO2Events to Siddhi events.    Binary  Converts Siddhi specific binary events to Siddhi events.    Key Value  Converts key-value HashMaps to Siddhi events.    CSV  Converts CSV like delimiter separated events to Siddhi events.      Tip  When the  @map  annotation is not provided  @map(type='passThrough')  is used as default, that passes the consumed Siddhi events directly to the streams without any data conversion.   PassThrough  is the only source mapper inbuilt in Siddhi, and all other source mappers are implemented as extensions.  Example 1  Receive  JSON  messages by exposing an  HTTP  service, and direct them to  InputStream  stream for processing.\nHere the  HTTP  service will be secured with basic authentication, receives events on all network interfaces on port  8080  and context  /foo . The service expects the  JSON  messages to be on the default data format that's supported by the  JSON  mapper as follows.  { \n   name : Paul , \n   age : 20 , \n   country : UK  }   The configuration of the  HTTP  source and  JSON  source mapper to achieve the above is as follows.  @ source ( type = http ,   receiver . url = http://0.0.0.0:8080/foo , \n   @ map ( type = json ))  define   stream   InputStream   ( name   string ,   age   int ,   country   string );   Example 2  Receive  JSON  messages by exposing an  HTTP  service, and direct them to  StockStream  stream for processing.\nHere the incoming  JSON , as given bellow, do not adhere to the default data format that's supported by the  JSON  mapper.  { \n   portfolio :{ \n     stock :{ \n       volume : 100 , \n       company :{ \n         symbol : FB \n       }, \n       price : 55.6 \n     } \n   }  }   The configuration of the  HTTP  source and the custom  JSON  source mapping to achieve the above is as follows.  @ source ( type = http ,   receiver . url = http://0.0.0.0:8080/foo , \n   @ map ( type = json ,   enclosing . element = $.portfolio , \n     @ attributes ( symbol   =   stock.company.symbol ,   price   =   stock.price , \n                 volume   =   stock.volume )))  define   stream   StockStream   ( symbol   string ,   price   float ,   volume   long );   The same can also be configured by omitting the attribute names as bellow.  @ source ( type = http ,   receiver . url = http://0.0.0.0:8080/foo , \n   @ map ( type = json ,   enclosing . element = $.portfolio , \n     @ attributes ( stock.company.symbol ,   stock.price ,   stock.volume )))  define   stream   StockStream   ( symbol   string ,   price   float ,   volume   long );", 
            "title": "Source Mapper"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#sink", 
            "text": "Sinks consumes events from streams and publish them via multiple transports to external endpoints in various data formats.  A sink configuration allows users to define a mapping to convert the Siddhi events in to the required output data format (such as  JSON ,  TEXT ,  XML , etc.) and publish the events to the configured endpoints. When customizations to such mappings are not provided, Siddhi converts events to the predefined event format based on the stream definition and the configured message mapper type before publishing the events.  Purpose  Sink provides a way to publish Siddhi events of a stream to external systems by converting events to their supported format.  Syntax  To configure a stream to publish events via a sink, add the sink configuration to a stream definition by adding the  @sink \nannotation with the required parameter values.  The sink syntax is as follows:  @ sink ( type = sink type ,   static . key = value ,   dynamic . key = {{ value }} , \n     @ map ( type = map type ,   static . key = value ,   dynamic . key = {{ value }} , \n         @ payload ( payload mapping ) \n     )  )  define   stream   stream   name   ( attribute1   type ,   attributeN   type );    Dynamic Properties  The sink and sink mapper properties that are categorized as  dynamic  have the ability to absorb attribute values\ndynamically from the Siddhi events of their associated streams. This can be configured by enclosing the relevant\nattribute names in double curly braces as {{...}} , and using it within the property values.  Some valid dynamic properties values are:   '{{attribute1}}'  'This is {{attribute1}}'  {{attribute1}}   {{attributeN}}      Here the attribute names in the double curly braces will be replaced with the values from the events before they are published.   This syntax includes the following annotations.  Sink  The  type  parameter of the  @sink  annotation defines the sink type that publishes the events.\nThe other parameters of the  @sink  annotation depends upon the selected sink type, and here\nsome of its parameters can be optional and/or dynamic.  For detailed information about the supported parameters see documentation of the relevant sink.  The following is a list of sink types supported by Siddhi:     Source type  Description      In-memory  Allow SiddhiApp to publish events to other SiddhiApps running on the same JVM.    Log  Logs the events appearing on the streams.    HTTP  Publish events to an HTTP endpoint.    Kafka  Publish events to Kafka topic.    TCP  Publish events to a TCP service.    WSO2Event  Publish WSO2Events via Thrift or TCP protocols.    Email  Send emails via SMTP protocols.    JMS  Publish events to JMS topics or queues.    File  Writes events to files.    RabbitMQ  Publish events to RabbitMQ topics.    MQTT  Publish events to MQTT topics.    WebSocket  Create a web-socket connection or expose a service to publish messages.    Amazon SQS  Publish events to Amazon SQS.    Prometheus  Expose data through Prometheus agent.", 
            "title": "Sink"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#distributed-sink", 
            "text": "Distributed Sinks publish events from a defined stream to multiple endpoints using load balancing or partitioning strategies.  Any sink can be used as a distributed sink. A distributed sink configuration allows users to define a common mapping to convert\nand send the Siddhi events for all its destination endpoints.  Purpose  Distributed sink provides a way to publish Siddhi events to multiple endpoints in the configured event format.  Syntax  To configure distributed sink add the sink configuration to a stream definition by adding the  @sink \nannotation and add the configuration parameters that are common of all the destination endpoints inside it,\nalong with the common parameters also add the  @distribution  annotation specifying the distribution strategy (i.e.  roundRobin  or  partitioned ) and  @destination  annotations providing each endpoint specific configurations.  The distributed sink syntax is as follows:  RoundRobin Distributed Sink  Publishes events to defined destinations in a round robin manner.  @ sink ( type = sink type ,   common . static . key = value ,   common . dynamic . key = {{ value }} , \n     @ map ( type = map type ,   static . key = value ,   dynamic . key = {{ value }} , \n         @ payload ( payload mapping ) \n     ) \n     @ distribution ( strategy = roundRobin , \n         @ destination ( destination . specific . key = value ), \n         @ destination ( destination . specific . key = value )))  )  define   stream   stream   name   ( attribute1   type ,   attributeN   type );   Partitioned Distributed Sink  Publishes events to defined destinations by partitioning them based on the partitioning key.  @ sink ( type = sink type ,   common . static . key = value ,   common . dynamic . key = {{ value }} , \n     @ map ( type = map type ,   static . key = value ,   dynamic . key = {{ value }} , \n         @ payload ( payload mapping ) \n     ) \n     @ distribution ( strategy = partitioned ,   partitionKey = partition key , \n         @ destination ( destination . specific . key = value ), \n         @ destination ( destination . specific . key = value )))  )  define   stream   stream   name   ( attribute1   type ,   attributeN   type );", 
            "title": "Distributed Sink"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#sink-mapper", 
            "text": "Each  @sink  configuration can have a mapping denoted by the  @map  annotation that defines how to convert Siddhi events to outgoing messages with the defined format.  The  type  parameter of the  @map  defines the map type to be used in converting the outgoing events. The other parameters of  @map  annotation depends on the mapper selected, and some of its parameters can be optional and/or dynamic.  For detailed information about the parameters see the documentation of the relevant mapper.  Map Payload  @payload  is an optional annotation used with  @map  to define custom mapping. When the  @payload  annotation is not provided, each mapper maps the outgoing events to its own default event format. The  @payload  annotation allow users to configure mappers to produce the output payload of their choice, and by using dynamic properties within the payload they can selectively extract and add data from the published Siddhi events.  There are two ways you to configure  @payload  annotation.   Some mappers such as  XML ,  JSON , and  Test  only accept one output payload:  \n   @payload( 'This is a test message from {{user}}.')  Some mappers such  key-value  accept series of mapping values:  \n   @payload( key1='mapping_1', 'key2'='user : {{user}}')   \n  Here, the keys of payload mapping can be defined using the dot notation as  a.b.c , or using any constant string value as  '$abc' .   Supported Sink Mapping Types  The following is a list of sink mapping types supported by Siddhi:     Sink mapping type  Description      PassThrough  Omits data conversion on outgoing Siddhi events.    JSON  Converts Siddhi events to JSON messages.    XML  Converts Siddhi events to XML messages.    TEXT  Converts Siddhi events to plain text messages.    Avro  Converts Siddhi events to Avro Events.    WSO2Event  Converts Siddhi events to WSO2Event events.    Binary  Converts Siddhi events to Siddhi specific binary events.    Key Value  Converts Siddhi events to key-value HashMaps.    CSV  Converts Siddhi events to CSV like delimiter separated events.      Tip  When the  @map  annotation is not provided  @map(type='passThrough')  is used as default, that passes the outgoing Siddhi events directly to the sinks without any data conversion.   PassThrough  is the only sink mapper inbuilt in Siddhi, and all other sink mappers are implemented as extensions.  Example 1  Publishes  OutputStream  events by converting them to  JSON  messages with the default format, and by sending to an  HTTP  endpoint  http://localhost:8005/endpoint1 , using  POST  method,  Accept  header, and basic authentication having  admin  is both username and password.  The configuration of the  HTTP  sink and  JSON  sink mapper to achieve the above is as follows.  @ sink ( type = http ,   publisher . url = http://localhost:8005/endpoint , \n       method = POST ,   headers = Accept-Date:20/02/2017 , \n       basic . auth . enabled = true ,   basic . auth . username = admin , \n       basic . auth . password = admin , \n       @ map ( type = json ))  define   stream   OutputStream   ( name   string ,   age   int ,   country   string );   This will publish a  JSON  message on the following format:  { \n   event :{ \n     name : Paul , \n     age : 20 , \n     country : UK \n   }  }   Example 2  Publishes  StockStream  events by converting them to user defined  JSON  messages, and by sending to an  HTTP  endpoint  http://localhost:8005/stocks .  The configuration of the  HTTP  sink and custom  JSON  sink mapping to achieve the above is as follows.  @ sink ( type = http ,   publisher . url = http://localhost:8005/stocks , \n       @ map ( type = json ,   validate . json = true ,   enclosing . element = $.Portfolio , \n            @ payload ( { StockData :{  Symbol : {{ symbol }} ,  Price :{{price}} }} )))  define   stream   StockStream   ( symbol   string ,   price   float ,   volume   long );   This will publish a single event as the  JSON  message on the following format:  { \n   Portfolio :{ \n     StockData :{ \n       Symbol : GOOG , \n       Price : 55.6 \n     } \n   }  }   This can also publish multiple events together as a  JSON  message on the following format:  { \n   Portfolio :[ \n     { \n       StockData :{ \n         Symbol : GOOG , \n         Price : 55.6 \n       } \n     }, \n     { \n       StockData :{ \n         Symbol : FB , \n         Price : 57.0 \n       } \n     } \n   ]    }   Example 3  Publishes events from the  OutputStream  stream to multiple the  HTTP  endpoints using a partitioning strategy. Here the events are sent to either  http://localhost:8005/endpoint1  or  http://localhost:8006/endpoint2  based on the partitioning key  country . It uses default  JSON  mapping,  POST  method, and used  admin  as both the username and the password when publishing to both the endpoints.  The configuration of the distributed  HTTP  sink and  JSON  sink mapper to achieve the above is as follows.  @ sink ( type = http ,   method = POST ,   basic . auth . enabled = true , \n       basic . auth . username = admin ,   basic . auth . password = admin , \n       @ map ( type = json ), \n       @ distribution ( strategy = partitioned ,   partitionKey = country , \n         @ destination ( publisher . url = http://localhost:8005/endpoint1 ), \n         @ destination ( publisher . url = http://localhost:8006/endpoint2 )))  define   stream   OutputStream   ( name   string ,   age   int ,   country   string );   This will partition the outgoing events and publish all events with the same country attribute value to the same endpoint. The  JSON  message published will be on the following format:  { \n   event :{ \n     name : Paul , \n     age : 20 , \n     country : UK \n   }  }", 
            "title": "Sink Mapper"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#error-handling", 
            "text": "Errors in Siddhi can be handled at the Streams and in Sinks.  Error Handling at Stream  When errors are thrown by Siddhi elements subscribed to the stream, the error gets propagated up to the stream that delivered the event to those Siddhi elements. By default the error is logged and dropped at the stream, but this behavior can be altered by by adding  @OnError  annotation to the corresponding stream definition. @OnError  annotation can help users to capture the error and the associated event, and handle them gracefully by sending them to a fault stream.  The  @OnError  annotation and the required  action  to be specified as bellow.  @ OnError ( action = on error action )  define   stream   stream   name   ( attribute   name   attribute   type , \n                              attribute   name   attribute   type ,   ...   );   The  action  parameter of the  @OnError  annotation defines the action to be executed during failure scenarios.\nThe following actions can be specified to  @OnError  annotation to handle erroneous scenarios.   LOG  : Logs the event with the error, and drops the event. This is the default action performed even when  @OnError  annotation is not defined.  STREAM : Creates a fault stream and redirects the event and the error to it. The created fault stream will have all the attributes defined in the base stream to capture the error causing event, and in addition it also contains  _error  attribute of type  object  to containing the error information. The fault stream can be referred by adding  !  in front of the base stream name as  ! stream name .   Example  Handle errors in  TempStream  by redirecting the errors to a fault stream.  The configuration of  TempStream  stream and  @OnError  annotation is as follows.  @ OnError ( name = STREAM )  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );   Siddhi will infer and automatically defines the fault stream of  TempStream  as given bellow.  define   stream   ! TempStream   ( deviceID   long ,   roomNo   int ,   temp   double ,   _error   object );   The SiddhiApp extending the above the use-case by adding failure generation and error handling with the use of  queries  is as follows.  Note: Details on writing processing logics via  queries  will be explained in later sections.  -- Define fault stream to handle error occurred at TempStream subscribers  @ OnError ( name = STREAM )  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  -- Error generation through a custom function `createError()`  @ name ( error-generation )  from   TempStream # custom : createError ()  insert   into   IgnoreStream1 ;  -- Handling error by simply logging the event and error.  @ name ( handle-error )  from   ! TempStream # log ( Error Occurred! )  select   deviceID ,   roomNo ,   temp ,   _error  insert   into   IgnoreStream2 ;   Error Handling at Sink  There can be cases where external systems becoming unavailable or coursing errors when the events are published to them. By default sinks log and drop the events causing event losses, and this can be handled gracefully by configuring  on.error  parameter of the  @sink  annotation.  The  on.error  parameter of the  @sink  annotation can be specified as bellow.  @ sink ( type = sink type ,   on . error = on error action ,   key = value ,   ...)  define   stream   stream   name   ( attribute   name   attribute   type , \n                              attribute   name   attribute   type ,   ...   );   The following actions can be specified to  on.error  parameter of  @sink  annotation to handle erroneous scenarios.   LOG  : Logs the event with the error, and drops the event. This is the default action performed even when  on.error  parameter is not defined on the  @sink  annotation.  WAIT  : Publishing threads wait in  back-off and re-trying  mode, and only send the events when the connection is re-established. During this time the threads will not consume any new messages causing the systems to introduce back pressure on the systems that publishes to it.  STREAM : Pushes the failed events with the corresponding error to the associated fault stream the sink belongs to.   Example 1  Introduce back pressure on the threads who bring events via  TempStream  when the system cannot connect to Kafka.  The configuration of  TempStream  stream and  @sink  Kafka annotation with  on.error  property is as follows.  @ sink ( type = kafka ,   on . error = WAIT ,   topic = {{roomNo}} , \n       bootstrap . servers = localhost:9092 , \n       @ map ( type = xml ))  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );   Example 2  Send events to the fault stream of  TempStream  when the system cannot connect to Kafka.  The configuration of  TempStream  stream with associated fault stream,  @sink  Kafka annotation with  on.error  property and a  queries  to handle the error is as follows.  Note: Details on writing processing logics via  queries  will be explained in later sections.  @ OnError ( name = STREAM )  @ sink ( type = kafka ,   on . error = STREAM ,   topic = {{roomNo}} , \n       bootstrap . servers = localhost:9092 , \n       @ map ( type = xml ))  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  -- Handling error by simply logging the event and error.  @ name ( handle-error )  from   ! TempStream # log ( Error Occurred! )  select   deviceID ,   roomNo ,   temp ,   _error  insert   into   IgnoreStream ;", 
            "title": "Error Handling"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#query", 
            "text": "Query defines the processing logic in Siddhi. It consumes events from one or more streams,  defined-windows ,  tables , and/or  aggregations , process the events in a streaming manner, and generate output events into a  stream ,  defined-window , or  table .  Purpose  A query provides a way to process the events in the order they arrive and produce output using both stateful and stateless complex event processing and stream processing operations.  Syntax  The high level query syntax for defining processing logics is as follows:  @ name ( query name )  from   input  projection  output   action   The following parameters are used to configure a stream definition.     Parameter  Description      query name  The name of the query. Since naming the query (i.e the  @name(' query name ')  annotation) is optional, when the name is not provided Siddhi assign a system generated name for the query.    input  Defines the means of event consumption via  streams ,  named-windows ,  tables , and/or  named-aggregations , and defines the processing logic using  filters ,  windows ,  stream-functions ,  joins ,  patterns  and  sequences .    projection  Generates output event attributes using  select ,  functions ,  aggregation-functions , and  group by  operations, and filters the generated the output using  having ,  limit   offset ,  order by , and  output rate limiting  operations before sending them out. Here the projection is optional and when it is omitted all the input events will be sent to the output as it is.    output action  Defines output action (such as  insert into ,  update ,  delete , etc) that needs to be performed by the generated events on a  stream ,  named-window , or  table     Example  A query consumes events from the  TempStream  stream and output only the  roomNo  and  temp  attributes to the  RoomTempStream  stream, from which another query consumes the events and sends all its attributes to  AnotherRoomTempStream  stream.  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  from   TempStream  select   roomNo ,   temp  insert   into   RoomTempStream ;  from   RoomTempStream  insert   into   AnotherRoomTempStream ;    Inferred Stream  Here, the  RoomTempStream  and  AnotherRoomTempStream  streams are an inferred streams, which means their stream definitions are inferred from the queries and they can be used same as any other defined stream without any restrictions.", 
            "title": "Query"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#select", 
            "text": "The select clause in Siddhi query defines the output event attributes of the query. Following are some basic query projection operations supported by select.  \n     \n         Action \n         Description \n     \n     \n         Select specific attributes for projection \n         Only select some of the input attributes as query output attributes.\n             \n            E.g., Select and output only  roomNo  and  temp  attributes from the  TempStream  stream.\n             from TempStream select roomNo, temp insert into RoomTempStream; \n         \n     \n     \n         Select all attributes for projection \n         Select all input attributes as query output attributes. This can be done by using asterisk (  *  ) or by omitting the  select  clause itself.\n             \n            E.g., Both following queries select all attributes of  TempStream  input stream and output all attributes to  NewTempStream  stream.\n             from TempStream select *  insert into NewTempStream; \n            or\n             from TempStream insert into NewTempStream; \n         \n     \n     \n         Name attribute \n         Provide a unique name for each output attribute generated by the query. This can help to rename the selected input attributes or assign an attribute name to a projection operation such as function, aggregate-function, mathematical operation, etc, using  as  keyword.\n             \n            E.g., Query that renames input attribute  temp  to  temperature  and function  currentTimeMillis()  as  time .\n             from TempStream  select roomNo, temp as temperature, currentTimeMillis() as time insert into RoomTempStream; \n         \n     \n     \n         Constant values as attributes \n         Creates output attributes with a constant value.\n             \n            The constant values can be defined as follows.\n             \n                 \n                     Attribute Type \n                     Format \n                     Example \n                 \n                 \n                     int \n                     + \n                     123 ,  -75 ,  +95 \n                 \n                 \n                     long \n                     +L \n                     123000L ,  -750l ,  +154L \n                 \n                 \n                     float \n                     ( +)?('.' *)? (E(-|+)? +)?F \n                     123.0f ,  -75.0e-10F , +95.789f \n                 \n                 \n                     double \n                     ( +)?('.' *)? (E(-|+)? +)?D? \n                     123.0 , 123.0D , -75.0e-10D , +95.789d \n                 \n                 \n                     bool \n                     (true|false) \n                     true ,  false ,  TRUE ,  FALSE \n                 \n                 \n                     string \n                     '( * !('|\"|\"\"\"|  line ))'  or    \"( * !(\"|\"\"\"|  line ))\"  or  \"\"\"( * !(\"\"\"))\"\"\"   \n                     'Any text.' ,  \"Text with 'single' quotes.\" ,  \"\"\"\nText with 'single' quotes,\n\"double\" quotes, and new lines.\n\"\"\" \n                 \n             \n\n            E.g., Query specifying  'C'  as the constant value for the  scale  attribute.\n             from TempStream select roomNo, temp, 'C' as scale insert into RoomTempStream;     \n         \n     \n     \n         Mathematical and logical expressions in attributes \n         Defines the mathematical and logical operations that need to be performed to generating output attribute values. These expressions are executed in the precedence order given below.\n             \n             Operator precedence \n             \n                 \n                     Operator \n                     Distribution \n                     Example \n                 \n                 \n                     () \n                     Scope \n                     (cost + tax) * 0.05 \n                 \n                 \n                     IS NULL \n                     Null check \n                     deviceID is null \n                 \n                 \n                     NOT \n                     Logical NOT \n                     not (price > 10) \n                 \n                 \n                      *  , / , % \n                     Multiplication, division, modulus \n                     temp * 9/5 + 32 \n                 \n                 \n                     + , - \n                     Addition, subtraction \n                     temp * 9/5 - 32 \n                 \n                 \n                     < , < = , > , >= \n                     Comparators: less-than, greater-than-equal, greater-than, less-than-equal \n                     totalCost >= price * quantity \n                 \n                 \n                     == , != \n                     Comparisons: equal, not equal \n                     totalCost !=  price * quantity \n                 \n                 \n                     IN \n                     Checks if value exist in the table \n                     roomNo in ServerRoomsTable \n                 \n                 \n                     AND \n                     Logical AND \n                     temp  <  40 and humidity  <  40 \n                 \n                 \n                     OR \n                     Logical OR \n                     humidity  <  40 or humidity >= 60 \n                 \n             \n            E.g., Query converts temperature from Celsius to Fahrenheit, and identifies rooms with room number between 10 and 15 as server rooms.\n             from TempStream select roomNo, temp * 9/5 + 32 as temp, 'F' as scale,        roomNo > 10 and roomNo  <  15 as isServerRoom insert into RoomTempStream;", 
            "title": "Select"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#function", 
            "text": "Function are pre-configured operations that can consumes zero, or more parameters and always produce a single value as result. It can be used anywhere an attribute can be used.  Purpose  Functions encapsulate pre-configured reusable execution logic allowing users to execute the logic anywhere just by calling the function. This also make writing SiddhiApps simple and easy to understand.  Function Parameters  Functions parameters are the input to the function. They can be attributes, constant values, results of other functions, results of mathematical or logical expressions, or time values. The number and type of parameters a function accepts depend on the function itself.   Note  Functions, mathematical expressions, and logical expressions can be used in a nested manner.   Time  Time is a special parameter that denotes time using digits and their unit in the format  ( digit +  unit )+ . During the execution, the time parameters get converted into milliseconds and return as long values.  \n     \n         \n            Unit  \n         \n         \n            Syntax\n         \n     \n     \n         \n            Year\n         \n         \n             year  |  years \n         \n     \n     \n         \n            Month\n         \n         \n             month  |  months \n         \n     \n     \n         \n            Week\n         \n         \n             week  |  weeks \n         \n     \n     \n         \n            Day\n         \n         \n             day  |  days \n         \n     \n     \n         \n            Hour\n         \n         \n            hour  |  hours \n         \n     \n     \n         \n           Minutes\n         \n         \n            minute  |  minutes  |  min \n         \n     \n     \n         \n           Seconds\n         \n         \n            second  |  seconds  |  sec \n         \n     \n     \n         \n           Milliseconds\n         \n         \n            millisecond  |  milliseconds \n         \n       E.g. Pass  1 hour and 25 minutes  as the input for  test()  function.   test(1 hour 25 min)  Following are some inbuilt Siddhi functions, for more functions refer  execution extensions  .     Inbuilt function  Description      eventTimestamp  Returns event's timestamp.    currentTimeMillis  Returns current time of SiddhiApp runtime.    default  Returns a default value if the parameter is null.    ifThenElse  Returns parameters based on a conditional parameter.    UUID  Generates a UUID.    cast  Casts parameter type.    convert  Converts parameter type.    coalesce  Returns first not null input parameter.    maximum  Returns the maximum value of all parameters.    minimum  Returns the minimum value of all parameters.    instanceOfBoolean  Checks if the parameter is an instance of Boolean.    instanceOfDouble  Checks if the parameter is an instance of Double.    instanceOfFloat  Checks if the parameter is an instance of Float.    instanceOfInteger  Checks if the parameter is an instance of Integer.    instanceOfLong  Checks if the parameter is an instance of Long.    instanceOfString  Checks if the parameter is an instance of String.    createSet  Creates  HashSet with given input parameters.    sizeOfSet  Returns number of items in the HashSet, that's passed as a parameter.     Example  Query that converts the  roomNo  to  string  using  convert  function, finds the maximum temperature reading with  maximum  function, and adds a unique  messageID  using the  UUID  function.  from   TempStream  select   convert ( roomNo ,   string )   as   roomNo ,   maximum ( tempReading1 ,   tempReading2 )   as   temp ,   UUID ()   as   messageID  insert   into   RoomTempStream ;", 
            "title": "Function"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#filter", 
            "text": "Filters are included in queries to filter information from input streams based on a specified condition.  Purpose  A filter allows you to separate events that match a specific condition as the output, or for further processing.  Syntax  Filter conditions should be defined in square brackets next to the input stream name as shown below.  from   input   stream [ filter   condition ]  select   attribute   name ,   attribute   name ,   ...  insert   into   output   stream   Example  This query filters all server rooms of which the room number is within the range of 100-210, and having temperature greater than 40 degrees\nfrom the  TempStream  stream, and inserts the results into the  HighTempStream  stream.  from   TempStream [( roomNo   =   100   and   roomNo     210 )   and   temp     40 ]  select   roomNo ,   temp  insert   into   HighTempStream ;", 
            "title": "Filter"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#window", 
            "text": "Windows allow you to capture a subset of events based on a specific criterion from an input stream for calculation.\nEach input stream can only have a maximum of one window.  Purpose  To create subsets of events within a stream based on time duration, number of events, etc for processing.\nA window can operate in a sliding or tumbling (batch) manner.  Syntax  The  #window  prefix should be inserted next to the relevant stream in order to use a window.  from   input   stream # window . window   name ( parameter ,   parameter ,   ...   )  select   attribute   name ,   attribute   name ,   ...  insert   event   type   into   output   stream    Note  Filter condition can be applied both before and/or after the window   Example  If you want to identify the maximum temperature out of the last 10 events, you need to define a  length  window of 10 events.\n This window operates in a sliding mode where the following 3 subsets are calculated when a list of 12 events are received in a sequential order.     Subset  Event Range      1  1-10    2  2-11    3  3-12     The following query finds the maximum temperature out of  last 10 events  from the  TempStream  stream,\nand inserts the results into the  MaxTempStream  stream.  from   TempStream # window . length ( 10 )  select   max ( temp )   as   maxTemp  insert   into   MaxTempStream ;   If you define the maximum temperature reading out of every 10 events, you need to define a  lengthBatch  window of 10 events.\nThis window operates as a batch/tumbling mode where the following 3 subsets are calculated when a list of 30 events are received in a sequential order.     Subset  Event Range      1  1-10    2  11-20    3  21-30     The following query finds the maximum temperature out of  every 10 events  from the  TempStream  stream,\nand inserts the results into the  MaxTempStream  stream.  from   TempStream # window . lengthBatch ( 10 )  select   max ( temp )   as   maxTemp  insert   into   MaxTempStream ;    Note  Similar operations can be done based on time via  time  windows and  timeBatch  windows and for others.\nCode segments such as  #window.time(10 min)  considers events that arrive during the last 10 minutes in a sliding manner, and the  #window.timeBatch(2 min)  considers events that arrive every 2 minutes in a tumbling manner.   Following are some inbuilt windows shipped with Siddhi. For more window types, see execution  extensions .   time  timeBatch  batch  timeLength  length  lengthBatch  sort  frequent  lossyFrequent  session  cron  externalTime  externalTimeBatch  delay   Output event types  Projection of the query depends on the output event types such as,  current  and  expired  event types.\n By default all queries produce  current  events and only queries with windows produce  expired  events\n when events expire from the window. You can specify whether the output of a query should be only current events, only expired events or both current and expired events.  Note!  Controlling the output event types does not alter the execution within the query, and it does not affect the accuracy of the query execution.    The following keywords can be used with the output stream to manipulate output.     Output event types  Description      current events  Outputs events when incoming events arrive to be processed by the query.   This is default when no specific output event type is specified.    expired events  Outputs events when events expires from the window.    all events  Outputs events when incoming events arrive to be processed by the query as well as   when events expire from the window.     The output event type keyword can be used between  insert  and  into  as shown in the following example.  Example  This query delays all events in a stream by 1 minute.    from   TempStream # window . time ( 1   min )  select   *  insert   expired   events   into   DelayedTempStream", 
            "title": "Window"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#aggregate-function", 
            "text": "Aggregate functions perform aggregate calculations in the query.\nWhen a window is defined the aggregation is restricted within that window. If no window is provided aggregation is performed from the start of the Siddhi application.  Syntax  from   input   stream # window . window   name ( parameter ,   parameter ,   ...   )  select   aggregate   function ( parameter ,   parameter ,   ...   )   as   attribute   name ,   attribute2   name ,   ...  insert   into   output   stream ;   Aggregate Parameters  Aggregate parameters can be attributes, constant values, results of other functions or aggregates, results of mathematical or logical expressions, or time parameters.\nAggregate parameters configured in a query  depends on the aggregate function being called.  Example  The following query calculates the average value for the  temp  attribute of the  TempStream  stream. This calculation is done for the last 10 minutes in a sliding manner, and the result is output as  avgTemp  to the  AvgTempStream  output stream.  from   TempStream # window . time ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo ,   deviceID  insert   into   AvgTempStream ;   Following are some inbuilt aggregation functions shipped with Siddhi, for more aggregation functions, see execution  extensions .   avg  sum  max  min  count  distinctCount  maxForever  minForever  stdDev", 
            "title": "Aggregate function"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#group-by", 
            "text": "Group By allows you to group the aggregate based on specified attributes.  Syntax \nThe syntax for the Group By aggregate function is as follows:  from   input   stream # window . window   name (...)  select   aggregate   function (   parameter ,   parameter ,   ...)   as   attribute1   name ,   attribute2   name ,   ...  group   by   attribute1   name ,   attribute2   name   ...  insert   into   output   stream ;   Example \nThe following query calculates the average temperature per  roomNo  and  deviceID  combination, for events that arrive at the  TempStream  stream\nfor a sliding time window of 10 minutes.  from   TempStream # window . time ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo ,   deviceID  group   by   roomNo ,   deviceID  insert   into   AvgTempStream ;", 
            "title": "Group By"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#having", 
            "text": "Having allows you to filter events after processing the  select  statement.  Purpose \nThis allows you to filter the aggregation output.  Syntax \nThe syntax for the Having clause is as follows:  from   input   stream # window . window   name (   ...   )  select   aggregate   function (   parameter ,   parameter ,   ...)   as   attribute1   name ,   attribute2   name ,   ...  group   by   attribute1   name ,   attribute2   name   ...  having   condition  insert   into   output   stream ;   Example  The following query calculates the average temperature per room for the last 10 minutes, and alerts if it exceeds 30 degrees.  from   TempStream # window . time ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo  group   by   roomNo  having   avgTemp     30  insert   into   AlertStream ;", 
            "title": "Having"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#order-by", 
            "text": "Order By allows you to order the aggregated result in ascending and/or descending order based on specified attributes. By default ordering will be done in\nascending manner. User can use 'desc' keyword to order in descending manner.  Syntax \nThe syntax for the Order By clause is as follows:  from   input   stream # window . window   name (   ...   )  select   aggregate   function (   parameter ,   parameter ,   ...)   as   attribute1   name ,   attribute2   name ,   ...  group   by   attribute1   name ,   attribute2   name   ...  having   condition  order   by   attribute1   name   ( asc   |   desc ) ? ,   attribute2   name   ( ascend / descend ) ? ,   ...  insert   into   output   stream ;   Example  The following query calculates the average temperature per  roomNo  and  deviceID  combination for every 10 minutes, and generate output events\nby ordering them in the ascending order of the room's avgTemp and then by the descending order of roomNo.  from   TempStream # window . timeBatch ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo ,   deviceID  group   by   roomNo ,   deviceID  order   by   avgTemp ,   roomNo   desc  insert   into   AvgTempStream ;", 
            "title": "Order By"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#limit-offset", 
            "text": "When events are emitted as a batch, offset allows you to offset beginning of the output event batch and limit allows you to limit the number of events in the batch from the defined offset.\nWith this users can specify which set of events need be emitted.  Syntax \nThe syntax for the Limit   Offset clause is as follows:  from   input   stream # window . window   name (   ...   )  select   aggregate   function (   parameter ,   parameter ,   ...)   as   attribute1   name ,   attribute2   name ,   ...  group   by   attribute1   name ,   attribute2   name   ...  having   condition  order   by   attribute1   name   ( asc   |   desc ) ? ,   attribute2   name   ( ascend / descend ) ? ,   ...  limit   positive   interger ?  offset   positive   interger ?  insert   into   output   stream ;   Here both  limit  and  offset  are optional where  limit  by default output all the events and  offset  by default set to  0 .  Example \nThe following query calculates the average temperature per  roomNo  and  deviceID  combination, for events that arrive at the  TempStream  stream\nfor every 10 minutes and emits two events with highest average temperature.  from   TempStream # window . timeBatch ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo ,   deviceID  group   by   roomNo ,   deviceID  order   by   avgTemp   desc  limit   2  insert   into   HighestAvgTempStream ;   The following query calculates the average temperature per  roomNo  and  deviceID  combination, for events that arrive at the  TempStream  stream\nfor every 10 minutes and emits third, forth and fifth events when sorted in descending order based on their average temperature.  from   TempStream # window . timeBatch ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo ,   deviceID  group   by   roomNo ,   deviceID  order   by   avgTemp   desc  limit   3  offset   2  insert   into   HighestAvgTempStream ;", 
            "title": "Limit &amp; Offset"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#join-stream", 
            "text": "Joins allow you to get a combined result from two streams in real-time based on a specified condition.  Purpose \nStreams are stateless. Therefore, in order to join two streams, they need to be connected to a window so that there is a pool of events that can be used for joining. Joins also accept conditions to join the appropriate events from each stream.  During the joining process each incoming event of each stream is matched against all the events in the other\nstream's window based on the given condition, and the output events are generated for all the matching event pairs.   Note  Join can also be performed with  stored data ,  aggregation  or externally  defined windows .   Syntax  The syntax for a join is as follows:  from   input   stream # window . window   name ( parameter ,   ...   )   { unidirectional }   { as   reference } \n          join   input   stream # window . window   name ( parameter ,    ...   )   { unidirectional }   { as   reference } \n     on   join   condition  select   attribute   name ,   attribute   name ,   ...  insert   into   output   stream   Here, the  join condition  allows you to match the attributes from both the streams.  Unidirectional join operation  By default, events arriving at either stream can trigger the joining process. However, if you want to control the\njoin execution, you can add the  unidirectional  keyword next to a stream in the join definition as depicted in the\nsyntax in order to enable that stream to trigger the join operation. Here, events arriving at other stream only update the\n window of that stream, and this stream does not trigger the join operation.   Note  The  unidirectional  keyword cannot be applied to both the input streams because the default behaviour already allows both streams to trigger the join operation.   Example  Assuming that the temperature of regulators are updated every minute.\nFollowing is a Siddhi App that controls the temperature regulators if they are not already  on  for all the rooms with a room temperature greater than 30 degrees.    define   stream   TempStream ( deviceID   long ,   roomNo   int ,   temp   double );  define   stream   RegulatorStream ( deviceID   long ,   roomNo   int ,   isOn   bool );  from   TempStream [ temp     30 . 0 ] # window . time ( 1   min )   as   T \n   join   RegulatorStream [ isOn   ==   false ] # window . length ( 1 )   as   R \n   on   T . roomNo   ==   R . roomNo  select   T . roomNo ,   R . deviceID ,   start   as   action  insert   into   RegulatorActionStream ;   Supported join types  Following are the supported operations of a join clause.    Inner join (join)  This is the default behaviour of a join operation.  join  is used as the keyword to join both the streams. The output is generated only if there is a matching event in both the streams.    Left outer join  The  left outer join  operation allows you to join two streams to be merged based on a condition.  left outer join  is used as the keyword to join both the streams.  Here, it returns all the events of left stream even if there are no matching events in the right stream by\nhaving null values for the attributes of the right stream.  Example  The following query generates output events for all events from the  StockStream  stream regardless of whether a matching\nsymbol exists in the  TwitterStream  stream or not.  \nfrom StockStream#window.time(1 min) as S\n  left outer join TwitterStream#window.length(1) as T\n  on S.symbol== T.symbol\nselect S.symbol as symbol, T.tweet, S.price\ninsert into outputStream ;        Right outer join  This is similar to a left outer join.  Right outer join  is used as the keyword to join both the streams.\nIt returns all the events of the right stream even if there are no matching events in the left stream.    Full outer join  The full outer join combines the results of left outer join and right outer join.  full outer join  is used as the keyword to join both the streams.\nHere, output event are generated for each incoming event even if there are no matching events in the other stream.  Example  The following query generates output events for all the incoming events of each stream regardless of whether there is a\nmatch for the  symbol  attribute in the other stream or not.  \nfrom StockStream#window.time(1 min) as S\n  full outer join TwitterStream#window.length(1) as T\n  on S.symbol== T.symbol\nselect S.symbol as symbol, T.tweet, S.price\ninsert into outputStream ;", 
            "title": "Join (Stream)"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#pattern", 
            "text": "This is a state machine implementation that allows you to detect patterns in the events that arrive over time. This can correlate events within a single stream or between multiple streams.  Purpose  Patterns allow you to identify trends in events over a time period.  Syntax  The following is the syntax for a pattern query:  from   ( every ) ?   event   reference = input   stream [ filter   condition ]   - \n     ( every ) ?   event   reference = input   stream   [ filter   condition ]   - \n     ... \n     ( within   time   gap ) ?       select   event   reference . attribute   name ,   event   reference . attribute   name ,   ...  insert   into   output   stream      Items  Description      -  This is used to indicate an event that should be following another event. The subsequent event does not necessarily have to occur immediately after the preceding event. The condition to be met by the preceding event should be added before the sign, and the condition to be met by the subsequent event should be added after the sign.    event reference  This allows you to add a reference to the the matching event so that it can be accessed later for further processing.    (within  time gap )?  The  within  clause is optional. It defines the time duration within which all the matching events should occur.    every  every  is an optional keyword. This defines whether the event matching should be triggered for every event arrival in the specified stream with the matching condition.   When this keyword is not used, the matching is carried out only once.     Siddhi also supports pattern matching with counting events and matching events in a logical order such as ( and ,  or , and  not ). These are described in detail further below in this guide.  Example  This query sends an alert if the temperature of a room increases by 5 degrees within 10 min.  from   every (   e1 = TempStream   )   -   e2 = TempStream [   e1 . roomNo   ==   roomNo   and   ( e1 . temp   +   5 )   =   temp   ] \n     within   10   min  select   e1 . roomNo ,   e1 . temp   as   initialTemp ,   e2 . temp   as   finalTemp  insert   into   AlertStream ;   Here, the matching process begins for each event in the  TempStream  stream (because  every  is used with  e1=TempStream ),\nand if  another event arrives within 10 minutes with a value for the  temp  attribute that is greater than or equal to  e1.temp + 5 \nof the event e1, an output is generated via the  AlertStream .", 
            "title": "Pattern"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#counting-pattern", 
            "text": "Counting patterns allow you to match multiple events that may have been received for the same matching condition.\nThe number of events matched per condition can be limited via condition postfixes.  Syntax  Each matching condition can contain a collection of events with the minimum and maximum number of events to be matched as shown in the syntax below.  from   ( every ) ?   event   reference = input   stream [ filter   condition ]   ( min   count : max   count ) ?   -   \n     ... \n     ( within   time   gap ) ?       select   event   reference ([ event   index ]) ? . attribute   name ,   ...  insert   into   output   stream      Postfix  Description  Example      n1:n2  This matches  n1  to  n2  events (including  n1  and not more than  n2 ).  1:4  matches 1 to 4 events.    n:  This matches  n  or more events (including  n ).  2:  matches 2 or more events.    :n  This matches up to  n  events (excluding  n ).  :5  matches up to 5 events.    n  This matches exactly  n  events.  5  matches exactly 5 events.     Specific occurrences of the event in a collection can be retrieved by using an event index with its reference.\nSquare brackets can be used to indicate the event index where  1  can be used as the index of the first event and  last  can be used as the index\n for the  last  available event in the event collection. If you provide an index greater then the last event index,\n the system returns  null . The following are some valid examples.   e1[3]  refers to the 3rd event.  e1[last]  refers to the last event.  e1[last - 1]  refers to the event before the last event.   Example  The following Siddhi App calculates the temperature difference between two regulator events.  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  define   stream   RegulatorStream   ( deviceID   long ,   roomNo   int ,   tempSet   double ,   isOn   bool );  from   every (   e1 = RegulatorStream )   -   e2 = TempStream [ e1 . roomNo == roomNo ] 1 :   -   e3 = RegulatorStream [ e1 . roomNo == roomNo ]  select   e1 . roomNo ,   e2 [ 0 ]. temp   -   e2 [ last ]. temp   as   tempDiff  insert   into   TempDiffStream ;", 
            "title": "Counting Pattern"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#logical-patterns", 
            "text": "Logical patterns match events that arrive in temporal order and correlate them with logical relationships such as  and , or  and  not .  Syntax  from   ( every ) ?   ( not ) ?   event   reference = input   stream [ filter   condition ] \n           (( and | or )   event   reference = input   stream [ filter   condition ]) ?   ( within   time   gap ) ?   -   \n     ...  select   event   reference ([ event   index ]) ? . attribute   name ,   ...  insert   into   output   stream   Keywords such as  and ,  or , or  not  can be used to illustrate the logical relationship.     Key Word  Description      and  This allows both conditions of  and  to be matched by two events in any order.    or  The state succeeds if either condition of  or  is satisfied. Here the event reference of the other condition is  null .    not  condition1  and  condition2  When  not  is included with  and , it identifies the events that match   arriving before any event that match  .    not  condition  for  time period  When  not  is included with  for , it allows you to identify a situation where no event that matches  condition1  arrives during the specified  time period .  e.g., from not TemperatureStream[temp   60] for 5 sec .     Here the  not  pattern can be followed by either an  and  clause or the effective period of  not  can be concluded after a given  time period . Further in Siddhi more than two streams cannot be matched with logical conditions using  and ,  or , or  not  clauses at this point.", 
            "title": "Logical Patterns"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#detecting-non-occurring-events", 
            "text": "Siddhi allows you to detect non-occurring events via multiple combinations of the key words specified above as shown in the table below.  In the patterns listed, P* can be either a regular event pattern, an absent event pattern or a logical pattern.     Pattern  Detected Scenario      not A for  time period  The non-occurrence of event A within  time period  after system start up.  e.g., Generating an alert if a taxi has not reached its destination within 30 minutes, to indicate that the passenger might be in danger.    not A for  time period  and B  After system start up, event A does not occur within  time period , but event B occurs at some point in time.   e.g., Generating an alert if a taxi has not reached its destination within 30 minutes, and the passenger marked that he/she is in danger at some point in time.    not A for  time period 1  and not B for  time period 2  After system start up, event A doess not occur within  time period 1 , and event B also does not occur within  time period 2 .   e.g., Generating an alert if the driver of a taxi has not reached the destination within 30 minutes, and the passenger has not marked himself/herself to be in danger within that same time period.    not A for  time period  or B  After system start up, either event A does not occur within  time period , or event B occurs at some point in time.   e.g., Generating an alert if the taxi has not reached its destination within 30 minutes, or if the passenger has marked that he/she is in danger at some point in time.    not A for  time period 1  or not B for  time period 2  After system start up, either event A does not occur within  time period 1 , or event B occurs within  time period 2 .   e.g., Generating an alert to indicate that the driver is not on an expected route if the taxi has not reached destination A within 20 minutes, or reached destination B within 30 minutes.    A \u2192 not B for  time period  Event B does not occur within  time period  after the occurrence of event A. e.g., Generating an alert if the taxi has reached its destination, but this was not followed by a payment record.    P* \u2192 not A for  time period  and B  After the occurrence of P*, event A does not occur within  time period , and event B occurs at some point in time.     P* \u2192 not A for  time period 1  and not B for  time period 2  After the occurrence of P*, event A does not occur within  time period 1 , and event B does not occur within  time period 2 .    P* \u2192 not A for  time period  or B  After the occurrence of P*, either event A does not occur within  time period , or event B occurs at some point in time.    P* \u2192 not A for  time period 1  or not B for  time period 2  After the occurrence of P*, either event A does not occur within  time period 1 , or event B does not occur within  time period 2 .    not A for  time period  \u2192 B  Event A does occur within  time period  after the system start up, but event B occurs after that  time period  has elapsed.    not A for  time period  and B \u2192 P*  Event A does not occur within  time period , and event B occurs at some point in time. Then P* occurs after the  time period  has elapsed, and after B has occurred.    not A for  time period 1  and not B for  time period 2  \u2192 P*  After system start up, event A does not occur within  time period 1 , and event B does not occur within  time period 2 . However, P* occurs after both A and B.    not A for  time period  or B \u2192 P*  After system start up, event A does not occur within  time period  or event B occurs at some point in time. The P* occurs after  time period  has elapsed, or after B has occurred.    not A for  time period 1  or not B for  time period 2  \u2192 P*  After system start up, either event A does not occur within  time period 1 , or event B does not occur within  time period 2 . Then P*  occurs after both  time period 1  and  time period 2  have elapsed.    not A and B  Event A does not occur before event B.    A and not B  Event B does not occur before event A.     Example  Following Siddhi App, sends the  stop  control action to the regulator when the key is removed from the hotel room.  define   stream   RegulatorStateChangeStream ( deviceID   long ,   roomNo   int ,   tempSet   double ,   action   string );  define   stream   RoomKeyStream ( deviceID   long ,   roomNo   int ,   action   string );  from   every (   e1 = RegulatorStateChangeStream [   action   ==   on   ]   )   - \n       e2 = RoomKeyStream [   e1 . roomNo   ==   roomNo   and   action   ==   removed   ]   or   e3 = RegulatorStateChangeStream [   e1 . roomNo   ==   roomNo   and   action   ==   off ]  select   e1 . roomNo ,   ifThenElse (   e2   is   null ,   none ,   stop   )   as   action  having   action   !=   none  insert   into   RegulatorActionStream ;   This Siddhi Application generates an alert if we have switch off the regulator before the temperature reaches 12 degrees.    define   stream   RegulatorStateChangeStream ( deviceID   long ,   roomNo   int ,   tempSet   double ,   action   string );  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  from   e1 = RegulatorStateChangeStream [ action   ==   start ]   -   not   TempStream [ e1 . roomNo   ==   roomNo   and   temp     12 ]   and   e2 = RegulatorStateChangeStream [ action   ==   off ]  select   e1 . roomNo   as   roomNo  insert   into   AlertStream ;   This Siddhi Application generates an alert if the temperature does not reduce to 12 degrees within 5 minutes of switching on the regulator.    define   stream   RegulatorStateChangeStream ( deviceID   long ,   roomNo   int ,   tempSet   double ,   action   string );  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  from   e1 = RegulatorStateChangeStream [ action   ==   start ]   -   not   TempStream [ e1 . roomNo   ==   roomNo   and   temp     12 ]   for   5 min  select   e1 . roomNo   as   roomNo  insert   into   AlertStream ;", 
            "title": "Detecting Non-occurring Events"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#sequence", 
            "text": "Sequence is a state machine implementation that allows you to detect the sequence of event occurrences over time.\nHere  all matching events need to arrive consecutively  to match the sequence condition, and there cannot be any non-matching events arriving within a matching sequence of events.\nThis can correlate events within a single stream or between multiple streams.  Purpose  This allows you to detect a specified event sequence over a specified time period.  Syntax  The syntax for a sequence query is as follows:  from   ( every ) ?   event   reference = input   stream [ filter   condition ], \n     event   reference = input   stream   [ filter   condition ], \n     ... \n     ( within   time   gap ) ?       select   event   reference . attribute   name ,   event   reference . attribute   name ,   ...  insert   into   output   stream      Items  Description      ,  This represents the immediate next event i.e., when an event that matches the first condition arrives, the event that arrives immediately after it should match the second condition.    event reference  This allows you to add a reference to the the matching event so that it can be accessed later for further processing.    (within  time gap )?  The  within  clause is optional. It defines the time duration within which all the matching events should occur.    every  every  is an optional keyword. This defines whether the matching event should be triggered for every event that arrives at the specified stream with the matching condition.   When this keyword is not used, the matching is carried out only once.     Example  This query generates an alert if the increase in the temperature between two consecutive temperature events exceeds one degree.  from   every   e1 = TempStream ,   e2 = TempStream [ e1 . temp   +   1     temp ]  select   e1 . temp   as   initialTemp ,   e2 . temp   as   finalTemp  insert   into   AlertStream ;   Counting Sequence  Counting sequences allow you to match multiple events for the same matching condition.\nThe number of events matched per condition can be limited via condition postfixes such as  Counting Patterns , or by using the * ,  + , and  ?  operators.  The matching events can also be retrieved using event indexes, similar to how it is done in  Counting Patterns .  Syntax  Each matching condition in a sequence can contain a collection of events as shown below.  from   ( every ) ?   event   reference = input   stream [ filter   condition ]( +|*|? ) ? , \n     event   reference = input   stream   [ filter   condition ]( +|*|? ) ? , \n     ... \n     ( within   time   gap ) ?       select   event   reference . attribute   name ,   event   reference . attribute   name ,   ...  insert   into   output   stream      Postfix symbol  Required/Optional  Description      +  Optional  This matches  one or more  events to the given condition.    *  Optional  This matches  zero or more  events to the given condition.    ?  Optional  This matches  zero or one  events to the given condition.     Example  This Siddhi application identifies temperature peeks.  define   stream   TempStream ( deviceID   long ,   roomNo   int ,   temp   double );  from   every   e1 = TempStream ,   e2 = TempStream [ e1 . temp   =   temp ] + ,   e3 = TempStream [ e2 [ last ]. temp     temp ]  select   e1 . temp   as   initialTemp ,   e2 [ last ]. temp   as   peakTemp  insert   into   PeekTempStream ;   Logical Sequence  Logical sequences identify logical relationships using  and ,  or  and  not  on consecutively arriving events.  Syntax \nThe syntax for a logical sequence is as follows:  from   ( every ) ?   ( not ) ?   event   reference = input   stream [ filter   condition ] \n           (( and | or )   event   reference = input   stream [ filter   condition ]) ?   ( within   time   gap ) ? , \n     ...  select   event   reference ([ event   index ]) ? . attribute   name ,   ...  insert   into   output   stream   Keywords such as  and ,  or , or  not  can be used to illustrate the logical relationship, similar to how it is done in  Logical Patterns .  Example  This Siddhi application notifies the state when a regulator event is immediately followed by both temperature and humidity events.  define   stream   TempStream ( deviceID   long ,   temp   double );  define   stream   HumidStream ( deviceID   long ,   humid   double );  define   stream   RegulatorStream ( deviceID   long ,   isOn   bool );  from   every   e1 = RegulatorStream ,   e2 = TempStream   and   e3 = HumidStream  select   e2 . temp ,   e3 . humid  insert   into   StateNotificationStream ;", 
            "title": "Sequence"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#output-rate-limiting", 
            "text": "Output rate limiting allows queries to output events periodically based on a specified condition.  Purpose  This allows you to limit the output to avoid overloading the subsequent executions, and to remove unnecessary information.  Syntax  The syntax of an output rate limiting configuration is as follows:  from   input   stream   ...  select   attribute   name ,   attribute   name ,   ...  output   rate   limiting   configuration  insert   into   output   stream   Siddhi supports three types of output rate limiting configurations as explained in the following table:     Rate limiting configuration  Syntax  Description      Based on time  output event  every  time interval  This outputs  output event  every  time interval  time interval.    Based on number of events  output event  every  event interval  events  This outputs  output event  for every  event interval  number of events.    Snapshot based output  snapshot every  time interval  This outputs all events in the window (or the last event if no window is defined in the query) for every given  time interval  time interval.     Here the  output event  specifies the event(s) that should be returned as the output of the query.\nThe possible values are as follows:   first  : Only the first event processed by the query during the specified time interval/sliding window is emitted.   last  : Only the last event processed by the query during the specified time interval/sliding window is emitted.\n*  all  : All the events processed by the query during the specified time interval/sliding window are emitted.  When no  output event  is defined,  all  is used by default.  Examples    Returning events based on the number of events  Here, events are emitted every time the specified number of events arrive. You can also specify whether to emit only the first event/last event, or all the events out of the events that arrived.  In this example, the last temperature per sensor is emitted for every 10 events.  \nfrom TempStreamselect\nselect temp, deviceID\ngroup by deviceID\noutput last every 10 events\ninsert into LowRateTempStream;        Returning events based on time  Here events are emitted for every predefined time interval. You can also specify whether to emit only the first event, last event, or all events out of the events that arrived during the specified time interval.  In this example, emits all temperature events every 10 seconds    \nfrom TempStreamoutput\noutput every 10 sec\ninsert into LowRateTempStream;        Returning a periodic snapshot of events  This method works best with windows. When an input stream is connected to a window, snapshot rate limiting emits all the current events that have arrived and do not have corresponding expired events for every predefined time interval.\nIf the input stream is not connected to a window, only the last current event for each predefined time interval is emitted.  This query emits a snapshot of the events in a time window of 5 seconds every 1 second.  \nfrom TempStream#window.time(5 sec)\noutput snapshot every 1 sec\ninsert into SnapshotTempStream;", 
            "title": "Output rate limiting"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#partition", 
            "text": "Partitions divide streams and queries into isolated groups in  order to process them in parallel and in isolation.\nA partition can contain one or more queries and there can be multiple instances where the same queries and streams are replicated for each partition.\nEach partition is tagged with a partition key. Those partitions only process the events that match the corresponding partition key.  Purpose  Partitions allow you to process the events groups in isolation so that event processing can be performed using the same set of queries for each group.  Partition key generation  A partition key can be generated in the following two methods:    Partition by value  This is created by generating unique values using input stream attributes.  Syntax  \npartition with (  expression  of  stream name ,  expression  of  stream name , ... )\nbegin\n     query \n     query \n    ...\nend;   Example  This query calculates the maximum temperature recorded within the last 10 events per  deviceID .  \npartition with ( deviceID of TempStream )\nbegin\n    from TempStream#window.length(10)\n    select roomNo, deviceID, max(temp) as maxTemp\n    insert into DeviceTempStream;\nend;    Partition by range  This is created by mapping each partition key to a range condition of the input streams numerical attribute.  Syntax  \npartition with (  condition  as  partition key  or  condition  as  partition key  or ... of  stream name , ... )\nbegin\n     query \n     query \n    ...\nend;  Example  This query calculates the average temperature for the last 10 minutes per office area.  \npartition with ( roomNo  = 1030 as 'serverRoom' or\n                 roomNo   1030 and roomNo  = 330 as 'officeRoom' or\n                 roomNo   330 as 'lobby' of TempStream)\nbegin\n    from TempStream#window.time(10 min)\n    select roomNo, deviceID, avg(temp) as avgTemp\n    insert into AreaTempStream\nend;", 
            "title": "Partition"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#inner-stream", 
            "text": "Queries inside a partition block can use inner streams to communicate with each other while preserving partition isolation.\nInner streams are denoted by a \"#\" placed before the stream name, and these streams cannot be accessed outside a partition block.  Purpose  Inner streams allow you to connect queries within the partition block so that the output of a query can be used as an input only by another query\nwithin the same partition. Therefore, you do not need to repartition the streams if they are communicating within the partition.  Example  This partition calculates the average temperature of every 10 events for each sensor, and sends an output to the  DeviceTempIncreasingStream  stream if the consecutive average temperature values increase by more than\n5 degrees.  \npartition with ( deviceID of TempStream )\nbegin\n    from TempStream#window.lengthBatch(10)\n    select roomNo, deviceID, avg(temp) as avgTemp\n    insert into #AvgTempStream\n\n    from every (e1=#AvgTempStream),e2=#AvgTempStream[e1.avgTemp + 5  <  avgTemp]\n    select e1.deviceID, e1.avgTemp as initialAvgTemp, e2.avgTemp as finalAvgTemp\n    insert into DeviceTempIncreasingStream\nend;", 
            "title": "Inner Stream"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#table", 
            "text": "A table is a stored version of an stream or a table of events. Its schema is defined via the  table definition  that is\nsimilar to a stream definition. These events are by default stored  in-memory , but Siddhi also provides store extensions to work with data/events stored in various data stores through the\ntable abstraction.  Purpose  Tables allow Siddhi to work with stored events. By defining a schema for tables Siddhi enables them to be processed by queries using their defined attributes with the streaming data. You can also interactively query the state of the stored events in the table.  Syntax  The syntax for a new table definition is as follows:  define   table   table   name   ( attribute   name   attribute   type ,   attribute   name   attribute   type ,   ...   );   The following parameters are configured in a table definition:     Parameter  Description      table name  The name of the table defined. ( PascalCase  is used for table name as a convention.)    attribute name  The schema of the table is defined by its attributes with uniquely identifiable attribute names ( camelCase  is used for attribute names as a convention.)    attribute type  The type of each attribute defined in the schema.   This can be  STRING ,  INT ,  LONG ,  DOUBLE ,  FLOAT ,  BOOL  or  OBJECT .     Example  The following defines a table named  RoomTypeTable  with  roomNo  and  type  attributes of data types  int  and  string  respectively.  define   table   RoomTypeTable   (   roomNo   int ,   type   string   );   Primary Keys  Tables can be configured with primary keys to avoid the duplication of data.  Primary keys are configured by including the  @PrimaryKey( 'key1', 'key2' )  annotation to the table definition.\nEach event table configuration can have only one  @PrimaryKey  annotation.\nThe number of attributes supported differ based on the table implementations. When more than one attribute\n is used for the primary key, the uniqueness of the events stored in the table is determined based on the combination of values for those attributes.  Examples  This query creates an event table with the  symbol  attribute as the primary key.\nTherefore each entry in this table must have a unique value for  symbol  attribute.  @ PrimaryKey ( symbol )  define   table   StockTable   ( symbol   string ,   price   float ,   volume   long );   Indexes  Indexes allow tables to be searched/modified much faster.  Indexes are configured by including the  @Index( 'key1', 'key2' )  annotation to the table definition.\n Each event table configuration can have 0-1  @Index  annotations.\n Support for the  @Index  annotation and the number of attributes supported differ based on the table implementations.\n When more then one attribute is used for index, each one of them is used to index the table for fast access of the data.\n Indexes can be configured together with primary keys.  Examples  This query creates an indexed event table named  RoomTypeTable  with the  roomNo  attribute as the index key.  @ Index ( roomNo )  define   table   RoomTypeTable   ( roomNo   int ,   type   string );", 
            "title": "Table"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#store", 
            "text": "Store is a table that refers to data/events stored in data stores outside of Siddhi such as RDBMS, Cassandra, etc.\nStore is defined via the  @store  annotation, and the store schema is defined via a  table definition  associated with it.  Purpose  Store allows Siddhi to search, retrieve and manipulate data stored in external data stores through Siddhi queries.  Syntax  The syntax for a defining store and it's associated table definition is as follows:  @ store ( type = store_type ,   static . option . key1 = static_option_value1 ,   static . option . keyN = static_option_valueN )  define   table   TableName   ( attribute1   Type1 ,   attributeN   TypeN );   Example  The following defines a RDBMS data store pointing to a MySQL database with name  hotel  hosted in  loacalhost:3306 \nhaving a table  RoomTypeTable  with columns  roomNo  of  INTEGER  and  type  of  VARCHAR(255)  mapped to Siddhi data types  int  and  string  respectively.  @ Store ( type = rdbms ,   jdbc . url = jdbc:mysql://localhost:3306/hotel ,   username = siddhi ,   password = 123 , \n        jdbc . driver . name = com.mysql.jdbc.Driver )  define   table   RoomTypeTable   (   roomNo   int ,   type   string   );   Supported Store Types  The following is a list of currently supported store types:   RDBMS (MySQL, Oracle, SQL Server, PostgreSQL, DB2, H2)  Solr  MongoDB  HBase  Redis  Cassandra   Operators on Table (and Store)  The following operators can be performed on tables (and stores).", 
            "title": "Store"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#insert", 
            "text": "This allows events to be inserted into tables. This is similar to inserting events into streams.   Warning  If the table is defined with primary keys, and if you insert duplicate data, primary key constrain violations can occur.\nIn such cases use the  update or insert into  operation.   Syntax  from   input   stream  select   attribute   name ,   attribute   name ,   ...  insert   into   table   Similar to streams, you need to use the  current events ,  expired events  or the  all events  keyword between  insert  and  into  keywords in order to insert only the specific output event types.\nFor more information, see  output event type  Example  This query inserts all the events from the  TempStream  stream to the  TempTable  table.  from   TempStream  select   *  insert   into   TempTable ;", 
            "title": "Insert"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#join-table", 
            "text": "This allows a stream to retrieve information from a table in a streaming manner.   Note  Joins can also be performed with  two streams ,  aggregation  or against externally  defined windows .   Syntax  from   input   stream   join   table \n     on   condition  select   ( input   stream | table ). attribute   name ,   ( input   stream | table ). attribute   name ,   ...  insert   into   output   stream    Note  A table can only be joint with a stream. Two tables cannot be joint because there must be at least one active\nentity to trigger the join operation.   Example  This Siddhi App performs a join to retrieve the room type from  RoomTypeTable  table based on the room number, so that it can filter the events related to  server-room s.  define   table   RoomTypeTable   ( roomNo   int ,   type   string );  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  from   TempStream   join   RoomTypeTable \n     on   RoomTypeTable . roomNo   ==   TempStream . roomNo  select   deviceID ,   RoomTypeTable . type   as   roomType ,   type ,   temp \n     having   roomType   ==   server-room  insert   into   ServerRoomTempStream ;   Supported join types  Table join supports following join operations.    Inner join (join)  This is the default behaviour of a join operation.  join  is used as the keyword to join the stream with the table. The output is generated only if there is a matching event in both the stream and the table.    Left outer join  The  left outer join  operation allows you to join a stream on left side with a table on the right side based on a condition.\nHere, it returns all the events of left stream even if there are no matching events in the right table by\nhaving null values for the attributes of the right table.    Right outer join  This is similar to a  left outer join .  right outer join  is used as the keyword to join a stream on right side with a table on the left side based on a condition.\nIt returns all the events of the right stream even if there are no matching events in the left table.", 
            "title": "Join (Table)"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#delete", 
            "text": "To delete selected events that are stored in a table.  Syntax  from   input   stream  select   attribute   name ,   attribute   name ,   ...  delete   table   ( for   output   event   type ) ? \n     on   condition   The  condition  element specifies the basis on which events are selected to be deleted.\nWhen specifying the condition, table attributes should be referred to with the table name.  To execute delete for specific output event types, use the  current events ,  expired events  or the  all events  keyword with  for  as shown\nin the syntax. For more information, see  output event type   Note  Table attributes must be always referred to with the table name as follows: table name . attibute name   Example  In this example, the script deletes a record in the  RoomTypeTable  table if it has a value for the  roomNo  attribute that matches the value for the  roomNumber  attribute of an event in the  DeleteStream  stream.  define   table   RoomTypeTable   ( roomNo   int ,   type   string );  define   stream   DeleteStream   ( roomNumber   int );  from   DeleteStream  delete   RoomTypeTable \n     on   RoomTypeTable . roomNo   ==   roomNumber ;", 
            "title": "Delete"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#update", 
            "text": "This operator updates selected event attributes stored in a table based on a condition.  Syntax  from   input   stream  select   attribute   name ,   attribute   name ,   ...  update   table   ( for   output   event   type ) ? \n     set   table . attribute   name   =   ( attribute   name | expression ) ? ,   table . attribute   name   =   ( attribute   name | expression ) ? ,   ... \n     on   condition   The  condition  element specifies the basis on which events are selected to be updated.\nWhen specifying the  condition , table attributes must be referred to with the table name.  You can use the  set  keyword to update selected attributes from the table. Here, for each assignment, the attribute specified in the left must be the table attribute, and the one specified in the right can be a stream/table attribute a mathematical operation, or other. When the  set  clause is not provided, all the attributes in the table are updated.  To execute an update for specific output event types use the  current events ,  expired events  or the  all events  keyword with  for  as shown\nin the syntax. For more information, see  output event type .   Note  Table attributes must be always referred to with the table name as shown below:\n  table name . attibute name .   Example  This Siddhi application updates the room occupancy in the  RoomOccupancyTable  table for each room number based on new arrivals and exits from the  UpdateStream  stream.  define   table   RoomOccupancyTable   ( roomNo   int ,   people   int );  define   stream   UpdateStream   ( roomNumber   int ,   arrival   int ,   exit   int );  from   UpdateStream  select   *  update   RoomOccupancyTable \n     set   RoomOccupancyTable . people   =   RoomOccupancyTable . people   +   arrival   -   exit \n     on   RoomOccupancyTable . roomNo   ==   roomNumber ;", 
            "title": "Update"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#update-or-insert", 
            "text": "This allows you update if the event attributes already exist in the table based on a condition, or\nelse insert the entry as a new attribute.  Syntax  from   input   stream  select   attribute   name ,   attribute   name ,   ...  update   or   insert   into   table   ( for   output   event   type ) ? \n     set   table . attribute   name   =   expression ,   table . attribute   name   =   expression ,   ... \n     on   condition   The  condition  element specifies the basis on which events are selected for update.\nWhen specifying the  condition , table attributes should be referred to with the table name.\nIf a record that matches the condition does not already exist in the table, the arriving event is inserted into the table.  The  set  clause is only used when an update is performed during the insert/update operation.\nWhen  set  clause is used, the attribute to the left is always a table attribute, and the attribute to the right can be a stream/table attribute, mathematical\noperation or other. The attribute to the left (i.e., the attribute in the event table) is updated with the value of the attribute to the right if the given condition is met. When the  set  clause is not provided, all the attributes in the table are updated.   Note  When the attribute to the right is a table attribute, the operations supported differ based on the database type.   To execute update upon specific output event types use the  current events ,  expired events  or the  all events  keyword with  for  as shown\nin the syntax. To understand more see  output event type .   Note  Table attributes should be always referred to with the table name as  table name . attibute name .   Example  The following query update for events in the  UpdateTable  event table that have room numbers that match the same in the  UpdateStream  stream. When such events are found in the event table, they are updated. When a room number available in the stream is not found in the event table, it is inserted from the stream.  define   table   RoomAssigneeTable   ( roomNo   int ,   type   string ,   assignee   string );  define   stream   RoomAssigneeStream   ( roomNumber   int ,   type   string ,   assignee   string );  from   RoomAssigneeStream  select   roomNumber   as   roomNo ,   type ,   assignee  update   or   insert   into   RoomAssigneeTable \n     set   RoomAssigneeTable . assignee   =   assignee \n     on   RoomAssigneeTable . roomNo   ==   roomNo ;", 
            "title": "Update or Insert"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#in", 
            "text": "This allows the stream to check whether the expected value exists in the table as a part of a conditional operation.  Syntax  from   input   stream [ condition   in   table ]  select   attribute   name ,   attribute   name ,   ...  insert   into   output   stream   The  condition  element specifies the basis on which events are selected to be compared.\nWhen constructing the  condition , the table attribute must be always referred to with the table name as shown below: table . attibute name .  Example  This Siddhi application filters only room numbers that are listed in the  ServerRoomTable  table.  define   table   ServerRoomTable   ( roomNo   int );  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  from   TempStream [ ServerRoomTable . roomNo   ==   roomNo   in   ServerRoomTable ]  insert   into   ServerRoomTempStream ;", 
            "title": "In"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#incremental-aggregation", 
            "text": "Incremental aggregation allows you to obtain aggregates in an incremental manner for a specified set of time periods.  This not only allows you to calculate aggregations with varied time granularity, but also allows you to access them in an interactive\n manner for reports, dashboards, and for further processing. Its schema is defined via the  aggregation definition .  Incremental aggregation granularity data holders are automatically purged every 15 minutes. When carrying out data purging, the retention period you have specified for each granularity in the incremental aggregation query is taken into account. The retention period defined for a granularity needs to be greater than or equal to its minimum retention period as specified in the table below. If no valid retention period is defined for a granularity, the default retention period (as specified in the table below) is applied.     Granularity  Default retention  Minimum retention      second  120  seconds  120  seconds    minute  24   hours  120  minutes    hour  30   days  25   hours    day  1    year  32   days    month  All  13   month    year  All  none     Purpose  Incremental aggregation allows you to retrieve the aggregate values for different time durations.\nThat is, it allows you to obtain aggregates such as  sum ,  count ,  avg ,  min ,  max ,  count  and  distinctCount \nof stream attributes for durations such as  sec ,  min ,  hour , etc.  This is of considerable importance in many Analytics scenarios because aggregate values are often needed for several time periods.\nFurthermore, this ensures that the aggregations are not lost due to unexpected system failures because aggregates can be stored in different persistence  stores .  Syntax  @ store ( type = store type ,   ...)  @ purge ( enable = true or false , interval = purging   interval , @ retentionPeriod ( granularity   =   retention   period ,   ...)   )  define   aggregation   aggregator   name  from   input   stream  select   attribute   name ,   aggregate   function ( attribute   name )   as   attribute   name ,   ... \n     group   by   attribute   name \n     aggregate   by   timestamp   attribute   every   time   periods   ;   The above syntax includes the following:     Item  Description      @BufferSize  DEPRECIATED FROM V4.2.0 . This identifies the number of expired events to retain in a buffer in order to handle out of order event processing. This is an optional parameter that is applicable only if aggregation is based on external timestamps (because events aggregated based on event arrival time cannot be out of order). Siddhi determines whether an event is expired or not based on the timestamp of the latest event and the most granular duration for which aggregation is calculated.  e.g., If the aggregation is calculated for  sec\u2026year , the most granular duration is seconds. Therefore, if the buffer size is  3  and events arrive during 51st, 52nd, 53rd and 54th seconds, all of the older aggregations (i.e., for 51st, 52nd and 53rd seconds) are kept in the buffer because the latest event arrived during the 54th second.  The default value is  0 .    @IgnoreEventsOlderThanBuffer  DEPRECIATED FROM V4.2.0 .This annotation specifies whether or not to aggregate events older than the  buffer. If this parameter is set to  false  (which is default), any event  older than the buffer is aggregated with the oldest event in buffer. If  this parameter is set to  true , any event older than the buffer is dropped. This is an optional annotation.    @store  This annotation is used to refer to the data store where the calculated  aggregate results are stored. This annotation is optional. When  no annotation is provided, the data is stored in the  in-memory  store.    @purge  This annotation is used to configure purging in aggregation granularities.  If this annotation is not provided, the default purging mentioned above is applied.  If you want to disable automatic data purging, you can use this annotation as follows: '@purge(enable=false) /You should disable data purging if the aggregation query in included in the Siddhi application for read-only purposes.    @retentionPeriod  This annotation is used to specify the length of time the data needs to be retained when carrying out data purging.  If this annotation is not provided, the default retention period is applied.    aggregator name  This specifies a unique name for the aggregation so that it can be referred  when accessing aggregate results.    input stream  The stream that feeds the aggregation.  Note! this stream should be  already defined.    group by  attribute name  The  group by  clause is optional. If it is included in a Siddhi application, aggregate values   are calculated per each  group by  attribute. If it is not used, all the  events are aggregated together.    by  timestamp attribute  This clause is optional. This defines the attribute that should be used as  the timestamp. If this clause is not used, the event time is used by default.  The timestamp could be given as either a  string  or a  long  value. If it is a  long  value,  the unix timestamp in milliseconds is expected (e.g.  1496289950000 ). If it is  a  string  value, the supported formats are  yyyy - MM - dd   HH : mm : ss   (if time is in GMT) and   yyyy - MM - dd   HH : mm : ss   Z  (if time is  not in GMT), here the ISO 8601 UTC offset must be provided for  Z  . (e.g.,  +05:30 ,  -11:00 ).    time periods  Time periods can be specified as a range where the minimum and the maximum value are separated by three dots, or as comma-separated values.   e.g., A range can be specified as sec...year where aggregation is done per second, minute, hour, day, month and year. Comma-separated values can be specified as min, hour.   Skipping time durations (e.g., min, day where the hour duration is skipped) when specifying comma-separated values is supported only from v4.1.1 onwards      Note  From V4.2.0 onwards, aggregation is carried out at calendar start times for each granularity with the GMT timezone    Note  From V4.2.6 onwards, the same aggregation can be defined in multiple Siddhi apps for joining, however,  only one siddhi app should carry out the processing  (i.e. the aggregation input stream should only feed events to one aggregation definition).   Example  This Siddhi Application defines an aggregation named  TradeAggregation  to calculate the average and sum for the  price  attribute of events arriving at the  TradeStream  stream. These aggregates are calculated per every time granularity in the second-year range.  define   stream   TradeStream   ( symbol   string ,   price   double ,   volume   long ,   timestamp   long );  @ purge ( enable = true ,   interval = 10 sec , @ retentionPeriod ( sec = 120 sec , min = 24 hours , hours = 30 days , days = 1 year , months = all , years = all ))  define   aggregation   TradeAggregation \n   from   TradeStream \n   select   symbol ,   avg ( price )   as   avgPrice ,   sum ( price )   as   total \n     group   by   symbol \n     aggregate   by   timestamp   every   sec   ...   year ;", 
            "title": "Incremental Aggregation"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#distributed-aggregation", 
            "text": "Note  Distributed Aggregation is only supported after v4.3.0   Distributed Aggregation allows you to partially process aggregations in different shards. This allows Siddhi\napp in one shard to be responsible only for processing a part of the aggregation.\nHowever for this, all aggregations must be based on a common physical database(@store).  Syntax  @ store ( type = store type ,   ...)  @ PartitionById  define   aggregation   aggregator   name  from   input   stream  select   attribute   name ,   aggregate   function ( attribute   name )   as   attribute   name ,   ... \n     group   by   attribute   name \n     aggregate   by   timestamp   attribute   every   time   periods   ;   Following table includes the  annotation  to be used to enable distributed aggregation,     Item  Description      @PartitionById  If the annotation is given, then the distributed aggregation is enabled. Further this can be disabled by using  enable  element,  @PartitionById(enable='false') .     Further, following system properties are also available,     System Property  Description  Possible Values  Optional  Default Value      shardId  The id of the shard one of the distributed aggregation is running in. This should be unique to a single shard  Any string  No     partitionById  This allows user to enable/disable distributed aggregation for all aggregations running in one siddhi manager .(Available from v4.3.3)  true/false  Yesio  false      Note  ShardIds should not be changed after the first configuration in order to keep data consistency.", 
            "title": "Distributed Aggregation"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#join-aggregation", 
            "text": "This allows a stream to retrieve calculated aggregate values from the aggregation.   Note  A join can also be performed with  two streams , with a  table  and a stream, or with a stream against externally  defined windows .   Syntax  A join with aggregation is similer to the join with  table , but with additional  within  and  per  clauses.  from   input   stream   join   aggrigation \n   on   join   condition \n   within   time   range \n   per   time   granularity  select   attribute   name ,   attribute   name ,   ...  insert   into   output   stream ;   Apart from constructs of  table join  this includes the following. Please note that the 'on' condition is optional :     Item  Description      within   time range  This allows you to specify the time interval for which the aggregate values need to be retrieved. This can be specified by providing the start and end time separated by a comma as  string  or  long  values, or by using the wildcard  string  specifying the data range. For details refer examples.    per  time granularity  This specifies the time granularity by which the aggregate values must be grouped and returned. e.g., If you specify  days , the retrieved aggregate values are grouped for each day within the selected time interval.    AGG_TIMESTAMP  This specifies the start time of the aggregations and can be used in the select clause.     within  and  per  clauses also accept attribute values from the stream.   Note  The timestamp of the aggregations can be accessed through the  AGG_TIMESTAMP  attribute.   Example  Following aggregation definition will be used for the examples.  define   stream   TradeStream   ( symbol   string ,   price   double ,   volume   long ,   timestamp   long );  define   aggregation   TradeAggregation \n   from   TradeStream \n   select   AGG_TIMESTAMP ,   symbol ,   avg ( price )   as   avgPrice ,   sum ( price )   as   total \n     group   by   symbol \n     aggregate   by   timestamp   every   sec   ...   year ;   This query retrieves daily aggregations within the time range  \"2014-02-15 00:00:00 +05:30\", \"2014-03-16 00:00:00 +05:30\"  (Please note that +05:30 can be omitted if timezone is GMT)  define   stream   StockStream   ( symbol   string ,   value   int );  from   StockStream   as   S   join   TradeAggregation   as   T \n   on   S . symbol   ==   T . symbol \n   within   2014-02-15 00:00:00 +05:30 ,   2014-03-16 00:00:00 +05:30 \n   per   days  select   S . symbol ,   T . total ,   T . avgPrice  insert   into   AggregateStockStream ;   This query retrieves hourly aggregations within the day  2014-02-15 .  define   stream   StockStream   ( symbol   string ,   value   int );  from   StockStream   as   S   join   TradeAggregation   as   T \n   on   S . symbol   ==   T . symbol \n   within   2014-02-15 **:**:** +05:30 \n   per   hours  select   S . symbol ,   T . total ,   T . avgPrice  insert   into   AggregateStockStream ;   This query retrieves all aggregations per  perValue  stream attribute within the time period\nbetween timestamps  1496200000000  and  1596434876000 .  define   stream   StockStream   ( symbol   string ,   value   int ,   perValue   string );  from   StockStream   as   S   join   TradeAggregation   as   T \n   on   S . symbol   ==   T . symbol \n   within   1496200000000 L ,   1596434876000 L \n   per   S . perValue  select   S . symbol ,   T . total ,   T . avgPrice  insert   into   AggregateStockStream ;   Supported join types  Aggregation join supports following join operations.    Inner join (join)  This is the default behaviour of a join operation.  join  is used as the keyword to join the stream with the aggregation. The output is generated only if there is a matching event in the stream and the aggregation.    Left outer join  The  left outer join  operation allows you to join a stream on left side with a aggregation on the right side based on a condition.\nHere, it returns all the events of left stream even if there are no matching events in the right aggregation by\nhaving null values for the attributes of the right aggregation.    Right outer join  This is similar to a  left outer join .  right outer join  is used as the keyword to join a stream on right side with a aggregation on the left side based on a condition.\nIt returns all the events of the right stream even if there are no matching events in the left aggregation.", 
            "title": "Join (Aggregation)"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#defined-window", 
            "text": "A defined window is a window that can be shared across multiple queries.\nEvents can be inserted to a defined window from one or more queries and it can produce output events based on the defined window type.  Syntax  The syntax for a defined window is as follows:  define   window   window   name   ( attribute   name   attribute   type ,   attribute   name   attribute   type ,   ...   )   window   type ( parameter ,   parameter ,   \u2026 )   output   event   type ;   The following parameters are configured in a table definition:     Parameter  Description      window name  The name of the window defined. ( PascalCase  is used for window names as a convention.)    attribute name  The schema of the window is defined by its attributes with uniquely identifiable attribute names ( camelCase  is used for attribute names as a convention.)    attribute type  The type of each attribute defined in the schema.   This can be  STRING ,  INT ,  LONG ,  DOUBLE ,  FLOAT ,  BOOL  or  OBJECT .    window type ( parameter , ...)  The window type associated with the window and its parameters.    output  output event type  This is optional. Keywords such as  current events ,  expired events  and  all events  (the default) can be used to specify when the window output should be exposed. For more information, see  output event type .     Examples    Returning all output when events arrive and when events expire from the window.  In this query, the output event type is not specified. Therefore, it returns both current and expired events as the output.       define   window   SensorWindow   ( name   string ,   value   float ,   roomNo   int ,   deviceID   string )   timeBatch ( 1   second );     Returning an output only when events expire from the window.  In this query, the output event type of the window is  expired events . Therefore, it only returns the events that have expired from the window as the output.       define   window   SensorWindow   ( name   string ,   value   float ,   roomNo   int ,   deviceID   string )   timeBatch ( 1   second )   output   expired   events ;   Operators on Defined Windows  The following operators can be performed on defined windows.", 
            "title": "(Defined) Window"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#insert_1", 
            "text": "This allows events to be inserted into windows. This is similar to inserting events into streams.  Syntax  from   input   stream  select   attribute   name ,   attribute   name ,   ...  insert   into   window   To insert only events of a specific output event type, add the  current events ,  expired events  or the  all events  keyword between  insert  and  into  keywords (similar to how it is done for streams).  For more information, see  output event type .  Example  This query inserts all events from the  TempStream  stream to the  OneMinTempWindow  window.  define   stream   TempStream ( tempId   string ,   temp   double );  define   window   OneMinTempWindow ( tempId   string ,   temp   double )   time ( 1   min );  from   TempStream  select   *  insert   into   OneMinTempWindow ;", 
            "title": "Insert"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#join-window", 
            "text": "To allow a stream to retrieve information from a window based on a condition.   Note  A join can also be performed with  two streams ,  aggregation  or with tables  tables .   Syntax  from   input   stream   join   window \n     on   condition  select   ( input   stream | window ). attribute   name ,   ( input   stream | window ). attribute   name ,   ...  insert   into   output   stream   Example  This Siddhi Application performs a join count the number of temperature events having more then 40 degrees\n within the last 2 minutes.  define   window   TwoMinTempWindow   ( roomNo   int ,   temp   double )   time ( 2   min );  define   stream   CheckStream   ( requestId   string );  from   CheckStream   as   C   join   TwoMinTempWindow   as   T \n     on   T . temp     40  select   requestId ,   count ( T . temp )   as   count  insert   into   HighTempCountStream ;   Supported join types  Window join supports following operations of a join clause.    Inner join (join)  This is the default behaviour of a join operation.  join  is used as the keyword to join two windows or a stream with a window. The output is generated only if there is a matching event in both stream/window.    Left outer join  The  left outer join  operation allows you to join two windows or a stream with a window to be merged based on a condition.\nHere, it returns all the events of left stream/window even if there are no matching events in the right stream/window by\nhaving null values for the attributes of the right stream/window.    Right outer join  This is similar to a left outer join.  Right outer join  is used as the keyword to join two windows or a stream with a window.\nIt returns all the events of the right stream/window even if there are no matching events in the left stream/window.    Full outer join  The full outer join combines the results of  left outer join  and  right outer join .  full outer join  is used as the keyword to join two windows or a stream with a window.\nHere, output event are generated for each incoming event even if there are no matching events in the other stream/window.", 
            "title": "Join (Window)"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#from", 
            "text": "A window can be an input to a query, similar to streams.  Note !!!\n     When window is used as an input to a query, another window cannot be applied on top of this.  Syntax  from   window  select   attribute   name ,   attribute   name ,   ...  insert   into   output   stream   Example \nThis Siddhi Application calculates the maximum temperature within the last 5 minutes.  define   window   FiveMinTempWindow   ( roomNo   int ,   temp   double )   time ( 5   min );  from   FiveMinTempWindow  select   max ( temp )   as   maxValue ,   roomNo  insert   into   MaxSensorReadingStream ;", 
            "title": "From"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#trigger", 
            "text": "Triggers allow events to be periodically generated.  Trigger definition  can be used to define a trigger.\nA trigger also works like a stream with a predefined schema.  Purpose  For some use cases the system should be able to periodically generate events based on a specified time interval to perform\nsome periodic executions.  A trigger can be performed for a  'start'  operation, for a given  time interval , or for a given  ' cron expression ' .  Syntax  The syntax for a trigger definition is as follows.  define   trigger   trigger   name   at   ( start |   every   time   interval |   cron expression );   Similar to streams, triggers can be used as inputs. They adhere to the following stream definition and produce the  triggered_time  attribute of the  long  type.  define   stream   trigger   name   ( triggered_time   long );   The following types of triggeres are currently supported:     Trigger type  Description      'start'  An event is triggered when Siddhi is started.    every  time interval  An event is triggered periodically at the given time interval.    ' cron expression '  An event is triggered periodically based on the given cron expression. For configuration details, see  quartz-scheduler .     Examples    Triggering events regularly at specific time intervals  The following query triggers events every 5 minutes.          define   trigger   FiveMinTriggerStream   at   every   5   min ;     Triggering events at a specific time on specified days  The following query triggers an event at 10.15 AM on every weekdays.          define   trigger   FiveMinTriggerStream   at   0 15 10 ? * MON-FRI ;", 
            "title": "Trigger"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#script", 
            "text": "Scripts allow you to write functions in other programming languages and execute them within Siddhi queries.\nFunctions defined via scripts can be accessed in queries similar to any other inbuilt function. Function definitions  can be used to define these scripts.  Function parameters are passed into the function logic as  Object[]  and with the name  data  .  Purpose  Scripts allow you to define a function operation that is not provided in Siddhi core or its extension. It is not required to write an extension to define the function logic.  Syntax  The syntax for a Script definition is as follows.  define   function   function   name [ language   name ]   return   return   type   { \n     operation   of   the   function  } ;   The following parameters are configured when defining a script.     Parameter  Description      function name  The name of the function ( camelCase  is used for the function name) as a convention.    language name  The name of the programming language used to define the script, such as  javascript ,  r  and  scala .    return type  The attribute type of the function\u2019s return. This can be  int ,  long ,  float ,  double ,  string ,  bool  or  object . Here the function implementer should be responsible for returning the output attribute on the defined return type for proper functionality.    operation of the function  Here, the execution logic of the function is added. This logic should be written in the language specified under the  language name , and it should return the output in the data type specified via the  return type  parameter.     Examples  This query performs concatenation using JavaScript, and returns the output as a string.  define   function   concatFn [ javascript ]   return   string   { \n     var   str1   =   data [ 0 ]; \n     var   str2   =   data [ 1 ]; \n     var   str3   =   data [ 2 ]; \n     var   responce   =   str1   +   str2   +   str3 ; \n     return   responce ;  } ;  define   stream   TempStream ( deviceID   long ,   roomNo   int ,   temp   double );  from   TempStream  select   concatFn ( roomNo , - , deviceID )   as   id ,   temp  insert   into   DeviceTempStream ;", 
            "title": "Script"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#store-query", 
            "text": "Siddhi store queries are a set of on-demand queries that can be used to perform operations on Siddhi tables, windows, and aggregators.  Purpose  Store queries allow you to execute the following operations on Siddhi tables, windows, and aggregators without the intervention of streams.  Queries supported for tables:   SELECT  INSERT  DELETE  UPDATE  UPDATE OR INSERT   Queries supported for windows and aggregators:   SELECT   This is be done by submitting the store query to the Siddhi application runtime using its  query()  method.  In order to execute store queries, the Siddhi application of the Siddhi application runtime you are using, should have\n a store defined, which contains the table that needs to be queried.  Example  If you need to query the table named  RoomTypeTable  the it should have been defined in the Siddhi application.  In order to execute a store query on  RoomTypeTable , you need to submit the store query using  query() \nmethod of  SiddhiAppRuntime  instance as below.  siddhiAppRuntime . query ( store   query );", 
            "title": "Store Query"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#tablewindow-select", 
            "text": "The  SELECT  store query retrieves records from the specified table or window, based on the given condition.  Syntax  from   table / window  on   condition ?  select   attribute   name ,   attribute   name ,   ...  group   by ?  having ?  order   by ?  limit ?   Example  This query retrieves room numbers and types of the rooms starting from room no 10.  from   roomTypeTable  on   roomNo   =   10 ;  select   roomNo ,   type", 
            "title": "(Table/Window) Select"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#aggregation-select", 
            "text": "The  SELECT  store query retrieves records from the specified aggregation, based on the given condition, time range,\nand granularity.  Syntax  from   aggregation  on   condition ?  within   time   range  per   time   granularity  select   attribute   name ,   attribute   name ,   ...  group   by ?  having ?  order   by ?  limit ?   Example  Following aggregation definition will be used for the examples.  define   stream   TradeStream   ( symbol   string ,   price   double ,   volume   long ,   timestamp   long );  define   aggregation   TradeAggregation \n   from   TradeStream \n   select   symbol ,   avg ( price )   as   avgPrice ,   sum ( price )   as   total \n     group   by   symbol \n     aggregate   by   timestamp   every   sec   ...   year ;   This query retrieves daily aggregations within the time range  \"2014-02-15 00:00:00 +05:30\", \"2014-03-16 00:00:00 +05:30\"  (Please note that +05:30 can be omitted if timezone is GMT)  from   TradeAggregation \n   within   2014-02-15 00:00:00 +05:30 ,   2014-03-16 00:00:00 +05:30 \n   per   days  select   symbol ,   total ,   avgPrice   ;   This query retrieves hourly aggregations of \"FB\" symbol within the day  2014-02-15 .  from   TradeAggregation \n   on   symbol   ==   FB \n   within   2014-02-15 **:**:** +05:30 \n   per   hours  select   symbol ,   total ,   avgPrice ;", 
            "title": "(Aggregation) Select"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#insert_2", 
            "text": "This allows you to insert a new record to the table with the attribute values you define in the  select  section.  Syntax  select   attribute   name ,   attribute   name ,   ...  insert   into   table ;   Example  This store query inserts a new record to the table  RoomOccupancyTable , with the specified attribute values.  select   10   as   roomNo ,   2   as   people  insert   into   RoomOccupancyTable", 
            "title": "Insert"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#delete_1", 
            "text": "The  DELETE  store query deletes selected records from a specified table.  Syntax  select ?    delete   table    on   conditional   expresssion   The  condition  element specifies the basis on which records are selected to be deleted.   Note  Table attributes must always be referred to with the table name as shown below:  \n  table name . attibute name .   Example  In this example, query deletes a record in the table named  RoomTypeTable  if it has value for the  roomNo \nattribute that matches the value for the  roomNumber  attribute of the selection which has 10 as the actual value.  select   10   as   roomNumber  delete   RoomTypeTable  on   RoomTypeTable . roomNo   ==   roomNumber ;   delete   RoomTypeTable  on   RoomTypeTable . roomNo   ==   10 ;", 
            "title": "Delete"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#update_1", 
            "text": "The  UPDATE  store query updates selected attributes stored in a specific table, based on a given condition.  Syntax  select   attribute   name ,   attribute   name ,   ... ?  update   table \n     set   table . attribute   name   =   ( attribute   name | expression ) ? ,   table . attribute   name   =   ( attribute   name | expression ) ? ,   ... \n     on   condition   The  condition  element specifies the basis on which records are selected to be updated.\nWhen specifying the  condition , table attributes must be referred to with the table name.  You can use the  set  keyword to update selected attributes from the table. Here, for each assignment, the attribute specified in the left must be the table attribute, and the one specified in the right can be a stream/table attribute a mathematical operation, or other. When the  set  clause is not provided, all the attributes in the table are updated.   Note  Table attributes must always be referred to with the table name as shown below:  \n  table name . attibute name .   Example  The following query updates the room occupancy by increasing the value of  people  by 1, in the  RoomOccupancyTable \ntable for each room number greater than 10.  select   10   as   roomNumber ,   1   as   arrival  update   RoomTypeTable \n     set   RoomTypeTable . people   =   RoomTypeTable . people   +   arrival \n     on   RoomTypeTable . roomNo   ==   roomNumber ;   update   RoomTypeTable \n     set   RoomTypeTable . people   =   RoomTypeTable . people   +   1 \n     on   RoomTypeTable . roomNo   ==   10 ;", 
            "title": "Update"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#update-or-insert_1", 
            "text": "This allows you to update selected attributes if a record that meets the given conditions already exists in the specified  table.\nIf a matching record does not exist, the entry is inserted as a new record.  Syntax  select   attribute   name ,   attribute   name ,   ...  update   or   insert   into   table \n     set   table . attribute   name   =   expression ,   table . attribute   name   =   expression ,   ... \n     on   condition   The  condition  element specifies the basis on which records are selected for update.\nWhen specifying the  condition , table attributes should be referred to with the table name.\nIf a record that matches the condition does not already exist in the table, the arriving event is inserted into the table.  The  set  clause is only used when an update is performed during the insert/update operation.\nWhen  set  clause is used, the attribute to the left is always a table attribute, and the attribute to the right can be a stream/table attribute, mathematical\noperation or other. The attribute to the left (i.e., the attribute in the event table) is updated with the value of the attribute to the right if the given condition is met. When the  set  clause is not provided, all the attributes in the table are updated.   Note  Table attributes must always be referred to with the table name as shown below:  \n  table name . attibute name .   Example  The following query tries to update the records in the  RoomAssigneeTable  table that have room numbers that match the\n same in the selection. If such records are not found, it inserts a new record based on the values provided in the selection.  select   10   as   roomNo ,   single   as   type ,   abc   as   assignee  update   or   insert   into   RoomAssigneeTable \n     set   RoomAssigneeTable . assignee   =   assignee \n     on   RoomAssigneeTable . roomNo   ==   roomNo ;", 
            "title": "Update or Insert"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#extensions", 
            "text": "Siddhi supports an extension architecture to enhance its functionality by incorporating other libraries in a seamless manner.  Purpose  Extensions are supported because, Siddhi core cannot have all the functionality that's needed for all the use cases, mostly use cases require\ndifferent type of functionality, and for some cases there can be gaps and you need to write the functionality by yourself.  All extensions have a namespace. This is used to identify the relevant extensions together, and to let you specifically call the extension.  Syntax  Extensions follow the following syntax;  namespace : function   name ( parameter ,   parameter ,   ...   )   The following parameters are configured when referring a script function.     Parameter  Description      namespace  Allows Siddhi to identify the extension without conflict    function name  The name of the function referred.    parameter  The function input parameter for function execution.      Extension Types  Siddhi supports following extension types:    Function  For each event, it consumes zero or more parameters as input parameters and returns a single attribute. This can be used to manipulate existing event attributes to generate new attributes like any Function operation.  This is implemented by extending  io.siddhi.core.executor.function.FunctionExecutor .  Example :  math:sin(x)  Here, the  sin  function of  math  extension returns the sin value for the  x  parameter.    Aggregate Function  For each event, it consumes zero or more parameters as input parameters and returns a single attribute with aggregated results. This can be used in conjunction with a window in order to find the aggregated results based on the given window like any Aggregate Function operation.  This is implemented by extending  io.siddhi.core.query.selector.attribute.aggregator.AttributeAggregatorExecutor .  Example :  custom:std(x)  Here, the  std  aggregate function of  custom  extension returns the standard deviation of the  x  value based on its assigned window query.    Window  This allows events to be  collected, generated, dropped and expired anytime   without altering  the event format based on the given input parameters, similar to any other Window operator.  This is implemented by extending  io.siddhi.core.query.processor.stream.window.WindowProcessor .  Example :  custom:unique(key)  Here, the  unique  window of the  custom  extension retains one event for each unique  key  parameter.    Stream Function  This allows events to be   generated or dropped only during event arrival  and  altered  by adding one or more attributes to it.  This is implemented by extending   io.siddhi.core.query.processor.stream.function.StreamFunctionProcessor .  Example :    custom:pol2cart(theta,rho)  Here, the  pol2cart  function of the  custom  extension returns all the events by calculating the cartesian coordinates  x     y  and adding them as new attributes to the events.    Stream Processor  This allows events to be  collected, generated, dropped and expired anytime  by  altering  the event format by adding one or more attributes to it based on the given input parameters.  Implemented by extending  io.siddhi.core.query.processor.stream.StreamProcessor .  Example :    custom:perMinResults( parameter ,  parameter , ...)  Here, the  perMinResults  function of the  custom  extension returns all events by adding one or more attributes to the events based on the conversion logic. Altered events are output every minute regardless of event arrivals.    Sink  Sinks provide a way to  publish Siddhi events to external systems  in the preferred data format. Sinks publish events from the streams via multiple transports to external endpoints in various data formats.  Implemented by extending  io.siddhi.core.stream.output.sink.Sink .  Example :  @sink(type='sink_type', static_option_key1='static_option_value1')  To configure a stream to publish events via a sink, add the sink configuration to a stream definition by adding the @sink annotation with the required parameter values. The sink syntax is as above    Source  Source allows Siddhi to  consume events from external systems , and map the events to adhere to the associated stream. Sources receive events via multiple transports and in various data formats, and direct them into streams for processing.  Implemented by extending  io.siddhi.core.stream.input.source.Source .  Example :  @source(type='source_type', static.option.key1='static_option_value1')  To configure a stream that consumes events via a source, add the source configuration to a stream definition by adding the @source annotation with the required parameter values. The source syntax is as above    Store  You can use Store extension type to work with data/events  stored in various data stores through the table abstraction . You can find more information about these extension types under the heading 'Extension types' in this document.  Implemented by extending  io.siddhi.core.table.record.AbstractRecordTable .    Script  Scripts allow you to  define a function  operation that is not provided in Siddhi core or its extension. It is not required to write an extension to define the function logic. Scripts allow you to write functions in other programming languages and execute them within Siddhi queries. Functions defined via scripts can be accessed in queries similar to any other inbuilt function.  Implemented by extending  io.siddhi.core.function.Script .    Source Mapper  Each  @source  configuration has a mapping denoted by the  @map  annotation that  converts the incoming messages format to Siddhi events .The type parameter of the @map defines the map type to be used to map the data. The other parameters to be configured depends on the mapper selected. Some of these parameters are optional.  Implemented by extending  io.siddhi.core.stream.output.sink.SourceMapper .  Example :  @map(type='map_type', static_option_key1='static_option_value1')    Sink Mapper  Each  @sink  configuration has a mapping denoted by the  @map  annotation that  converts the outgoing Siddhi events to configured messages format .The type parameter of the @map defines the map type to be used to map the data. The other parameters to be configured depends on the mapper selected. Some of these parameters are optional.  Implemented by extending  io.siddhi.core.stream.output.sink.SinkMapper .  Example :  @map(type='map_type', static_option_key1='static_option_value1')    Example  A window extension created with namespace  foo  and function name  unique  can be referred as follows:  from   StockExchangeStream [ price   =   20 ] # window . foo : unique ( symbol )  select   symbol ,   price  insert   into   StockQuote   Available Extensions  Siddhi currently has several pre written extensions that are available  here  We value your contribution on improving Siddhi and its extensions further.", 
            "title": "Extensions"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#writing-custom-extensions", 
            "text": "Custom extensions can be written in order to cater use case specific logic that are not available in Siddhi out of the box or as an existing extension.  There are five types of Siddhi extensions that you can write to cater your specific use cases. These\nextension types and the related maven archetypes are given below. You can use these archetypes to generate Maven projects for each\nextension type.   Follow the procedure for the required archetype, based on your project:    Note  When using the generated archetype please make sure you uncomment @Extension annotation and complete the\nannotation with proper values. This annotation will be used to identify and document the extension, hence your\nextension will not work without @Extension annotation.   siddhi-execution  Siddhi-execution provides following extension types:   Function  Aggregate Function  Stream Function  Stream Processor  Window   You can use one or more from above mentioned extension types and implement according to your requirement.  For more information about these extension types, see  Extension Types .  To install and implement the siddhi-io extension archetype, follow the procedure below:    Issue the following command from your CLI.          mvn archetype:generate\n            -DarchetypeGroupId=io.siddhi.extension.archetype\n            -DarchetypeArtifactId=siddhi-archetype-execution\n            -DgroupId=io.extension.siddhi.execution\n            -Dversion=1.0.0-SNAPSHOT    Enter the required execution name in the message that pops up as shown in the example below.      Define value for property  executionType : ML    To confirm that all property values are correct, type  Y  in the console. If not, press  N .    siddhi-io  Siddhi-io provides following extension types:   Sink  Source   You can use one or more from above mentioned extension types and implement according to your requirement. siddhi-io is generally used to work with IO operations as follows:\n * The Source extension type gets inputs to your Siddhi application.\n * The Sink extension publishes outputs from your Siddhi application.  For more information about these extension types, see  Extension Types .  To implement the siddhi-io extension archetype, follow the procedure below:    Issue the following command from your CLI.         mvn archetype:generate\n           -DarchetypeGroupId=io.siddhi.extension.archetype\n           -DarchetypeArtifactId=siddhi-archetype-io\n           -DgroupId=io.extension.siddhi.io\n           -Dversion=1.0.0-SNAPSHOT    Enter the required execution name (the transport type in this scenario) in the message that pops up as shown in the example below.   Define value for property  typeOf_IO : http    To confirm that all property values are correct, type  Y  in the console. If not, press  N .    siddhi-map  Siddhi-map provides following extension types,   Sink Mapper  Source Mapper   You can use one or more from above mentioned extension types and implement according to your requirement as follows.   The Source Mapper maps events to a predefined data format (such as XML, JSON, binary, etc), and publishes them to external endpoints (such as E-mail, TCP, Kafka, HTTP, etc).  The Sink Mapper also maps events to a predefined data format, but it does it at the time of publishing events from a Siddhi application.   For more information about these extension types, see  Extension Types .  To implement the siddhi-map extension archetype, follow the procedure below:    Issue the following command from your CLI.                          mvn archetype:generate\n            -DarchetypeGroupId=io.siddhi.extension.archetype\n            -DarchetypeArtifactId=siddhi-archetype-map\n            -DgroupId=io.extension.siddhi.map\n            -Dversion=1.0.0-SNAPSHOT    Enter the required execution name (the map type in this scenario) in the message that pops up as shown in the example below.      Define value for property  mapType :CSV    To confirm that all property values are correct, type  Y  in the console. If not, press  N .    siddhi-script  Siddhi-script provides the  Script  extension type.  The script extension type allows you to write functions in other programming languages and execute them within Siddhi queries. Functions defined via scripts can be accessed in queries similar to any other inbuilt function.  For more information about these extension types, see  Extension Types .  To implement the siddhi-script extension archetype, follow the procedure below:    Issue the following command from your CLI.                            mvn archetype:generate\n           -DarchetypeGroupId=io.siddhi.extension.archetype\n           -DarchetypeArtifactId=siddhi-archetype-script\n           -DgroupId=io.extension.siddhi.script\n           -Dversion=1.0.0-SNAPSHOT    Enter the required execution name in the message that pops up as shown in the example below.   Define value for property  typeOfScript :    To confirm that all property values are correct, type  Y  in the console. If not, press  N .    siddhi-store  Siddhi-store provides the  Store  extension type.  The Store extension type allows you to work with data/events stored in various data stores through the table abstraction.  For more information about these extension types, see  Extension Types .  To implement the siddhi-store extension archetype, follow the procedure below:    Issue the following command from your CLI.                               mvn archetype:generate\n          -DarchetypeGroupId=io.siddhi.extension.archetype\n          -DarchetypeArtifactId=siddhi-archetype-store\n          -DgroupId=io.extension.siddhi.store\n          -Dversion=1.0.0-SNAPSHOT    Enter the required execution name in the message that pops up as shown in the example below.    Define value for property  storeType : RDBMS    To confirm that all property values are correct, type  Y  in the console. If not, press  N .", 
            "title": "Writing Custom Extensions"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#configuring-and-monitoring-siddhi-applications", 
            "text": "", 
            "title": "Configuring and Monitoring Siddhi Applications"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#multi-threading-and-asynchronous-processing", 
            "text": "When  @Async  annotation is added to the Streams it enable the Streams to introduce asynchronous and multi-threading\nbehaviour.  @ Async ( buffer . size = 256 ,   workers = 2 ,   batch . size . max = 5 )  define   stream   stream   name   ( attribute   name   attribute   type ,   attribute   name   attribute   type ,   ...   );   The following elements are configured with this annotation.     Annotation  Description  Default Value      buffer.size  The size of the event buffer that will be used to handover the execution to other threads.  -    workers  Number of worker threads that will be be used to process the buffered events.  1    batch.size.max  The maximum number of events that will be processed together by a worker thread at a given time.  buffer.size", 
            "title": "Multi-threading and Asynchronous Processing"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#statistics", 
            "text": "Use  @app:statistics  app level annotation to evaluate the performance of an application, you can enable the statistics of a Siddhi application to be published. This is done via the  @app:statistics  annotation that can be added to a Siddhi application as shown in the following example.  @ app : statistics ( reporter   =   console )   The following elements are configured with this annotation.     Annotation  Description  Default Value      reporter  The interface in which statistics for the Siddhi application are published. Possible values are as follows:   console   jmx  console    interval  The time interval (in seconds) at  which the statistics for the Siddhi application are reported.  60    include  If this parameter is added, only the types of metrics you specify are included in the reporting. The required metric types can be specified as a comma-separated list. It is also possible to use wild cards  All ( . )     The metrics are reported in the following format. io.siddhi.SiddhiApps. SiddhiAppName .Siddhi. Component Type . Component Name .  Metrics name  The following table lists the types of metrics supported for different Siddhi application component types.     Component Type  Metrics Type      Stream  Throughput The size of the buffer if parallel processing is enabled via the @async annotation.    Trigger  Throughput (Trigger and Stream)    Source  Throughput    Sink  Throughput    Mapper  Latency Input/output throughput    Table  Memory Throughput (For all operations) Throughput (For all operations)    Query  Memory Latency    Window  Throughput (For all operations) Latency (For all operation)    Partition  Throughput (For all operations) Latency (For all operation)     e.g., the following is a Siddhi application that includes the  @app  annotation to report performance statistics.  @ App : name ( TestMetrics )  @ App : Statistics ( reporter   =   console )  define   stream   TestStream   ( message   string );  @ info ( name = logQuery )  from   TestSream # log ( Message: )  insert   into   TempSream ;   Statistics are reported for this Siddhi application as shown in the extract below.  \n   Click to view the extract \n11/26/17 8:01:20 PM ============================================================  -- Gauges ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Queries.logQuery.memory\n              value = 5760\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TestStream.size\n              value = 0  -- Meters ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Sources.TestStream.http.throughput\n              count = 0\n          mean rate = 0.00 events/second\n      1-minute rate = 0.00 events/second\n      5-minute rate = 0.00 events/second\n     15-minute rate = 0.00 events/second\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TempSream.throughput\n              count = 2\n          mean rate = 0.04 events/second\n      1-minute rate = 0.03 events/second\n      5-minute rate = 0.01 events/second\n     15-minute rate = 0.00 events/second\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TestStream.throughput\n              count = 2\n          mean rate = 0.04 events/second\n      1-minute rate = 0.03 events/second\n      5-minute rate = 0.01 events/second\n     15-minute rate = 0.00 events/second  -- Timers ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Queries.logQuery.latency\n              count = 2\n          mean rate = 0.11 calls/second\n      1-minute rate = 0.34 calls/second\n      5-minute rate = 0.39 calls/second\n     15-minute rate = 0.40 calls/second\n                min = 0.61 milliseconds\n                max = 1.08 milliseconds\n               mean = 0.84 milliseconds\n             stddev = 0.23 milliseconds\n             median = 0.61 milliseconds\n               75%  = 1.08 milliseconds\n               95%  = 1.08 milliseconds\n               98%  = 1.08 milliseconds\n               99%  = 1.08 milliseconds\n             99.9%  = 1.08 milliseconds", 
            "title": "Statistics"
        }, 
        {
            "location": "/documentation/siddhi-5.x/query-guide-5.x/#event-playback", 
            "text": "When  @app:playback  annotation is added to the app, the timestamp of the event (specified via an attribute) is treated as the current time. This results in events being processed faster.\nThe following elements are configured with this annotation.     Annotation  Description      idle.time  If no events are received during a time interval specified (in milliseconds) via this element, the Siddhi system time is incremented by a number of seconds specified via the  increment  element.    increment  The number of seconds by which the Siddhi system time must be incremented if no events are received during the time interval specified via the  idle.time  element.     e.g., In the following example, the Siddhi system time is incremented by two seconds if no events arrive for a time interval of 100 milliseconds.  @app:playback(idle.time = '100 millisecond', increment = '2 sec')", 
            "title": "Event Playback"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/", 
            "text": "Siddhi 5.x Architecture\n\n\nSiddhi is an open source, cloud native, stream processing and complex event processing engine, and it can be utilized in any of the following ways:\n\n\n\n\nRun as a server on its own\n\n\nRun with \nWSO2 Stream Processor\n as a service\n\n\nEmbedded into any Java or Python based application\n\n\nRun on an Android application\n\n\n\n\nSiddhi provides streaming data integration and data analytical operators. It connects multiple disparate live data sources, \norchestrates data flows, calculates analytics, and also detects complex event patterns. This allows developers to build \napplications that collect data, performs data transformation and analytics, and publish the results to data sinks in real time.\n\n\n\n\nInfo\n\n\nPlease find the Siddhi 4.x Architecture \nhere\n\n\n\n\nThis section illustrates the architecture of Siddhi Engine and guides you through its key functionality. We hope this article \nhelps developers to understand Siddhi and its codebase better, and also help them to contribute and improve Siddhi.\n\n\nMain Design Decisions\n\n\n\n\nEvent by event processing of real-time streaming data to achieve low latency. \n\n\nEase of use with Streaming SQL providing an intuitive way to express stream processing logic and complex \nevent processing constructs such as Patterns. \n\n\nAchieve high performance by processing events in-memory and using data stores for long term data storage. \n\n\nOptimize performance by enforcing a strict event stream schema and by pre-compiling the queries.\n\n\nOptimize memory consumption by having only the absolutely necessary information in-memory and dropping the rest as soon as possible. \n\n\nSupporting multiple extension points to accommodate a diverse set of functionality such as supporting multiple sources, sinks, functions, \naggregation operations, windows, etc.\n\n\n\n\nHigh Level Architecture\n\n\n\n\nAt a high level, Siddhi consumes events from various events sources, processes them according to the defined Siddhi application, \nand produces results to the subscribed event sinks. \nSiddhi can store and consume events from in-memory tables or from external data stores such as \nRDBMS\n, \nMongoDB\n, \n\nHazelcast\n in-memory grid, etc. (i.e., when configured to do so). Siddhi also allows applications and users to query Siddhi via its Store Query API to interactively \nretrieve data from in-memory and other stores.\n\n\nMain Modules in Siddhi Engine\n\n\nSiddhi Engine comprises four main modules, they are: \n\n\n\n\n\n\nSiddhi Query API\n : This allows users to define the execution logic of the Siddhi application as queries and definitions using POJOs (Plan Old Java Objects). \nInternally, Siddhi uses these objects to identify the logic that it is expected to perform. \n\n\n\n\n\n\nSiddhi Query Compiler\n : This allows users to define the Siddhi application using the Siddhi Streaming SQL, \n and it compiles the Streaming SQL script to Siddhi Query API POJOs so that Siddhi can execute them. \n\n\n\n\n\n\nSiddhi Core\n : This builds the execution runtime based on the defined Siddhi Application POJOs and processes the incoming events as and when they arrive. \n\n\n\n\n\n\nSiddhi Annotation\n : This is a helper module that allows all extensions to be annotated, so that they can be \npicked by Siddhi Core for processing. This also helps Siddhi to generate the extension documentation. \n\n\n\n\n\n\nSiddhi Component Architecture\n\n\nThe following diagram illustrates the main components of Siddhi and how they work together. \n\n\n\n\nHere the \nSiddhi Core\n module maintains\nthe execution logic. It also interacts with the external environment and systems \nfor consuming, processing and publishing events. It uses the following components achieve its tasks:  \n\n\n\n\n\n\nSiddhiManager\n : \n  This is a key component of Siddhi Core that manages Siddhi Application Runtimes \n  and facilitates their functionality via Siddhi Context with periodic state persistence, \n  statistics reporting and extension loading. It is recommended to use one Siddhi Manager for a single JVM.  \n\n\n\n\n\n\nSiddhiAppRuntime\n : \n Siddhi Application Runtime can be generated for each Siddhi Application through the Siddhi Manager. Siddhi Application Runtimes\n provide an isolated execution environment for each defined Siddhi Application. These Siddhi Application Runtimes can have their one lifecycle and they execute \n based on the logic defined in their Siddhi Application. \n\n\n\n\n\n\nSiddhiContext\n : \nThis is a shared object across all the Siddhi Application Runtimes within the same Siddhi manager. It contains references \nto the persistence store for periodic persistence, statistics manager to report performance statistics of Siddhi Application Runtimes, \nand extension holders for loading Siddhi extensions. \n\n\n\n\n\n\nSiddhi Application Creation\n\n\nExecution logic if the Siddhi Engine is composed as a Siddhi Application, and this is usually passed as a string to \n\nSiddhiManager\n to create the \nSiddhiAppRuntime\n for execution. \n\n\nWhen a Siddhi Application is passed to the \nSiddhiManager.createSiddhiAppRuntime()\n, it is processed internally with the \n\nSiddhiCompiler\n. \nHere, the \nSiddhiApp\n String is compiled to \nSiddhiApp\n\n object model by the \nSiddhiQLBaseVisitorImpl\n class. \n This validates the syntax of the given Siddhi Application. The model is then passed to the \nSiddhiAppParser\n \nto create the \nSiddhiAppRuntime\n. During this phase the semantics of the Siddhi Application is validated and the execution logic of the Siddhi Application is optimized. \n\n\nSiddhi App Execution Flow\n\n\nFollowing diagram depicts the execution flow within a Siddhi App Runtime. \n\n\n\n\nThe path taken by events within Siddhi Engine is indicated in blue. \n\n\nThe components that are involved in handling the events are following: \n\n\n\n\n\n\nStreamJunction\n\n\nThis routes events of a particular stream to various components within the Siddhi App Runtime. A stream junction is\ngenerated for each defined or inferred Stream in the Siddhi Application. A stream junction by default uses the incoming event's thread\nand passes all the events to its subscribed components as soon as they arrive, but this behaviour can be altered by configuring \n@Async\n \nannotation to buffer the events at the and stream junction and to use another one or more threads to collect the events from the buffer \nand process the subsequent executions.\n\n\n\n\n\n\nInputHandler\n \n\n\nInput handler is used to push \nEvent\n and \nEvent[]\n objects into stream junctions from defined event sources, and from Java/Python programmes. \n\n\n\n\n\n\nStreamCallback\n \n\n\nThis receives \nEvent[]\ns from stream junction and passes them to event sinks to publish to external endpoints, \nand/or passes them to subscribed Java/Python programmes for further processing. \n\n\n\n\n\n\nQueries\n \n \nPartitions\n \n\n\nThese components process events by filtering, transforming, aggregation, joining, patten matching, \netc. They consume events from one or more stream junctions, process them and publish the processed events\ninto a set of stream junctions based on the defined queries or partitions. \n\n\n\n\n\n\nSource\n \n\n\nSources consume events from external sources in various data formats, convert them into Siddhi events using \nSourceMapper\ns \nand pass them to corresponding stream junction via their associated input handlers. A source is generated \nfor each \n@Source\n annotation defined above a stream definition. \n\n\n\n\n\n\nSourceMapper\n \n\n\nA source mapper is a sub component of source, and it needs to be configured for each source in order to convert the incoming event into Siddhi event. \nThe source mapper type can be configured using the \n@Map\n annotation within the \n@Source\n annotation. When the \n@Map\n annotation is\nnot defined, Siddhi uses the \nPassThroughSourceMapper\n,\nwhere it assumes that the incoming message is already in the \nSiddhi Event\n \nformat (i.e \nEvent\n or \nEvent[]\n), and therefore makes no changes to the incoming event format.\n\n\n\n\n\n\nSink\n \n\n\nSinks consumes events from its associated stream junction, convert them to various data formats via \nSinkMapper\n \nand publish them to external endpoints as defined in the \n@Sink\n annotation. A sink is generated for each \n@Sink\n annotation defined above a stream definition. \n\n\n\n\n\n\nSinkMapper\n\n\nA sink mapper is a sub component of sink. and its need to be configured for each sink in order to map the Siddhi events to the specified data format so that they \ncan be published via the sink. The sink mapper type can be configured using the \n@Map\n annotation within the \n@Sink\n\nannotation. When the \n@Map\n annotation is not defined, Siddhi uses \nPassThroughSinkMapper\n, \nwhere it passes the \nSiddhi Event\n \n(i.e \nEvent\n or \nEvent[]\n) without any formatting to the Sink.\n\n\n\n\n\n\nTable\n\n\nTables are used to store events. When tables are defined by default, Siddhi uses the \nInMemoryTable\n \nimplementation to store events in-memory. When \n@Store\n annotation\nis used on top of the table definition, it loads the associated external data store connector based on the defined \nstore\n type. Most table implementations are \nextended from either \nAbstractRecordTable\n \nor \nAbstractQueryableRecordTable\n abstract classes\nthe former provides functionality to query external data store based on a given filtering condition, and the latter queries external data store by providing projection, limits, and ordering parameters in addition to data filter condition.\n\n\n\n\n\n\nWindow\n\n\nWindows store events as and when they arrive and automatically expire/clean them based on the given window constrain. Multiple types of windows are\ncan be implemented by extending the \nWindowProcessor\n \nabstract class. \n\n\n\n\n\n\nIncrementalAggregation\n \n\n\nLong running time series aggregates defined via the aggregation definition is calculated in an incremental manner using the Incremental Aggregation Processor for the defined time periods.\nIncremental aggregation functions can be implemented by extending \nIncrementalAttributeAggregator\n. \nBy default, incremental aggregations aggregate all the values in-memory, but when its associated with a store by adding \n@store\n \nannotation it uses in-memory to aggregate partial results and use data stores to persist those increments. When requested for aggregate results it \nretrieves data from data stores and (if needed from) in-memory, computes combined aggregate results and provide as the output. \n\n\n\n\n\n\nTrigger\n\n\nA trigger triggers events at a given interval as given in the trigger definition. The triggered events are pushed to a stream junction having the same name as the trigger.\n\n\n\n\n\n\nQueryCallback\n\n\nA query callback taps in to the events that are emitted by a particular query. It notifies the event occurrence \ntimestamp\n, and classifies \nthe output events into \ncurrentEvents\n, and \nexpiredEvents\n. \n\n\n\n\n\n\nSiddhi Query Execution\n\n\nSiddhi \nQueryRuntimes\n\n can be categorized in to three main types: \n\n\n\n\n\n\nSingleInputStream\n: \n Queries that consist of query types such as filters and windows.\n\n\n\n\n\n\nJoinInputStream\n:\n  Queries that consist of joins.\n\n\n\n\n\n\nStateInputStream\n: \n   Queries that consist of patterns and sequences. \n\n\n\n\n\n\nFollowing section explains the internals of each query type. \n\n\nSingleInputStream\n Query Runtime (Filter \n Windows)\n\n\n\n\nA single input stream query runtime is generated for filter and window queries. They consume events from a stream junction or a window\nand convert the incoming events according to the expected output stream format at the \nProcessStreamReceiver\n\nby dropping all the unrelated incoming stream attributes.\n\n\nThen the converted events are passed through a few Processors such as \nFilterProcessor\n,\n\nStreamProcessor\n, \n\nStreamFunctionProcessor\n, \n\nWindowProcessor\n\nand \nQuerySelector\n. \nHere, the \nStreamProcessor\n, \nStreamFunctionProcessor\n, and \nWindowProcessor\n can be extended with various stream processing capabilities. \nThe last processor of the chain of processors must always be a \nQuerySelector\n and it can't appear anywhere else. When the query runtime consumes events from a stream,\nits processor chain can maximum contain one \nWindowProcessor\n, and when query runtime consumes events from a window, its chain of processors cannot \ncontain any \nWindowProcessor\n.\n\n\nThe \nFilterProcessor\n is implemented using expressions that returns a boolean value. \nExpressionExecutor\n \nis used to process conditions, mathematical operations, unary operations, constant values, variables, and functions. Expressions have a tree structure, and \nthey are processed based using the Depth First search algorithm. To achieve high performance, Siddhi currently depends on the user\nto formulate the least successful case in the leftmost side of the condition, thereby increasing the chance of an early \nfalse\n detection.\n\n\nThe condition expression \nprice \n= 100 and ( Symbol == 'IBM' or Symbol == 'MSFT' )\n is represented as shown below.\n\n\n\n\nThese expressions also support the execution of user defined functions (UDFs), and they can be implemented by extending the \nFunctionExecutor\n class. \n\n\nAfter getting processed by all the processors events reach the \nQuerySelector\n for transformation. At the \nQuerySelector\n,\nevents are transformed based on the \nselect\n clause of the query. The \nselect\n clause produced one \nAttributeProcessor\n for each output stream attribute, and these \n\nAttributeProcessor\ns contain expressions defining data transformation including constant values, variables, user defined functions, etc. \nThey can also contain \nAttributeAggregatorExecutor\ns\nto process aggregation operations such as \nsum\n, \ncount\n, etc. If there is a \nGroup By\n clause defined, then the \nGroupByKeyGenerator\n\nis used to identify the composite group-by key, and then for each key an \nAttributeAggregatorExecutor\n state is generated to maintain per group-by key aggregations. \nWhen each time \nAttributeProcessor\n \nis executed the \nAttributeAggregatorExecutor\n calculates per group-by aggregation results and output the values. When \nAttributeAggregatorExecutor\n group-by states become\nobsolete, they are destroyed and automatically cleaned. \n\n\nAfter an event is transformed to the output format through the above process, it is evaluated against the having condition executor if a \nhaving\n clause is \nprovided. The succeeding events are then ordered, and limited based on \norder by\n, \nlimit\n and \noffset\n clauses, \nbefore they pushed to the \nOutputRateLimiter\n. \n\n\nAt \nOutputRateLimiter\n, the event output is controlled before sending the events to the stream junction or to the query callback. \nWhen the \noutput\n clause is not defined, the \nPassThroughOutputRateLimiter\n is used by passing all the events without any rate limiting. \n\n\nTemporal Processing with Windows\n\n\nThe temporal event processing aspect is achieved via \nWindow\n\nand \nAttributeAggregators\n\n\nTo achieve temporal processing, Siddhi uses the following four type of events: \n\n\n\n\n\n\nCurrent Events\n: Events that are newly arriving to the query from streams.\n\n\n\n\n\n\nExpired Events\n: Events that have expired from a window. \n\n\n\n\n\n\nTimer Events\n: Events that inform the query about an update of execution time. These events are usually generated by schedulers. \n\n\n\n\n\n\nReset Events\n: Events that resets the Siddhi query states.\n\n\n\n\n\n\nIn Siddhi, when an event comes into a \nWindowProcessor\n, \nit creates an appropriate \nexpired event\n corresponding to the incoming \ncurrent event\n with the expiring timestamp, and stores that \nevent in the window. At the same time \nWindowProcessor\n also forwards the \ncurrent event\n to the next processor for further processing. \nIt uses a scheduler or some other counting approach to determine when to emit the events that are stored in in-memory. When the \nexpired events\n meets the condition for expiry based on the window contains, it emits the \nexpired events\n to the next processor. \nAt times like in \nwindow.timeBatch()\n there can be cases that needs to emit all the events in-memory at once and the output does not need individual \nexpired events\n values, in this cases the window emits a single \nreset event\n instead of sending one \nexpired event\n for each event it has stored, \nso that it can reset the states in one go. For the \nQuerySelector\n aggregations to work correctly the window must emit a corresponding \nexpired event\n for each \ncurrent event\n it has emitted or it must send a \nreset event\n. \nIn the \nQuerySelector\n, the arrived \ncurrent events\n increase the aggregation values, \nexpired events\n decrease the values, and \n\nreset events\n reset the aggregation calculation to produce correct query output. \n\n\nFor example, the sliding \nTimeWindow\n\n(\nwindow.time()\n) creates a corresponding \nexpired event\n for each \ncurrent event\n that arrives, adds the \nexpired event\ns to \nthe window, adds an entry to the scheduler to notify when that event need to be expired, and finally sends the \ncurrent event\n to the next processor for subsequent processing. \nThe scheduler notifies the window by sending a \ntimer event\n, and when the window receives an indication that the expected expiry time has come for the oldest event in the window via a \na \ntimer event\n or by other means, it removes the \nexpired event\n from the window and passes that to the next processor. \n\n\n\n\nJoinInputStream\n Query Runtime (Join)\n\n\n\n\nJoin input stream query runtime is generated for join queries. This can consume events from two stream junctions and perform a join operation as depicted above. \nIt can also perform a join by consuming events from one stream junction and join against itself, or it can also join against a \ntable, window or an aggregation. When a join is performed with a table, window or aggregation,\nthe \nWindowProcessor\n in the above image is replaced with the corresponding table, window or aggregation and no basic processors are used on their side. \n\n\nThe joining operation is triggered by the events that arrive from the stream junction.\nHere, when an event from one stream reaches the pre \nJoinProcessor\n, \nit matches against all the available events of the other stream's \nWindowProcessor\n. \nWhen a match is found, those matched events are sent to the \nQuerySelector\n as \ncurrent events\n, and at the same time, \nthe original event is added to the \nWindowProcessor\n where it remains until it expires. Similarly, when an \nevent expires from the \nWindowProcessor\n, it matches against all the available events of the other stream's \nWindowProcessor\n, and \nwhen a match is found, those matched events are sent to the \nQuerySelector\n as \nexpired events\n.\n\n\n\n\nNote\n\n\nDespite the optimizations, a join query is quite expensive when it comes to performance. This is because the \nWindowProcessor\n \nis locked during the matching process to avoid race conditions and to achieve accuracy while joining. Therefore, when possible avoid \nmatching large (time or length) windows in high volume streams.\n\n\n\n\nStateInputStream\n Query Runtime (Pattern \n Sequence)\n\n\n\n\nThe state input stream query runtime is generated for pattern and sequence queries. This consumes events from one or more stream junctions \nvia \nProcessStreamReceiver\ns\nand checks whether the events matches each pattern or sequence condition by processing the set of basic processors associated with each \nProcessStreamReceiver\n. \nThe \nPreStateProcessor\ns usually contains lists of state events that are already matched by previous conditions, and if its the first condition \nthen it will have an empty state event in its list. When \nProcessStreamReceiver\n consumes an event, it passes the event \nto the \nPreStateProcessor\n which updates the list of state events it has with the incoming event and executes the condition by passing the events to the basic processors. \nThe state events that matches the conditions reaches the \nPostStateProcessor\n which will then stores the events to the state event list of the following \nPreStateProcessor\n.\nIf it is the final condition's \nPostStateProcessor\n, then it will pass the state event to the \nQuerySelector\n to generate and emit the output.\n\n\nSiddhi Partition Execution\n\n\n\n\nA partition is a wrapper around one or more Siddhi queries and inner streams that connect them. \nA partition is implemented in Siddhi as a \nPartitionRuntime\n\nwhich contains multiple \nQueryRuntime\ns and inner stream junctions. \nEach partitioned stream entering the partition goes through a designated \nPartitionStreamReceiver\n.\nThe \nPartitionExecutor\n\nof \nPartitionStreamReceiver\n evaluates the incoming events to identify their associated partition-key using either \nRangePartitionExecutor\n\nor \nValuePartitionExecutor\n. \nThe identified partition-key is then set as thread local variable and the event is passed to the \nQueryRuntime\ns of processing. \nThe \nQueryRuntime\ns process events by maintaining separate states for each partition-key such that producing separate output per partition.\nWhen a partition query consumes a non partitioned global stream, the \nQueryRuntime\ns are executed for each available partition-key in the system such that \nallowing all partitions to receive the same event. When the partitions are obsolete \nPartitionRuntime\n deletes all the partition states from its \nQueryRuntime\ns. \n\n\nSiddhi Aggregation\n\n\n\n\nSiddhi supports long duration time series aggregations via its aggregation definition. \nAggregationRuntime\n \nimplements this by the use of \nstreaming lambda architecture\n, where it process part of the data in-memory and gets part of the data from data stores. \n\nAggregationRuntime\n creates an in-memory table or external store for each time granularity (i.e seconds, minutes, days, etc) it has to process the events, \nand when events enters it calculates the aggregations in-memory for its least granularity (usually seconds) using the \nIncrementalExecutor\n \nand maintains the running aggregation values in its \nBaseIncrementalValueStore\n. \nAt each clock end time of the granularity (end of each second) \nIncrementalExecutor\n stores the summarized values to the associated granularity \ntable and also passes the summarized values to the \nIncrementalExecutor\n of the next granularity level, which also follows \nthe same methodology in processing the events. Through this approach each time granularities, the current time duration will be in-memory and all the historical time durations \nwill be in stored in the tables. \n\n\nThe aggregations results are calculated by \nIncrementalAttributeAggregator\ns \nand stored in such as way that allows proper data composition upon retrial, for example \navg()\n is stored as \nsum\n and \ncount\n. \nThis allows data composition across various granularity time durations when retrieving, for example results for \navg()\n composed by returning sum of \nsum\ns divided by the sum of \ncount\ns. \nAggregation can also work in a distributed manner and across system restarts. This is done by storing node specific IDs and granularity time duration information in the tables. \nTo make sure tables do not go out of memory \nIncrementalDataPurging\n \nis used to purge old data. \n\n\nWhen aggregation is queried through join or store query for a given time granularity it reads the data \nfrom the in-memory \nBaseIncrementalValueStore\n and from the tables, computes the composite results as described, and presents the results. \n\n\nSiddhi Event Formats\n\n\nSiddhi has three event formats. \n\n\n\n\n\n\nEvent\n \n\n\nThis is the format exposed to external systems when they send events via Input Handler, and consume events via Stream Callback or Query Callback.\nThis consists of a \ntimestamp\n and an \nObject[]\n that contains all the values in accordance to the corresponding stream. \n\n\n\n\n\n\nStreamEvent\n (Subtype of \nComplexEvent\n)\n\n\nThis is used within queries. This contains a \ntimestamp\n and the following three \nObject[]\ns: \n\n\n\n\nbeforeWindowData\n: This contains values that are only used in processors that are executed before the \nWindowProcessor\n.\n\n\nonAfterWindowData\n: This contains values that are only used by the \nWindowProcessor\n and the other processors that follow it, but not sent as output.\n\n\noutputData\n: This contains the values that are sent via the output stream of the query.\n\n\n\n\nIn order to optimize the amount of data that is stored in the in-memory at windows, the content in \nbeforeWindowData\n is cleared before the \nevent enters the \nWindowProcessor\n. StreamEvents can also be chained by linking each other via the \nnext\n property in them. \n\n\n\n\n\n\nStateEvent\n (Subtype of \nComplexEvent\n)\n\n\nThis is used in joins, patterns and sequences queries when we need to associate events of multiple streams, tables, windows or aggregations together.\nThis contains a \ntimestamp\n, a collection of \nStreamEvent\ns representing different streams, tables, etc, that are used in the query, and an \nObject[]\n to contain \noutputData\n values that is needed for query output. \nThe \nStreamEvent\ns within the \nStateEvent\n, and the \nStateEvent\n themselves can be chained by linking each other with the \nnext\n property in them. \n\n\n\n\n\n\nEvent Chunks\n\n\nEvent Chunks provide an easier way of manipulating the chain of \nStreamEvent\ns and \nStateEvent\ns so that they are be easily iterated, inserted and removed. \n\n\nSummary\n\n\nThis article focuses on describing the architecture of Siddhi and rationalizing some of the architectural decisions made when implementing the system.\nIt also explains the key features of Siddhi. \nWe hope this will be a good starting point for new developers to understand Siddhi and to start contributing to it.", 
            "title": "Siddhi Architecture"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#siddhi-5x-architecture", 
            "text": "Siddhi is an open source, cloud native, stream processing and complex event processing engine, and it can be utilized in any of the following ways:   Run as a server on its own  Run with  WSO2 Stream Processor  as a service  Embedded into any Java or Python based application  Run on an Android application   Siddhi provides streaming data integration and data analytical operators. It connects multiple disparate live data sources, \norchestrates data flows, calculates analytics, and also detects complex event patterns. This allows developers to build \napplications that collect data, performs data transformation and analytics, and publish the results to data sinks in real time.   Info  Please find the Siddhi 4.x Architecture  here   This section illustrates the architecture of Siddhi Engine and guides you through its key functionality. We hope this article \nhelps developers to understand Siddhi and its codebase better, and also help them to contribute and improve Siddhi.", 
            "title": "Siddhi 5.x Architecture"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#main-design-decisions", 
            "text": "Event by event processing of real-time streaming data to achieve low latency.   Ease of use with Streaming SQL providing an intuitive way to express stream processing logic and complex \nevent processing constructs such as Patterns.   Achieve high performance by processing events in-memory and using data stores for long term data storage.   Optimize performance by enforcing a strict event stream schema and by pre-compiling the queries.  Optimize memory consumption by having only the absolutely necessary information in-memory and dropping the rest as soon as possible.   Supporting multiple extension points to accommodate a diverse set of functionality such as supporting multiple sources, sinks, functions, \naggregation operations, windows, etc.", 
            "title": "Main Design Decisions"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#high-level-architecture", 
            "text": "At a high level, Siddhi consumes events from various events sources, processes them according to the defined Siddhi application, \nand produces results to the subscribed event sinks. \nSiddhi can store and consume events from in-memory tables or from external data stores such as  RDBMS ,  MongoDB ,  Hazelcast  in-memory grid, etc. (i.e., when configured to do so). Siddhi also allows applications and users to query Siddhi via its Store Query API to interactively \nretrieve data from in-memory and other stores.", 
            "title": "High Level Architecture"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#main-modules-in-siddhi-engine", 
            "text": "Siddhi Engine comprises four main modules, they are:     Siddhi Query API  : This allows users to define the execution logic of the Siddhi application as queries and definitions using POJOs (Plan Old Java Objects). \nInternally, Siddhi uses these objects to identify the logic that it is expected to perform.     Siddhi Query Compiler  : This allows users to define the Siddhi application using the Siddhi Streaming SQL, \n and it compiles the Streaming SQL script to Siddhi Query API POJOs so that Siddhi can execute them.     Siddhi Core  : This builds the execution runtime based on the defined Siddhi Application POJOs and processes the incoming events as and when they arrive.     Siddhi Annotation  : This is a helper module that allows all extensions to be annotated, so that they can be \npicked by Siddhi Core for processing. This also helps Siddhi to generate the extension documentation.", 
            "title": "Main Modules in Siddhi Engine"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#siddhi-component-architecture", 
            "text": "The following diagram illustrates the main components of Siddhi and how they work together.    Here the  Siddhi Core  module maintains\nthe execution logic. It also interacts with the external environment and systems \nfor consuming, processing and publishing events. It uses the following components achieve its tasks:      SiddhiManager  : \n  This is a key component of Siddhi Core that manages Siddhi Application Runtimes \n  and facilitates their functionality via Siddhi Context with periodic state persistence, \n  statistics reporting and extension loading. It is recommended to use one Siddhi Manager for a single JVM.      SiddhiAppRuntime  : \n Siddhi Application Runtime can be generated for each Siddhi Application through the Siddhi Manager. Siddhi Application Runtimes\n provide an isolated execution environment for each defined Siddhi Application. These Siddhi Application Runtimes can have their one lifecycle and they execute \n based on the logic defined in their Siddhi Application.     SiddhiContext  : \nThis is a shared object across all the Siddhi Application Runtimes within the same Siddhi manager. It contains references \nto the persistence store for periodic persistence, statistics manager to report performance statistics of Siddhi Application Runtimes, \nand extension holders for loading Siddhi extensions.", 
            "title": "Siddhi Component Architecture"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#siddhi-application-creation", 
            "text": "Execution logic if the Siddhi Engine is composed as a Siddhi Application, and this is usually passed as a string to  SiddhiManager  to create the  SiddhiAppRuntime  for execution.   When a Siddhi Application is passed to the  SiddhiManager.createSiddhiAppRuntime() , it is processed internally with the  SiddhiCompiler . \nHere, the  SiddhiApp  String is compiled to  SiddhiApp \n object model by the  SiddhiQLBaseVisitorImpl  class. \n This validates the syntax of the given Siddhi Application. The model is then passed to the  SiddhiAppParser  \nto create the  SiddhiAppRuntime . During this phase the semantics of the Siddhi Application is validated and the execution logic of the Siddhi Application is optimized.", 
            "title": "Siddhi Application Creation"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#siddhi-app-execution-flow", 
            "text": "Following diagram depicts the execution flow within a Siddhi App Runtime.    The path taken by events within Siddhi Engine is indicated in blue.   The components that are involved in handling the events are following:     StreamJunction  This routes events of a particular stream to various components within the Siddhi App Runtime. A stream junction is\ngenerated for each defined or inferred Stream in the Siddhi Application. A stream junction by default uses the incoming event's thread\nand passes all the events to its subscribed components as soon as they arrive, but this behaviour can be altered by configuring  @Async  \nannotation to buffer the events at the and stream junction and to use another one or more threads to collect the events from the buffer \nand process the subsequent executions.    InputHandler    Input handler is used to push  Event  and  Event[]  objects into stream junctions from defined event sources, and from Java/Python programmes.     StreamCallback    This receives  Event[] s from stream junction and passes them to event sinks to publish to external endpoints, \nand/or passes them to subscribed Java/Python programmes for further processing.     Queries     Partitions    These components process events by filtering, transforming, aggregation, joining, patten matching, \netc. They consume events from one or more stream junctions, process them and publish the processed events\ninto a set of stream junctions based on the defined queries or partitions.     Source    Sources consume events from external sources in various data formats, convert them into Siddhi events using  SourceMapper s \nand pass them to corresponding stream junction via their associated input handlers. A source is generated \nfor each  @Source  annotation defined above a stream definition.     SourceMapper    A source mapper is a sub component of source, and it needs to be configured for each source in order to convert the incoming event into Siddhi event. \nThe source mapper type can be configured using the  @Map  annotation within the  @Source  annotation. When the  @Map  annotation is\nnot defined, Siddhi uses the  PassThroughSourceMapper ,\nwhere it assumes that the incoming message is already in the  Siddhi Event  \nformat (i.e  Event  or  Event[] ), and therefore makes no changes to the incoming event format.    Sink    Sinks consumes events from its associated stream junction, convert them to various data formats via  SinkMapper  \nand publish them to external endpoints as defined in the  @Sink  annotation. A sink is generated for each  @Sink  annotation defined above a stream definition.     SinkMapper  A sink mapper is a sub component of sink. and its need to be configured for each sink in order to map the Siddhi events to the specified data format so that they \ncan be published via the sink. The sink mapper type can be configured using the  @Map  annotation within the  @Sink \nannotation. When the  @Map  annotation is not defined, Siddhi uses  PassThroughSinkMapper , \nwhere it passes the  Siddhi Event  \n(i.e  Event  or  Event[] ) without any formatting to the Sink.    Table  Tables are used to store events. When tables are defined by default, Siddhi uses the  InMemoryTable  \nimplementation to store events in-memory. When  @Store  annotation\nis used on top of the table definition, it loads the associated external data store connector based on the defined  store  type. Most table implementations are \nextended from either  AbstractRecordTable  \nor  AbstractQueryableRecordTable  abstract classes\nthe former provides functionality to query external data store based on a given filtering condition, and the latter queries external data store by providing projection, limits, and ordering parameters in addition to data filter condition.    Window  Windows store events as and when they arrive and automatically expire/clean them based on the given window constrain. Multiple types of windows are\ncan be implemented by extending the  WindowProcessor  \nabstract class.     IncrementalAggregation    Long running time series aggregates defined via the aggregation definition is calculated in an incremental manner using the Incremental Aggregation Processor for the defined time periods.\nIncremental aggregation functions can be implemented by extending  IncrementalAttributeAggregator . \nBy default, incremental aggregations aggregate all the values in-memory, but when its associated with a store by adding  @store  \nannotation it uses in-memory to aggregate partial results and use data stores to persist those increments. When requested for aggregate results it \nretrieves data from data stores and (if needed from) in-memory, computes combined aggregate results and provide as the output.     Trigger  A trigger triggers events at a given interval as given in the trigger definition. The triggered events are pushed to a stream junction having the same name as the trigger.    QueryCallback  A query callback taps in to the events that are emitted by a particular query. It notifies the event occurrence  timestamp , and classifies \nthe output events into  currentEvents , and  expiredEvents .", 
            "title": "Siddhi App Execution Flow"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#siddhi-query-execution", 
            "text": "Siddhi  QueryRuntimes \n can be categorized in to three main types:     SingleInputStream : \n Queries that consist of query types such as filters and windows.    JoinInputStream :\n  Queries that consist of joins.    StateInputStream : \n   Queries that consist of patterns and sequences.     Following section explains the internals of each query type.", 
            "title": "Siddhi Query Execution"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#singleinputstream-query-runtime-filter-windows", 
            "text": "A single input stream query runtime is generated for filter and window queries. They consume events from a stream junction or a window\nand convert the incoming events according to the expected output stream format at the  ProcessStreamReceiver \nby dropping all the unrelated incoming stream attributes.  Then the converted events are passed through a few Processors such as  FilterProcessor , StreamProcessor ,  StreamFunctionProcessor ,  WindowProcessor \nand  QuerySelector . \nHere, the  StreamProcessor ,  StreamFunctionProcessor , and  WindowProcessor  can be extended with various stream processing capabilities. \nThe last processor of the chain of processors must always be a  QuerySelector  and it can't appear anywhere else. When the query runtime consumes events from a stream,\nits processor chain can maximum contain one  WindowProcessor , and when query runtime consumes events from a window, its chain of processors cannot \ncontain any  WindowProcessor .  The  FilterProcessor  is implemented using expressions that returns a boolean value.  ExpressionExecutor  \nis used to process conditions, mathematical operations, unary operations, constant values, variables, and functions. Expressions have a tree structure, and \nthey are processed based using the Depth First search algorithm. To achieve high performance, Siddhi currently depends on the user\nto formulate the least successful case in the leftmost side of the condition, thereby increasing the chance of an early  false  detection.  The condition expression  price  = 100 and ( Symbol == 'IBM' or Symbol == 'MSFT' )  is represented as shown below.   These expressions also support the execution of user defined functions (UDFs), and they can be implemented by extending the  FunctionExecutor  class.   After getting processed by all the processors events reach the  QuerySelector  for transformation. At the  QuerySelector ,\nevents are transformed based on the  select  clause of the query. The  select  clause produced one  AttributeProcessor  for each output stream attribute, and these  AttributeProcessor s contain expressions defining data transformation including constant values, variables, user defined functions, etc. \nThey can also contain  AttributeAggregatorExecutor s\nto process aggregation operations such as  sum ,  count , etc. If there is a  Group By  clause defined, then the  GroupByKeyGenerator \nis used to identify the composite group-by key, and then for each key an  AttributeAggregatorExecutor  state is generated to maintain per group-by key aggregations. \nWhen each time  AttributeProcessor  \nis executed the  AttributeAggregatorExecutor  calculates per group-by aggregation results and output the values. When  AttributeAggregatorExecutor  group-by states become\nobsolete, they are destroyed and automatically cleaned.   After an event is transformed to the output format through the above process, it is evaluated against the having condition executor if a  having  clause is \nprovided. The succeeding events are then ordered, and limited based on  order by ,  limit  and  offset  clauses, \nbefore they pushed to the  OutputRateLimiter .   At  OutputRateLimiter , the event output is controlled before sending the events to the stream junction or to the query callback. \nWhen the  output  clause is not defined, the  PassThroughOutputRateLimiter  is used by passing all the events without any rate limiting.", 
            "title": "SingleInputStream Query Runtime (Filter &amp; Windows)"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#temporal-processing-with-windows", 
            "text": "The temporal event processing aspect is achieved via  Window \nand  AttributeAggregators  To achieve temporal processing, Siddhi uses the following four type of events:     Current Events : Events that are newly arriving to the query from streams.    Expired Events : Events that have expired from a window.     Timer Events : Events that inform the query about an update of execution time. These events are usually generated by schedulers.     Reset Events : Events that resets the Siddhi query states.    In Siddhi, when an event comes into a  WindowProcessor , \nit creates an appropriate  expired event  corresponding to the incoming  current event  with the expiring timestamp, and stores that \nevent in the window. At the same time  WindowProcessor  also forwards the  current event  to the next processor for further processing. \nIt uses a scheduler or some other counting approach to determine when to emit the events that are stored in in-memory. When the  expired events  meets the condition for expiry based on the window contains, it emits the  expired events  to the next processor. \nAt times like in  window.timeBatch()  there can be cases that needs to emit all the events in-memory at once and the output does not need individual  expired events  values, in this cases the window emits a single  reset event  instead of sending one  expired event  for each event it has stored, \nso that it can reset the states in one go. For the  QuerySelector  aggregations to work correctly the window must emit a corresponding  expired event  for each  current event  it has emitted or it must send a  reset event . \nIn the  QuerySelector , the arrived  current events  increase the aggregation values,  expired events  decrease the values, and  reset events  reset the aggregation calculation to produce correct query output.   For example, the sliding  TimeWindow \n( window.time() ) creates a corresponding  expired event  for each  current event  that arrives, adds the  expired event s to \nthe window, adds an entry to the scheduler to notify when that event need to be expired, and finally sends the  current event  to the next processor for subsequent processing. \nThe scheduler notifies the window by sending a  timer event , and when the window receives an indication that the expected expiry time has come for the oldest event in the window via a \na  timer event  or by other means, it removes the  expired event  from the window and passes that to the next processor.", 
            "title": "Temporal Processing with Windows"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#joininputstream-query-runtime-join", 
            "text": "Join input stream query runtime is generated for join queries. This can consume events from two stream junctions and perform a join operation as depicted above. \nIt can also perform a join by consuming events from one stream junction and join against itself, or it can also join against a \ntable, window or an aggregation. When a join is performed with a table, window or aggregation,\nthe  WindowProcessor  in the above image is replaced with the corresponding table, window or aggregation and no basic processors are used on their side.   The joining operation is triggered by the events that arrive from the stream junction.\nHere, when an event from one stream reaches the pre  JoinProcessor , \nit matches against all the available events of the other stream's  WindowProcessor . \nWhen a match is found, those matched events are sent to the  QuerySelector  as  current events , and at the same time, \nthe original event is added to the  WindowProcessor  where it remains until it expires. Similarly, when an \nevent expires from the  WindowProcessor , it matches against all the available events of the other stream's  WindowProcessor , and \nwhen a match is found, those matched events are sent to the  QuerySelector  as  expired events .   Note  Despite the optimizations, a join query is quite expensive when it comes to performance. This is because the  WindowProcessor  \nis locked during the matching process to avoid race conditions and to achieve accuracy while joining. Therefore, when possible avoid \nmatching large (time or length) windows in high volume streams.", 
            "title": "JoinInputStream Query Runtime (Join)"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#stateinputstream-query-runtime-pattern-sequence", 
            "text": "The state input stream query runtime is generated for pattern and sequence queries. This consumes events from one or more stream junctions \nvia  ProcessStreamReceiver s\nand checks whether the events matches each pattern or sequence condition by processing the set of basic processors associated with each  ProcessStreamReceiver . \nThe  PreStateProcessor s usually contains lists of state events that are already matched by previous conditions, and if its the first condition \nthen it will have an empty state event in its list. When  ProcessStreamReceiver  consumes an event, it passes the event \nto the  PreStateProcessor  which updates the list of state events it has with the incoming event and executes the condition by passing the events to the basic processors. \nThe state events that matches the conditions reaches the  PostStateProcessor  which will then stores the events to the state event list of the following  PreStateProcessor .\nIf it is the final condition's  PostStateProcessor , then it will pass the state event to the  QuerySelector  to generate and emit the output.", 
            "title": "StateInputStream Query Runtime (Pattern &amp; Sequence)"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#siddhi-partition-execution", 
            "text": "A partition is a wrapper around one or more Siddhi queries and inner streams that connect them. \nA partition is implemented in Siddhi as a  PartitionRuntime \nwhich contains multiple  QueryRuntime s and inner stream junctions. \nEach partitioned stream entering the partition goes through a designated  PartitionStreamReceiver .\nThe  PartitionExecutor \nof  PartitionStreamReceiver  evaluates the incoming events to identify their associated partition-key using either  RangePartitionExecutor \nor  ValuePartitionExecutor . \nThe identified partition-key is then set as thread local variable and the event is passed to the  QueryRuntime s of processing. \nThe  QueryRuntime s process events by maintaining separate states for each partition-key such that producing separate output per partition.\nWhen a partition query consumes a non partitioned global stream, the  QueryRuntime s are executed for each available partition-key in the system such that \nallowing all partitions to receive the same event. When the partitions are obsolete  PartitionRuntime  deletes all the partition states from its  QueryRuntime s.", 
            "title": "Siddhi Partition Execution"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#siddhi-aggregation", 
            "text": "Siddhi supports long duration time series aggregations via its aggregation definition.  AggregationRuntime  \nimplements this by the use of  streaming lambda architecture , where it process part of the data in-memory and gets part of the data from data stores.  AggregationRuntime  creates an in-memory table or external store for each time granularity (i.e seconds, minutes, days, etc) it has to process the events, \nand when events enters it calculates the aggregations in-memory for its least granularity (usually seconds) using the  IncrementalExecutor  \nand maintains the running aggregation values in its  BaseIncrementalValueStore . \nAt each clock end time of the granularity (end of each second)  IncrementalExecutor  stores the summarized values to the associated granularity \ntable and also passes the summarized values to the  IncrementalExecutor  of the next granularity level, which also follows \nthe same methodology in processing the events. Through this approach each time granularities, the current time duration will be in-memory and all the historical time durations \nwill be in stored in the tables.   The aggregations results are calculated by  IncrementalAttributeAggregator s \nand stored in such as way that allows proper data composition upon retrial, for example  avg()  is stored as  sum  and  count . \nThis allows data composition across various granularity time durations when retrieving, for example results for  avg()  composed by returning sum of  sum s divided by the sum of  count s. \nAggregation can also work in a distributed manner and across system restarts. This is done by storing node specific IDs and granularity time duration information in the tables. \nTo make sure tables do not go out of memory  IncrementalDataPurging  \nis used to purge old data.   When aggregation is queried through join or store query for a given time granularity it reads the data \nfrom the in-memory  BaseIncrementalValueStore  and from the tables, computes the composite results as described, and presents the results.", 
            "title": "Siddhi Aggregation"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#siddhi-event-formats", 
            "text": "Siddhi has three event formats.     Event    This is the format exposed to external systems when they send events via Input Handler, and consume events via Stream Callback or Query Callback.\nThis consists of a  timestamp  and an  Object[]  that contains all the values in accordance to the corresponding stream.     StreamEvent  (Subtype of  ComplexEvent )  This is used within queries. This contains a  timestamp  and the following three  Object[] s:    beforeWindowData : This contains values that are only used in processors that are executed before the  WindowProcessor .  onAfterWindowData : This contains values that are only used by the  WindowProcessor  and the other processors that follow it, but not sent as output.  outputData : This contains the values that are sent via the output stream of the query.   In order to optimize the amount of data that is stored in the in-memory at windows, the content in  beforeWindowData  is cleared before the \nevent enters the  WindowProcessor . StreamEvents can also be chained by linking each other via the  next  property in them.     StateEvent  (Subtype of  ComplexEvent )  This is used in joins, patterns and sequences queries when we need to associate events of multiple streams, tables, windows or aggregations together.\nThis contains a  timestamp , a collection of  StreamEvent s representing different streams, tables, etc, that are used in the query, and an  Object[]  to contain  outputData  values that is needed for query output. \nThe  StreamEvent s within the  StateEvent , and the  StateEvent  themselves can be chained by linking each other with the  next  property in them.     Event Chunks  Event Chunks provide an easier way of manipulating the chain of  StreamEvent s and  StateEvent s so that they are be easily iterated, inserted and removed.", 
            "title": "Siddhi Event Formats"
        }, 
        {
            "location": "/documentation/siddhi-5.x/architecture-5.x/#summary", 
            "text": "This article focuses on describing the architecture of Siddhi and rationalizing some of the architectural decisions made when implementing the system.\nIt also explains the key features of Siddhi. \nWe hope this will be a good starting point for new developers to understand Siddhi and to start contributing to it.", 
            "title": "Summary"
        }, 
        {
            "location": "/documentation/siddhi-4.x/quckstart-4.x/", 
            "text": "Siddhi 4.x Quick Start Guide\n\n\n\n\nInfo\n\n\nPlease find the latest Siddhi Quick Start Guide \nhere\n\n\n\n\nSiddhi\n is a 100% open source Java library that is thoroughly optimized for high performance. \nIt performs \nStream Processing\n and \nComplex Event Processing\n on real time data streams. \n\n\nSiddhi is used by many companies including Uber and eBay (via Apache Eagle). \nUber processes more than 20 billion \nevents per day using Siddhi\n for fraud analytics, and Siddhi is used in Apache Eagle as a policy enforcement engine.\n\n\nThis quick start guide contains the following six sections:\n\n\n\n\nStream Processing and Complex Event Processing Overview - about the \ndomain\n of Siddhi\n\n\nAn Overview of Siddhi - Explaining the basic \narchitecture\n\n\nUsing Siddhi for the First Time - how to \nset up\n the software\n\n\nSiddhi \u2018Hello World!\u2019 - Your \nFirst Siddhi Application\n\n\nSimulating Events - \nTesting\n your query with simulated events\n\n\nA Bit of Stream Processing - \ntemporal event processing\n\n\n\n\n1. Stream Processing and Complex Event Processing (CEP) Overview\n\n\nBefore diving into using Siddhi, let's first discuss Stream Processing \nand Complex Event Processing in brief so that we can identify the use-cases where Siddhi can be used.\n\n\nFirst let's understand what an event is through an example. \nIf we consider the transactions carried out via an ATM as a data \nstream, one withdrawal from it can be considered an event\n. This event contains data about the amount, time, account number etc. \nMany such transactions form a stream.\n\n\n\n\nForrester\n defines Streaming Analytics as:\n\n\n\n\nSoftware that provides analytical operators to \norchestrate data flow\n, \ncalculate analytics\n, and \ndetect patterns\n on \nevent data \nfrom multiple, disparate live data sources\n to allow developers to build applications that \nsense, think, \nand act in real time\n.\n\n\n\n\nGartner\u2019s IT Glossary\n defines CEP as follows:\n\n\n\n\n\"CEP is a kind of computing in which \nincoming data about events is distilled into more useful, higher level \u201ccomplex\u201d \nevent data\n that provides insight into what is happening.\"\n\n\n\"\nCEP is event-driven\n because the computation is triggered by the receipt of event data. CEP is used for highly \ndemanding, continuous-intelligence applications that enhance situation awareness and support real-time decisions.\"\n\n\n\n\n\n\nBasically, Siddhi receives data event-by-event and processes them in real time to produce meaningful information.\n\n\nSiddhi Can be used in the following use-cases:\n\n\n\n\nFraud Analytics \n\n\nMonitoring \n\n\nAnomaly Detection\n\n\nSentiment Analysis\n\n\nProcessing Customer Behaviour\n\n\n.. etc\n\n\n\n\n2. Overview of Siddhi\n\n\n\n\nAs indicated above, Siddhi can:\n\n\n\n\naccept event inputs from many different types of sources\n\n\nprocess them to generate insights\n\n\npublish them to many types of sinks.\n\n\n\n\nTo use Siddhi, you need to write the processing logic as a \nSiddhi Application\n in the \nSiddhi Streaming SQL\n \nlanguage which is discussed in the 4th section. After writing and starting \na Siddhi application\n, it:\n\n\n\n\nTakes data one-by-one as events\n\n\nProcesses the data in each event\n\n\nGenerates new high level events based on the processing done so far\n\n\nSends newly generated events as the output to streams.\n\n\n\n\n3. Using Siddhi for the First Time\n\n\nIn this section, we will be using the WSO2 Stream Processor(referred to as SP in the rest of this guide)\u200a\u2014\u200aa server version of Siddhi that has a\nsophisticated editor with a GUI (referred to as \n\u201cStream Processor Studio\u201d\n) where you can write your query and simulate events\nas a data stream.\n\n\nStep 1\n\u200a\u2014\u200aInstall \n\nOracle Java SE Development Kit (JDK)\n version 1.8. \n\n\nStep 2\n\u200a\u2014\u200a\nSet the JAVA_HOME\n environment \nvariable. \n\n\nStep 3\n\u200a\u2014\u200aDownload the latest \nWSO2 Stream Processor\n. \n\n\nStep 4\n\u200a\u2014\u200aExtract the downloaded zip and navigate to \nSP_HOME\n/bin\n. \n (\nSP_HOME\n refers to the extracted folder) \n\n\nStep 5\n\u200a\u2014\u200aIssue the following command in the command prompt (Windows) / terminal (Linux) \n\n\nFor Windows: editor.bat\nFor Linux: ./editor.sh\n\n\n\n\n\nFor more details about WSO2 Stream Processor, see its \nQuick Start Guide\n.\n\n\nAfter successfully starting the Stream Processor Studio, the terminal in Linux should look like as shown below:\n\n\n\n\nAfter starting the WSO2 Stream Processor, access the Stream Processor Studio by visiting the following link in your browser.\n\n\nhttp://localhost:9390/editor\n\n\n\n\n\nThis takes you to the Stream Processor Studio landing page.\n\n\n\n\n4. Siddhi \u2018Hello World!\u2019\u200a\u2014\u200aYour First Siddhi Application\n\n\nSiddhi Streaming SQL is a rich, compact, easy-to-learn SQL-like language. \nLet's first learn how to find the total\n of values \ncoming into a data stream and output the current running total value with each event. Siddhi has lot of in-built functions and extensions \navailable for complex analysis, but to get started, let's use a simple one. You can find more information about the Siddhi grammar \nand its functions in the \nSiddhi Query Guide\n.\n\n\nLet's \nconsider a scenario where we are loading cargo boxes into a ship\n. We need to keep track of the total \nweight of the cargo added. \nMeasuring the weight of a cargo box when loading is considered an event\n.\n\n\n\n\nWe can write a Siddhi program for the above scenario which has \n4 parts\n.\n\n\nPart 1\u200a\u2014\u200aGiving our Siddhi application a suitable name.\n This is a Siddhi routine. In this example, let's name our application as \n\n\u201cHelloWorldApp\u201d\n\n\n@App:name(\nHelloWorldApp\n)\n\n\n\n\n\nPart 2\u200a\u2014\u200aDefining the input stream.\n The stream needs to have a name and a schema defining the data that each incoming event should contain.\nThe event data attributes are expressed as name and type pairs. In this example:\n\n\n\n\nThe name of the input stream\u200a\u2014\u200a\n\u201cCargoStream\u201d\n \n\nThis contains only one data attribute:\n\n\nThe name of the data in each event\u200a\u2014\u200a\n\u201cweight\u201d\n\n\nType of the data \n\u201cweight\u201d\n\u200a\u2014\u200aint\n\n\n\n\ndefine stream CargoStream (weight int);\n\n\n\n\n\nPart 3 - Defining the output stream.\n This has the same info as the previous definition with an additional \n\ntotalWeight\n attribute that contains the total weight calculated so far. Here, we need to add a \n\n\"sink\"\n  to log the \nOutputStream\n so that we can observe the output values. (\nSink is the Siddhi way to publish \nstreams to external systems.\n This particular \nlog\n type sink just logs the stream events. To learn more about sinks, see \n\nsink\n)\n\n\n@sink(type=\nlog\n, prefix=\nLOGGER\n)\ndefine stream OutputStream(weight int, totalWeight long);\n\n\n\n\n\nPart 4\u200a\u2014\u200aThe actual Siddhi query.\n Here we need to specify the following:\n\n\n\n\nA name for the query\u200a\u2014\u200a\n\u201cHelloWorldQuery\u201d\n\n\nWhich stream should be taken into processing\u200a\u2014\u200a\n\u201cCargoStream\u201d\n\n\nWhat data we require in the output stream\u200a\u2014\u200a\n\u201cweight\u201d\n, \n\u201ctotalWeight\u201d\n\n\nHow the output should be calculated - by calculating the \nsum\n of the the \nweight\ns  \n\n\nWhich stream should be populated with the output\u200a\u2014\u200a\n\u201cOutputStream\u201d\n\n\n\n\n@info(name=\nHelloWorldQuery\n)\nfrom CargoStream\nselect weight, sum(weight) as totalWeight\ninsert into OutputStream;\n\n\n\n\n\n\n\n5. Simulating Events\n\n\nThe Stream Processor Studio has in-built support to simulate events. You can do it via the \n\u201cEvent Simulator\u201d\n \npanel at the left of the Stream Processor Studio. You should save your \nHelloWorldApp\n by browsing to \nFile\n -\n \n\nSave\n before you run event simulation. Then click  \nEvent Simulator\n and configure it as shown below.\n\n\n\n\nStep 1\u200a\u2014\u200aConfigurations:\n\n\n\n\nSiddhi App Name\u200a\u2014\u200a\n\u201cHelloWorldApp\u201d\n\n\nStream Name\u200a\u2014\u200a\n\u201cCargoStream\u201d\n\n\nTimestamp\u200a\u2014\u200a(Leave it blank)\n\n\nweight\u200a\u2014\u200a2 (or some integer)\n\n\n\n\nStep 2\u200a\u2014\u200aClick \u201cRun\u201d mode and then click \u201cStart\u201d\n. This starts the Siddhi Application. \nIf the Siddhi application is successfully started, the following message is printed in the Stream Processor Studio console:\n\n\n\u201cHelloWorldApp.siddhi Started Successfully!\u201d\n \n\n\nStep 3\u200a\u2014\u200aClick \u201cSend\u201d and observe the terminal\n where you started WSO2 Stream Processor Studio. \nYou can see a log that contains \n\u201coutputData=[2, 2]\u201d\n. Click \nSend\n again and observe a log with \n\n\u201coutputData=[2, 4]\u201d\n. You can change the value of the weight and send it to see how the sum of the weight is updated.\n\n\n\n\nBravo! You have successfully completed creating Siddhi Hello World! \n\n\n6. A Bit of Stream Processing - \ntemporal event processing\n\n\nThis section demonstrates how to carry out \ntemporal window processing\n with Siddhi.\n\n\nUp to this point, we have been carrying out the processing by having only the running sum value in-memory. \nNo events were stored during this process. \n\n\nWindow processing\n\nis a method that allows us to store some events in-memory for a given period so that we can perform operations \nsuch as calculating the average, maximum, etc values within them.\n\n\nLet's imagine that when we are loading cargo boxes into the ship \nwe need to keep track of the average weight of \nthe recently loaded boxes\n so that we can balance the weight across the ship. \nFor this purpose, let's try to find the \naverage weight of last three boxes\n of each event.\n\n\n\n\nFor window processing, we need to modify our query as follows:\n\n\n@info(name=\nHelloWorldQuery\n) \nfrom CargoStream#window.length(3)\nselect weight, sum(weight) as totalWeight, avg(weight) as averageWeight\ninsert into OutputStream;\n\n\n\n\n\n\n\nfrom CargoStream#window.length(3)\n - Here, we are specifying that the last 3 events should be kept in memory for processing.\n\n\navg(weight) as averageWeight\n - Here, we are calculating the average of events stored in the window and producing the \naverage value as \n\"averageWeight\"\n (Note: Now the \nsum\n also calculates the \ntotalWeight\n based on the last three events).\n\n\n\n\nWe also need to modify the \n\"OutputStream\"\n definition to accommodate the new \n\"averageWeight\"\n.\n\n\ndefine stream OutputStream(weight int, totalWeight long, averageWeight double);\n\n\n\n\n\nThe updated Siddhi Application should look as shown below:\n\n\n\n\nNow you can send events using the Event Simulator and observe the log to see the sum and average of the weights of the last three \ncargo events.\n\n\nIt is also notable that the defined \nlength window\n only keeps 3 events in-memory. When the 4th event arrives, the \nfirst event in the window is removed from memory. This ensures that the memory usage does not grow beyond a specific limit. There are also other \nimplementations done in Siddhi  to reduce the memory consumption. For more information, see \nSiddhi Architecture\n.\n\n\nTo learn more about the Siddhi functionality, see \nSiddhi Query Guide\n.\n\n\nFeel free to try out Siddhi and event simulation to understand Siddhi better.\n\n\nIf you have questions please post them to the \nStackoverflow\n with \n\"Siddhi\"\n tag.", 
            "title": "Quick Start Guide"
        }, 
        {
            "location": "/documentation/siddhi-4.x/quckstart-4.x/#siddhi-4x-quick-start-guide", 
            "text": "Info  Please find the latest Siddhi Quick Start Guide  here   Siddhi  is a 100% open source Java library that is thoroughly optimized for high performance. \nIt performs  Stream Processing  and  Complex Event Processing  on real time data streams.   Siddhi is used by many companies including Uber and eBay (via Apache Eagle).  Uber processes more than 20 billion \nevents per day using Siddhi  for fraud analytics, and Siddhi is used in Apache Eagle as a policy enforcement engine.  This quick start guide contains the following six sections:   Stream Processing and Complex Event Processing Overview - about the  domain  of Siddhi  An Overview of Siddhi - Explaining the basic  architecture  Using Siddhi for the First Time - how to  set up  the software  Siddhi \u2018Hello World!\u2019 - Your  First Siddhi Application  Simulating Events -  Testing  your query with simulated events  A Bit of Stream Processing -  temporal event processing", 
            "title": "Siddhi 4.x Quick Start Guide"
        }, 
        {
            "location": "/documentation/siddhi-4.x/quckstart-4.x/#1-stream-processing-and-complex-event-processing-cep-overview", 
            "text": "Before diving into using Siddhi, let's first discuss Stream Processing \nand Complex Event Processing in brief so that we can identify the use-cases where Siddhi can be used.  First let's understand what an event is through an example.  If we consider the transactions carried out via an ATM as a data \nstream, one withdrawal from it can be considered an event . This event contains data about the amount, time, account number etc. \nMany such transactions form a stream.   Forrester  defines Streaming Analytics as:   Software that provides analytical operators to  orchestrate data flow ,  calculate analytics , and  detect patterns  on \nevent data  from multiple, disparate live data sources  to allow developers to build applications that  sense, think, \nand act in real time .   Gartner\u2019s IT Glossary  defines CEP as follows:   \"CEP is a kind of computing in which  incoming data about events is distilled into more useful, higher level \u201ccomplex\u201d \nevent data  that provides insight into what is happening.\"  \" CEP is event-driven  because the computation is triggered by the receipt of event data. CEP is used for highly \ndemanding, continuous-intelligence applications that enhance situation awareness and support real-time decisions.\"    Basically, Siddhi receives data event-by-event and processes them in real time to produce meaningful information.  Siddhi Can be used in the following use-cases:   Fraud Analytics   Monitoring   Anomaly Detection  Sentiment Analysis  Processing Customer Behaviour  .. etc", 
            "title": "1. Stream Processing and Complex Event Processing (CEP) Overview"
        }, 
        {
            "location": "/documentation/siddhi-4.x/quckstart-4.x/#2-overview-of-siddhi", 
            "text": "As indicated above, Siddhi can:   accept event inputs from many different types of sources  process them to generate insights  publish them to many types of sinks.   To use Siddhi, you need to write the processing logic as a  Siddhi Application  in the  Siddhi Streaming SQL  \nlanguage which is discussed in the 4th section. After writing and starting  a Siddhi application , it:   Takes data one-by-one as events  Processes the data in each event  Generates new high level events based on the processing done so far  Sends newly generated events as the output to streams.", 
            "title": "2. Overview of Siddhi"
        }, 
        {
            "location": "/documentation/siddhi-4.x/quckstart-4.x/#3-using-siddhi-for-the-first-time", 
            "text": "In this section, we will be using the WSO2 Stream Processor(referred to as SP in the rest of this guide)\u200a\u2014\u200aa server version of Siddhi that has a\nsophisticated editor with a GUI (referred to as  \u201cStream Processor Studio\u201d ) where you can write your query and simulate events\nas a data stream.  Step 1 \u200a\u2014\u200aInstall  Oracle Java SE Development Kit (JDK)  version 1.8.   Step 2 \u200a\u2014\u200a Set the JAVA_HOME  environment \nvariable.   Step 3 \u200a\u2014\u200aDownload the latest  WSO2 Stream Processor .   Step 4 \u200a\u2014\u200aExtract the downloaded zip and navigate to  SP_HOME /bin .   ( SP_HOME  refers to the extracted folder)   Step 5 \u200a\u2014\u200aIssue the following command in the command prompt (Windows) / terminal (Linux)   For Windows: editor.bat\nFor Linux: ./editor.sh  For more details about WSO2 Stream Processor, see its  Quick Start Guide .  After successfully starting the Stream Processor Studio, the terminal in Linux should look like as shown below:   After starting the WSO2 Stream Processor, access the Stream Processor Studio by visiting the following link in your browser.  http://localhost:9390/editor  This takes you to the Stream Processor Studio landing page.", 
            "title": "3. Using Siddhi for the First Time"
        }, 
        {
            "location": "/documentation/siddhi-4.x/quckstart-4.x/#4-siddhi-hello-world-your-first-siddhi-application", 
            "text": "Siddhi Streaming SQL is a rich, compact, easy-to-learn SQL-like language.  Let's first learn how to find the total  of values \ncoming into a data stream and output the current running total value with each event. Siddhi has lot of in-built functions and extensions \navailable for complex analysis, but to get started, let's use a simple one. You can find more information about the Siddhi grammar \nand its functions in the  Siddhi Query Guide .  Let's  consider a scenario where we are loading cargo boxes into a ship . We need to keep track of the total \nweight of the cargo added.  Measuring the weight of a cargo box when loading is considered an event .   We can write a Siddhi program for the above scenario which has  4 parts .  Part 1\u200a\u2014\u200aGiving our Siddhi application a suitable name.  This is a Siddhi routine. In this example, let's name our application as  \u201cHelloWorldApp\u201d  @App:name( HelloWorldApp )  Part 2\u200a\u2014\u200aDefining the input stream.  The stream needs to have a name and a schema defining the data that each incoming event should contain.\nThe event data attributes are expressed as name and type pairs. In this example:   The name of the input stream\u200a\u2014\u200a \u201cCargoStream\u201d   \nThis contains only one data attribute:  The name of the data in each event\u200a\u2014\u200a \u201cweight\u201d  Type of the data  \u201cweight\u201d \u200a\u2014\u200aint   define stream CargoStream (weight int);  Part 3 - Defining the output stream.  This has the same info as the previous definition with an additional  totalWeight  attribute that contains the total weight calculated so far. Here, we need to add a  \"sink\"   to log the  OutputStream  so that we can observe the output values. ( Sink is the Siddhi way to publish \nstreams to external systems.  This particular  log  type sink just logs the stream events. To learn more about sinks, see  sink )  @sink(type= log , prefix= LOGGER )\ndefine stream OutputStream(weight int, totalWeight long);  Part 4\u200a\u2014\u200aThe actual Siddhi query.  Here we need to specify the following:   A name for the query\u200a\u2014\u200a \u201cHelloWorldQuery\u201d  Which stream should be taken into processing\u200a\u2014\u200a \u201cCargoStream\u201d  What data we require in the output stream\u200a\u2014\u200a \u201cweight\u201d ,  \u201ctotalWeight\u201d  How the output should be calculated - by calculating the  sum  of the the  weight s    Which stream should be populated with the output\u200a\u2014\u200a \u201cOutputStream\u201d   @info(name= HelloWorldQuery )\nfrom CargoStream\nselect weight, sum(weight) as totalWeight\ninsert into OutputStream;", 
            "title": "4. Siddhi \u2018Hello World!\u2019\u200a\u2014\u200aYour First Siddhi Application"
        }, 
        {
            "location": "/documentation/siddhi-4.x/quckstart-4.x/#5-simulating-events", 
            "text": "The Stream Processor Studio has in-built support to simulate events. You can do it via the  \u201cEvent Simulator\u201d  \npanel at the left of the Stream Processor Studio. You should save your  HelloWorldApp  by browsing to  File  -   Save  before you run event simulation. Then click   Event Simulator  and configure it as shown below.   Step 1\u200a\u2014\u200aConfigurations:   Siddhi App Name\u200a\u2014\u200a \u201cHelloWorldApp\u201d  Stream Name\u200a\u2014\u200a \u201cCargoStream\u201d  Timestamp\u200a\u2014\u200a(Leave it blank)  weight\u200a\u2014\u200a2 (or some integer)   Step 2\u200a\u2014\u200aClick \u201cRun\u201d mode and then click \u201cStart\u201d . This starts the Siddhi Application. \nIf the Siddhi application is successfully started, the following message is printed in the Stream Processor Studio console:  \u201cHelloWorldApp.siddhi Started Successfully!\u201d    Step 3\u200a\u2014\u200aClick \u201cSend\u201d and observe the terminal  where you started WSO2 Stream Processor Studio. \nYou can see a log that contains  \u201coutputData=[2, 2]\u201d . Click  Send  again and observe a log with  \u201coutputData=[2, 4]\u201d . You can change the value of the weight and send it to see how the sum of the weight is updated.   Bravo! You have successfully completed creating Siddhi Hello World!", 
            "title": "5. Simulating Events"
        }, 
        {
            "location": "/documentation/siddhi-4.x/quckstart-4.x/#6-a-bit-of-stream-processing-temporal-event-processing", 
            "text": "This section demonstrates how to carry out  temporal window processing  with Siddhi.  Up to this point, we have been carrying out the processing by having only the running sum value in-memory. \nNo events were stored during this process.   Window processing \nis a method that allows us to store some events in-memory for a given period so that we can perform operations \nsuch as calculating the average, maximum, etc values within them.  Let's imagine that when we are loading cargo boxes into the ship  we need to keep track of the average weight of \nthe recently loaded boxes  so that we can balance the weight across the ship. \nFor this purpose, let's try to find the  average weight of last three boxes  of each event.   For window processing, we need to modify our query as follows:  @info(name= HelloWorldQuery ) \nfrom CargoStream#window.length(3)\nselect weight, sum(weight) as totalWeight, avg(weight) as averageWeight\ninsert into OutputStream;   from CargoStream#window.length(3)  - Here, we are specifying that the last 3 events should be kept in memory for processing.  avg(weight) as averageWeight  - Here, we are calculating the average of events stored in the window and producing the \naverage value as  \"averageWeight\"  (Note: Now the  sum  also calculates the  totalWeight  based on the last three events).   We also need to modify the  \"OutputStream\"  definition to accommodate the new  \"averageWeight\" .  define stream OutputStream(weight int, totalWeight long, averageWeight double);  The updated Siddhi Application should look as shown below:   Now you can send events using the Event Simulator and observe the log to see the sum and average of the weights of the last three \ncargo events.  It is also notable that the defined  length window  only keeps 3 events in-memory. When the 4th event arrives, the \nfirst event in the window is removed from memory. This ensures that the memory usage does not grow beyond a specific limit. There are also other \nimplementations done in Siddhi  to reduce the memory consumption. For more information, see  Siddhi Architecture .  To learn more about the Siddhi functionality, see  Siddhi Query Guide .  Feel free to try out Siddhi and event simulation to understand Siddhi better.  If you have questions please post them to the  Stackoverflow  with  \"Siddhi\"  tag.", 
            "title": "6. A Bit of Stream Processing - temporal event processing"
        }, 
        {
            "location": "/documentation/siddhi-4.x/user-guide-4.x/", 
            "text": "Siddhi 4.x User Guide\n\n\n\n\nInfo\n\n\nPlease find the latest Siddhi User Guide \nhere\n\n\n\n\nUsing Siddhi in \nWSO2 Stream Processor\n\n\n\n\n\n\nYou can use Siddhi in the latest \nWSO2 Stream \nProcessor\n. It is equipped with a graphical and source query editor, debugger, event simulator, monitoring, data visualization and reporting support. \nAll none GPL \nSiddhi extensions\n are shipped by default with \nWSO2 Stream Processor, and you can add other Siddhi extensions or upgrade existing Siddhi extensions, by removing and \nadding relevant Siddhi extension and its dependent OSGi bundles to \nSP_HOME\n/lib\n directory. If the Siddhi Extension depends on non OSGi jars \nconvert them to OSGi bundles by following \nthe steps provided in the SP docs\n. \n\n\n\n\n\n\nRefer the \nWSO2 SP Quick Start Guide\n to try out Siddhi within WSO2 Stream Processor. \n\n\n\n\n\n\nRefer \nWSO2 Stream Processor Documentation\n for more information.\n\n\n\n\n\n\nUsing Siddhi as a java library\n\n\n\n\nTo embed Siddhi as a java library into your project and to get a working sample follow the bellow steps:\n\n\n\n\nStep 1: Creating a Java Project\n\n\n\n\nCreate a Java project using Maven and include the following dependencies in its \npom.xml\n file.\n\n\n\n\n   \ndependency\n\n     \ngroupId\norg.wso2.siddhi\n/groupId\n\n     \nartifactId\nsiddhi-core\n/artifactId\n\n     \nversion\n4.x.x\n/version\n\n   \n/dependency\n\n   \ndependency\n\n     \ngroupId\norg.wso2.siddhi\n/groupId\n\n     \nartifactId\nsiddhi-query-api\n/artifactId\n\n     \nversion\n4.x.x\n/version\n\n   \n/dependency\n\n   \ndependency\n\n     \ngroupId\norg.wso2.siddhi\n/groupId\n\n     \nartifactId\nsiddhi-query-compiler\n/artifactId\n\n     \nversion\n4.x.x\n/version\n\n   \n/dependency\n\n   \ndependency\n\n     \ngroupId\norg.wso2.siddhi\n/groupId\n\n     \nartifactId\nsiddhi-annotations\n/artifactId\n\n     \nversion\n4.x.x\n/version\n\n   \n/dependency\n   \n\n\n\n\n\nNote\n: You can create the Java project using any method you prefer. The required dependencies can be downloaded from \nhere\n.\n* Create a new Java class in the Maven project.\n\n\nStep 2: Creating Siddhi Application\n\n\nA Siddhi application is a self contained execution entity that defines how data is captured, processed and sent out.  \n\n\n\n\nCreate a Siddhi Application by defining a stream definition E.g.\nStockEventStream\n defining the format of the incoming\n events, and by defining a Siddhi query as follows.\n\n\n\n\n  \nString\n \nsiddhiApp\n \n=\n \ndefine stream StockEventStream (symbol string, price float, volume long); \n \n+\n \n                     \n \n \n+\n\n                     \n@info(name = \nquery1\n) \n \n+\n\n                     \nfrom StockEventStream#window.time(5 sec)  \n \n+\n\n                     \nselect symbol, sum(price) as price, sum(volume) as volume \n \n+\n\n                     \ngroup by symbol \n \n+\n\n                     \ninsert into AggregateStockStream ;\n;\n\n\n\n\n\n\nThis Siddhi query groups the events by symbol and calculates aggregates such as the sum for price and sum of volume \n  for the last 5 seconds time window. Then it inserts the results into a stream named \nAggregateStockStream\n. \n\n\nStep 3: Creating Siddhi Application Runtime\n\n\nThis step involves creating a runtime representation of a Siddhi application.\n\n\nSiddhiManager\n \nsiddhiManager\n \n=\n \nnew\n \nSiddhiManager\n();\n\n\nSiddhiAppRuntime\n \nsiddhiAppRuntime\n \n=\n \nsiddhiManager\n.\ncreateSiddhiAppRuntime\n(\nsiddhiApp\n);\n\n\n\n\n\n\nThe Siddhi Manager parses the Siddhi application and provides you with an Siddhi application runtime. \nThis Siddhi application runtime can be used to add callbacks and input handlers such that you can \nprogrammatically invoke the Siddhi application.\n\n\nStep 4: Registering a Callback\n\n\nYou can register a callback to the Siddhi application runtime in order to receive the results once the events are processed. There are two types of callbacks:\n\n\n\n\nQuery callback\n: This subscribes to a query.\n\n\nStream callback\n: This subscribes to an event stream.\nIn this example, a Stream callback is added to the \nAggregateStockStream\n to capture the processed events.\n\n\n\n\nsiddhiAppRuntime\n.\naddCallback\n(\nAggregateStockStream\n,\n \nnew\n \nStreamCallback\n()\n \n{\n\n           \n@Override\n\n           \npublic\n \nvoid\n \nreceive\n(\nEvent\n[]\n \nevents\n)\n \n{\n\n               \nEventPrinter\n.\nprint\n(\nevents\n);\n\n           \n}\n\n       \n});\n\n\n\n\n\n\nHere, once the results are generated they are sent to the receive method of this callback. An event printer is added \ninside this callback to print the incoming events for demonstration purposes.\n\n\nStep 5: Sending Events\n\n\nIn order to programmatically send events from the stream you need to obtain it's an input handler as follows:\n\n\nInputHandler\n \ninputHandler\n \n=\n \nsiddhiAppRuntime\n.\ngetInputHandler\n(\nStockEventStream\n);\n\n\n\n\n\n\nUse the following code to start the Siddhi application runtime, send events and to shutdown Siddhi:\n\n\n//Start SiddhiApp runtime\n\n\nsiddhiAppRuntime\n.\nstart\n();\n\n\n\n//Sending events to Siddhi\n\n\ninputHandler\n.\nsend\n(\nnew\n \nObject\n[]{\nIBM\n,\n \n100\nf\n,\n \n100L\n});\n\n\nThread\n.\nsleep\n(\n1000\n);\n\n\ninputHandler\n.\nsend\n(\nnew\n \nObject\n[]{\nIBM\n,\n \n200\nf\n,\n \n300L\n});\n\n\ninputHandler\n.\nsend\n(\nnew\n \nObject\n[]{\nWSO2\n,\n \n60\nf\n,\n \n200L\n});\n\n\nThread\n.\nsleep\n(\n1000\n);\n\n\ninputHandler\n.\nsend\n(\nnew\n \nObject\n[]{\nWSO2\n,\n \n70\nf\n,\n \n400L\n});\n\n\ninputHandler\n.\nsend\n(\nnew\n \nObject\n[]{\nGOOG\n,\n \n50\nf\n,\n \n30L\n});\n\n\nThread\n.\nsleep\n(\n1000\n);\n\n\ninputHandler\n.\nsend\n(\nnew\n \nObject\n[]{\nIBM\n,\n \n200\nf\n,\n \n400L\n});\n\n\nThread\n.\nsleep\n(\n2000\n);\n\n\ninputHandler\n.\nsend\n(\nnew\n \nObject\n[]{\nWSO2\n,\n \n70\nf\n,\n \n50L\n});\n\n\nThread\n.\nsleep\n(\n2000\n);\n\n\ninputHandler\n.\nsend\n(\nnew\n \nObject\n[]{\nWSO2\n,\n \n80\nf\n,\n \n400L\n});\n\n\ninputHandler\n.\nsend\n(\nnew\n \nObject\n[]{\nGOOG\n,\n \n60\nf\n,\n \n30L\n});\n\n\nThread\n.\nsleep\n(\n1000\n);\n\n\n\n//Shutdown SiddhiApp runtime\n\n\nsiddhiAppRuntime\n.\nshutdown\n();\n\n\n\n//Shutdown Siddhi\n\n\nsiddhiManager\n.\nshutdown\n();\n\n\n\n\n\n\nWhen the events are sent, you can see the output logged by the event printer.\n\n\nFind the executable Java code of this example \nhere\n\n\nFor more code examples, see \nquick start samples for Siddhi\n.\n\n\nSystem Requirements\n\n\n\n\nMinimum memory - 500 MB (based on in-memory data stored for processing)\n\n\nProcessor      - Pentium 800MHz or equivalent at minimum\n\n\nJava SE Development Kit 1.8 (1.7 for 3.x version)\n\n\nTo build Siddhi from the Source distribution, it is necessary that you have\n   JDK 1.8 version (1.7 for 3.x version) or later and Maven 3.0.4 or later", 
            "title": "User Guide"
        }, 
        {
            "location": "/documentation/siddhi-4.x/user-guide-4.x/#siddhi-4x-user-guide", 
            "text": "Info  Please find the latest Siddhi User Guide  here", 
            "title": "Siddhi 4.x User Guide"
        }, 
        {
            "location": "/documentation/siddhi-4.x/user-guide-4.x/#using-siddhi-in-wso2-stream-processor", 
            "text": "You can use Siddhi in the latest  WSO2 Stream \nProcessor . It is equipped with a graphical and source query editor, debugger, event simulator, monitoring, data visualization and reporting support. \nAll none GPL  Siddhi extensions  are shipped by default with \nWSO2 Stream Processor, and you can add other Siddhi extensions or upgrade existing Siddhi extensions, by removing and \nadding relevant Siddhi extension and its dependent OSGi bundles to  SP_HOME /lib  directory. If the Siddhi Extension depends on non OSGi jars \nconvert them to OSGi bundles by following  the steps provided in the SP docs .     Refer the  WSO2 SP Quick Start Guide  to try out Siddhi within WSO2 Stream Processor.     Refer  WSO2 Stream Processor Documentation  for more information.", 
            "title": "Using Siddhi in WSO2 Stream Processor"
        }, 
        {
            "location": "/documentation/siddhi-4.x/user-guide-4.x/#using-siddhi-as-a-java-library", 
            "text": "To embed Siddhi as a java library into your project and to get a working sample follow the bellow steps:", 
            "title": "Using Siddhi as a java library"
        }, 
        {
            "location": "/documentation/siddhi-4.x/user-guide-4.x/#step-1-creating-a-java-project", 
            "text": "Create a Java project using Maven and include the following dependencies in its  pom.xml  file.       dependency \n      groupId org.wso2.siddhi /groupId \n      artifactId siddhi-core /artifactId \n      version 4.x.x /version \n    /dependency \n    dependency \n      groupId org.wso2.siddhi /groupId \n      artifactId siddhi-query-api /artifactId \n      version 4.x.x /version \n    /dependency \n    dependency \n      groupId org.wso2.siddhi /groupId \n      artifactId siddhi-query-compiler /artifactId \n      version 4.x.x /version \n    /dependency \n    dependency \n      groupId org.wso2.siddhi /groupId \n      artifactId siddhi-annotations /artifactId \n      version 4.x.x /version \n    /dependency      Note : You can create the Java project using any method you prefer. The required dependencies can be downloaded from  here .\n* Create a new Java class in the Maven project.", 
            "title": "Step 1: Creating a Java Project"
        }, 
        {
            "location": "/documentation/siddhi-4.x/user-guide-4.x/#step-2-creating-siddhi-application", 
            "text": "A Siddhi application is a self contained execution entity that defines how data is captured, processed and sent out.     Create a Siddhi Application by defining a stream definition E.g. StockEventStream  defining the format of the incoming\n events, and by defining a Siddhi query as follows.      String   siddhiApp   =   define stream StockEventStream (symbol string, price float, volume long);    +  \n                          + \n                      @info(name =  query1 )    + \n                      from StockEventStream#window.time(5 sec)     + \n                      select symbol, sum(price) as price, sum(volume) as volume    + \n                      group by symbol    + \n                      insert into AggregateStockStream ; ;   This Siddhi query groups the events by symbol and calculates aggregates such as the sum for price and sum of volume \n  for the last 5 seconds time window. Then it inserts the results into a stream named  AggregateStockStream .", 
            "title": "Step 2: Creating Siddhi Application"
        }, 
        {
            "location": "/documentation/siddhi-4.x/user-guide-4.x/#step-3-creating-siddhi-application-runtime", 
            "text": "This step involves creating a runtime representation of a Siddhi application.  SiddhiManager   siddhiManager   =   new   SiddhiManager ();  SiddhiAppRuntime   siddhiAppRuntime   =   siddhiManager . createSiddhiAppRuntime ( siddhiApp );   The Siddhi Manager parses the Siddhi application and provides you with an Siddhi application runtime. \nThis Siddhi application runtime can be used to add callbacks and input handlers such that you can \nprogrammatically invoke the Siddhi application.", 
            "title": "Step 3: Creating Siddhi Application Runtime"
        }, 
        {
            "location": "/documentation/siddhi-4.x/user-guide-4.x/#step-4-registering-a-callback", 
            "text": "You can register a callback to the Siddhi application runtime in order to receive the results once the events are processed. There are two types of callbacks:   Query callback : This subscribes to a query.  Stream callback : This subscribes to an event stream.\nIn this example, a Stream callback is added to the  AggregateStockStream  to capture the processed events.   siddhiAppRuntime . addCallback ( AggregateStockStream ,   new   StreamCallback ()   { \n            @Override \n            public   void   receive ( Event []   events )   { \n                EventPrinter . print ( events ); \n            } \n        });   Here, once the results are generated they are sent to the receive method of this callback. An event printer is added \ninside this callback to print the incoming events for demonstration purposes.", 
            "title": "Step 4: Registering a Callback"
        }, 
        {
            "location": "/documentation/siddhi-4.x/user-guide-4.x/#step-5-sending-events", 
            "text": "In order to programmatically send events from the stream you need to obtain it's an input handler as follows:  InputHandler   inputHandler   =   siddhiAppRuntime . getInputHandler ( StockEventStream );   Use the following code to start the Siddhi application runtime, send events and to shutdown Siddhi:  //Start SiddhiApp runtime  siddhiAppRuntime . start ();  //Sending events to Siddhi  inputHandler . send ( new   Object []{ IBM ,   100 f ,   100L });  Thread . sleep ( 1000 );  inputHandler . send ( new   Object []{ IBM ,   200 f ,   300L });  inputHandler . send ( new   Object []{ WSO2 ,   60 f ,   200L });  Thread . sleep ( 1000 );  inputHandler . send ( new   Object []{ WSO2 ,   70 f ,   400L });  inputHandler . send ( new   Object []{ GOOG ,   50 f ,   30L });  Thread . sleep ( 1000 );  inputHandler . send ( new   Object []{ IBM ,   200 f ,   400L });  Thread . sleep ( 2000 );  inputHandler . send ( new   Object []{ WSO2 ,   70 f ,   50L });  Thread . sleep ( 2000 );  inputHandler . send ( new   Object []{ WSO2 ,   80 f ,   400L });  inputHandler . send ( new   Object []{ GOOG ,   60 f ,   30L });  Thread . sleep ( 1000 );  //Shutdown SiddhiApp runtime  siddhiAppRuntime . shutdown ();  //Shutdown Siddhi  siddhiManager . shutdown ();   When the events are sent, you can see the output logged by the event printer.  Find the executable Java code of this example  here  For more code examples, see  quick start samples for Siddhi .", 
            "title": "Step 5: Sending Events"
        }, 
        {
            "location": "/documentation/siddhi-4.x/user-guide-4.x/#system-requirements", 
            "text": "Minimum memory - 500 MB (based on in-memory data stored for processing)  Processor      - Pentium 800MHz or equivalent at minimum  Java SE Development Kit 1.8 (1.7 for 3.x version)  To build Siddhi from the Source distribution, it is necessary that you have\n   JDK 1.8 version (1.7 for 3.x version) or later and Maven 3.0.4 or later", 
            "title": "System Requirements"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/", 
            "text": "Siddhi 4.x Streaming SQL Guide\n\n\n\n\nInfo\n\n\nPlease find the latest Siddhi Streaming SQL Guide \nhere\n\n\n\n\nIntroduction\n\n\nSiddhi Streaming SQL is designed to process event streams in a streaming manner, detect complex event occurrences, \nand notify them in real-time. \n\n\nSiddhi Application\n\n\nStreaming processing and Complex Event Processing rules can be written is Siddhi Streaming SQL and they can be put \ntogether as a \nSiddhiApp\n in a single file. \n\n\nPurpose\n\n\nEach Siddhi Application is an isolated processing unit that allows you to deploy and execute queries independent of other Siddhi applications in the system.\n\n\nThe following diagram depicts how \nevent flows\n work with some of the key Siddhi Streaming SQL elements \nof the Siddhi Application.\n\n\n\n\nBelow table provides brief description of a few key elements in the Siddhi Streaming SQL Language.\n\n\n\n\n\n\n\n\nElements\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStream\n\n\nA logical series of events ordered in time with a uniquely identifiable name, and set of defined attributes with specific data types defining its schema.\n\n\n\n\n\n\nEvent\n\n\nAn event is associated with only one stream, and all events of that stream have an identical set of attributes that are assigned specific types (or the same schema). An event contains a timestamp and set of attribute values according to the schema.\n\n\n\n\n\n\nTable\n\n\nA structured representation of data stored with a defined schema. Stored data can be backed by \nIn-Memory\n, \nRDBMs\n, \nMongoDB\n, etc. to be accessed and manipulated at runtime.\n\n\n\n\n\n\nQuery\n\n\nA logical construct that processes events in streaming manner by combining existing streams and/or tables, and generates events to an output stream or table. A query consumes one or more input streams, and zero or one table. Then it processes these events in a streaming manner and publishes the output events to streams or tables for further processing or to generate notifications.\n\n\n\n\n\n\nSource\n\n\nA contract that consumes data from external sources (such as \nTCP\n, \nKafka\n, \nHTTP\n, etc)in the form of events, then converts each event (which can be in \nXML\n, \nJSON\n, \nbinary\n, etc. format) to a Siddhi event, and passes that to a Stream for processing.\n\n\n\n\n\n\nSink\n\n\nA contract that takes events arriving at a stream, maps them to a predefined data format (such as \nXML\n, \nJSON\n, \nbinary\n, etc), and publishes them to external endpoints (such as \nE-mail\n, \nTCP\n, \nKafka\n, \nHTTP\n, etc).\n\n\n\n\n\n\nInput Handler\n\n\nA mechanism to programmatically inject events into streams.\n\n\n\n\n\n\nStream/Query Callback\n\n\nA mechanism to programmatically consume output events from streams and queries.\n\n\n\n\n\n\nPartition\n\n\nA logical container that isolates the processing of queries based on partition keys. Here, a separate instance of queries is generated for each partition key to achieve isolation.\n\n\n\n\n\n\nInner Stream\n\n\nA positionable stream that connects portioned queries within their partitions, preserving isolation.\n\n\n\n\n\n\n\n\nGrammar\n\n\nAn element of Siddhi SQL can be composed together as a script in a Siddhi application, Here each construct must be separated \nby a semicolon \n( ; )\n as shown in the below syntax. \n\n\nsiddhi app\n  : \n        \napp annotation\n * \n        ( \nstream definition\n | \ntable definition\n | ... ) + \n        ( \nquery\n | \npartition\n ) +\n        ;\n\n\n\n\n\nExample\n\nSiddhi Application named \nTemperature-Analytics\n defined with a stream named \nTempStream\n and a query \nnamed \n5minAvgQuery\n for processing it.\n\n\n@\napp\n:\nname\n(\nTemperature-Analytics\n)\n\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\n@\nname\n(\n5minAvgQuery\n)\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntime\n(\n5\n \nmin\n)\n\n\nselect\n \nroomNo\n,\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n\n  \ngroup\n \nby\n \nroomNo\n\n\ninsert\n \ninto\n \nOutputStream\n;\n\n\n\n\n\n\nStream\n\n\nA stream is a logical series of events ordered in time. Its schema is defined via the \nstream definition\n.\nA stream definition contains a unique name and a set of attributes with specific types and uniquely identifiable names within the stream.\nAll the events that are selected to be received into a specific stream have the same schema (i.e., have the same attributes in the same order). \n\n\nPurpose\n\n\nBy defining a schema it unifies common types of events together. This enables them to be processed via queries using their defined attributes in a streaming manner, and allow sinks and sources to map events to/from various data formats.\n\n\nSyntax\n\n\nThe syntax for defining a new stream is as follows.\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n);\n\n\n\n\n\n\nThe following parameters are configured in a stream definition.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream name\n\n\nThe name of the stream created. (It is recommended to define a stream name in \nPascalCase\n.)\n\n\n\n\n\n\nattribute name\n\n\nThe schema of an stream is defined by its attributes with uniquely identifiable attribute names. (It is recommended to define attribute names in \ncamelCase\n.)\n\n\n\n\n\n\nattribute type\n\n\nThe type of each attribute defined in the schema. \n This can be \nSTRING\n, \nINT\n, \nLONG\n, \nDOUBLE\n, \nFLOAT\n, \nBOOL\n or \nOBJECT\n.\n\n\n\n\n\n\n\n\nTo use and refer stream and attribute names that do not follow \n[a-zA-Z_][a-zA-Z_0-9]*\n format enclose them in \n`. E.g. ```\n$test(0)` ```.\n\n\nTo make the stream process events in asynchronous and multi-threading manner use the \n@Async\n annotation as shown in \n\nThreading and Asynchronous\n configuration section.\n\n\nExample\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\n\n\n\nThe above creates a stream named \nTempStream\n with the following attributes.\n\n\n\n\ndeviceID\n of type \nlong\n\n\nroomNo\n of type \nint\n \n\n\ntemp\n of type \ndouble\n \n\n\n\n\nSource\n\n\nSources receive events via multiple transports and in various data formats, and direct them into streams for processing.\n\n\nA source configuration allows you to define a mapping in order to convert each incoming event from its native data format to a Siddhi event. When customizations to such mappings are not provided, Siddhi assumes that the arriving event adheres to the predefined format based on the stream definition and the selected message format. \n\n\nPurpose\n\n\nSource allows Siddhi to consume events from external systems, and map the events to adhere to the associated stream. \n\n\nSyntax\n\n\nTo configure a stream that consumes events via a source, add the source configuration to a stream definition by adding the \n@source\n annotation with the required parameter values. \nThe source syntax is as follows:\n\n\n@\nsource\n(\ntype\n=\nsource_type\n,\n \nstatic\n.\noption\n.\nkey1\n=\nstatic_option_value1\n,\n \nstatic\n.\noption\n.\nkeyN\n=\nstatic_option_valueN\n,\n\n    \n@\nmap\n(\ntype\n=\nmap_type\n,\n \nstatic\n.\noption_key1\n=\nstatic_option_value1\n,\n \nstatic\n.\noption\n.\nkeyN\n=\nstatic_option_valueN\n,\n\n        \n@\nattributes\n(\n \nattributeN\n=\nattribute_mapping_N\n,\n \nattribute1\n=\nattribute_mapping_1\n)\n\n    \n)\n\n\n)\n\n\ndefine\n \nstream\n \nStreamName\n \n(\nattribute1\n \nType1\n,\n \nattributeN\n \nTypeN\n);\n\n\n\n\n\n\nThis syntax includes the following annotations.\n\nSource\n\n\nThe \ntype\n parameter of \n@source\n defines the source type that receives events. The other parameters to be configured \ndepends on the source type selected, some of the the parameters are optional. \n\n\nFor detailed information about the parameters see the documentation for the relevant source.\n\n\nThe following is the list of source types that are currently supported:\n\n\n\n\nHTTP\n\n\nKafka\n\n\nTCP\n\n\nIn-memory\n\n\nWSO2Event\n\n\nEmail\n\n\nJMS\n\n\nFile\n\n\nRabbitMQ\n\n\nMQTT\n\n\nWebSocket\n\n\nTwitter\n\n\nAmazon SQS\n\n\nCDC\n\n\nPrometheus\n\n\n\n\nSource Mapper\n\n\nEach \n@source\n configuration has a mapping denoted by the \n@map\n annotation that converts the incoming messages format to Siddhi events.\n\n\nThe \ntype\n parameter of the \n@map\n defines the map type to be used to map the data. The other parameters to be \nconfigured depends on the mapper selected. Some of these parameters are optional. \n\nFor detailed information about the parameters see the documentation for the relevant mapper.\n\n\n\n\nTip\n\n\nWhen the \n@map\n annotation is not provided, \n@map(type='passThrough')\n is used as default. This default mapper type can be used when source consumes Siddhi events and when it does not need any mappings.\n\n\n\n\nMap Attributes\n\n\n@attributes\n is an optional annotation used with \n@map\n to define custom mapping. When \n@attributes\n is not provided, each mapper\nassumes that the incoming events  adhere to its own default data format. By adding the \n@attributes\n annotation, you \ncan configure mappers to extract data from the incoming message selectively, and assign them to attributes. \n\n\nThere are two ways you can configure map attributes. \n\n\n\n\nDefining attributes as keys and mapping content as values in the following format: \n\n\n@attributes( attributeN='mapping_N', attribute1='mapping_1')\n \n\n\nDefining the mapping content of all attributes in the same order as how the attributes are defined in stream definition: \n\n\n@attributes( 'mapping_1', 'mapping_N')\n \n\n\n\n\nSupported Mapping Types\n\n\nThe following is a list of currently supported source mapping types:\n\n\n\n\nWSO2Event\n\n\nXML\n\n\nTEXT\n\n\nJSON\n\n\nBinary\n\n\nKey Value\n\n\nCSV\n\n\nAvro\n\n\n\n\nExample\n\n\nThis query receives events via the \nHTTP\n source in the \nJSON\n data format, and directs them to the \nInputStream\n stream for processing. \nHere the HTTP source is configured to receive events on all network interfaces on the \n8080\nport, on the \nfoo\n context, and \nit is secured via basic authentication.\n\n\n@\nsource\n(\ntype\n=\nhttp\n,\n \nreceiver\n.\nurl\n=\nhttp://0.0.0.0:8080/foo\n,\n \nbasic\n.\nauth\n.\nenabled\n=\ntrue\n,\n \n  \n@\nmap\n(\ntype\n=\njson\n))\n\n\ndefine\n \nstream\n \nInputStream\n \n(\nname\n \nstring\n,\n \nage\n \nint\n,\n \ncountry\n \nstring\n);\n\n\n\n\n\n\nSink\n\n\nSinks publish events from the streams via multiple transports to external endpoints in various data formats.\n\n\nA sink configuration allows you to define a mapping to convert the Siddhi event to the required output data format (such as \nJSON\n, \nTEXT\n, \nXML\n, etc.).\nWhen customization to such mappings is not provided, Siddhi converts events to its default format based on the stream definition and \nthe selected data format to publish the events.\n\n\nPurpose\n\n\nSinks provide a way to publish Siddhi events to external systems in the preferred data format. \n\n\nSyntax\n\n\nTo configure a stream to publish events via a sink, add the sink configuration to a stream definition by adding the \n@sink\n \nannotation with the required parameter values. The sink syntax is as follows:\n\n\n@\nsink\n(\ntype\n=\nsink_type\n,\n \nstatic_option_key1\n=\nstatic_option_value1\n,\n \ndynamic_option_key1\n=\n{{dynamic_option_value1}}\n,\n\n    \n@\nmap\n(\ntype\n=\nmap_type\n,\n \nstatic_option_key1\n=\nstatic_option_value1\n,\n \ndynamic_option_key1\n=\n{{dynamic_option_value1}}\n,\n\n        \n@\npayload\n(\npayload_mapping\n)\n\n    \n)\n\n\n)\n\n\ndefine\n \nstream\n \nStreamName\n \n(\nattribute1\n \nType1\n,\n \nattributeN\n \nTypeN\n);\n\n\n\n\n\n\n\n\nDynamic Properties\n\n\nThe sink and sink mapper properties that are categorized as \ndynamic\n have the ability to absorb attributes values \nfrom their associated streams. This can be done by using the attribute names in double curly braces as \n{{...}}\n when configuring the property value. \n\n\nSome valid dynamic properties values are: \n\n\n\n\n'{{attribute1}}'\n\n\n'This is {{attribute1}}'\n \n\n\n{{attribute1}} \n {{attributeN}}\n  \n\n\n\n\nHere the attribute names in the double curly braces will be replaced with event values during execution. \n\n\n\n\nThis syntax includes the following annotations.\n\n\nSink\n\n\nThe \ntype\n parameter of the \n@sink\n annotation defines the sink type that publishes the events. The other parameters to be configured \ndepends on the sink type selected. Some of these parameters are optional, and some can have dynamic values. \n\n\nFor detailed information about the parameters see documentation for the relevant sink.\n\n\nThe following is a list of currently supported sink types.\n\n\n\n\nHTTP\n\n\nKafka\n\n\nTCP\n\n\nIn-memory\n\n\nLog\n\n\nWSO2Event\n\n\nEmail\n \n\n\nJMS\n \n\n\nFile\n \n\n\nRabbitMQ\n\n\nMQTT\n\n\nWebSocket\n\n\nAmazon SQS\n\n\nPrometheus\n\n\n\n\nDistributed Sink\n\n\nDistributed Sinks publish events from a defined stream to multiple destination endpoints using load balancing and partitioning strategies.\n\n\nAny ordinary sink can be used as a distributed sink. A distributed sink configuration allows you to define a common mapping to convert the Siddhi events for all its destination endpoints, \nallows you to define a distribution strategy (e.g. \nroundRobin\n, \npartitioned\n), and configuration for each specific endpoint destination. \n\n\nPurpose\n\n\nDistributed sinks provide a way to publish Siddhi events to multiple destination endpoints in the preferred data format. \n\n\nSyntax\n\n\nTo configure a stream to publish events via a distributed sink, add the sink configuration to a stream definition by adding the \n@sink\n \nannotation and add the configuration parameters that are common of all the destination endpoints inside the \n@sink\n annotation \nalong with \n@distribution\n and \n@destination\n annotations providing distribution strategy and endpoint specific configurations. \nThe distributed sink syntax is as follows:\n\n\nRoundRobin Distributed Sink\n\n\nPublishes events to defined destinations in a round robin manner. \n\n\n@\nsink\n(\ntype\n=\nsink_type\n,\n \ncommon_option_key1\n=\ncommon_option_value1\n,\n \ncommon_option_key2\n=\n{{common_option_value1}}\n,\n\n    \n@\nmap\n(\ntype\n=\nmap_type\n,\n \noption_key1\n=\noption_value1\n,\n \noption_key2\n=\n{{option_value1}}\n,\n\n        \n@\npayload\n(\npayload_mapping\n)\n\n    \n)\n\n    \n@\ndistribution\n(\nstrategy\n=\nroundRobin\n,\n\n        \n@\ndestination\n(\nspecific_option_key1\n=\nspecific_option_value1\n),\n\n        \n@\ndestination\n(\nspecific_option_key1\n=\nspecific_option_value2\n)))\n\n\n)\n\n\ndefine\n \nstream\n \nStreamName\n \n(\nattribute1\n \nType1\n,\n \nattributeN\n \nTypeN\n);\n\n\n\n\n\n\nPartitioned Distributed Sink\n\n\nPublishes events to defined destinations by partitioning based on the hashcode of the events partition key. \n\n\n@\nsink\n(\ntype\n=\nsink_type\n,\n \ncommon_option_key1\n=\ncommon_option_value1\n,\n \ncommon_option_key2\n=\n{{common_option_value1}}\n,\n\n    \n@\nmap\n(\ntype\n=\nmap_type\n,\n \noption_key1\n=\noption_value1\n,\n \noption_key2\n=\n{{option_value1}}\n,\n\n        \n@\npayload\n(\npayload_mapping\n)\n\n    \n)\n\n    \n@\ndistribution\n(\nstrategy\n=\npartitioned\n,\n \npartitionKey\n=\npartition_key\n,\n\n        \n@\ndestination\n(\nspecific_option_key1\n=\nspecific_option_value1\n),\n\n        \n@\ndestination\n(\nspecific_option_key1\n=\nspecific_option_value2\n)))\n\n\n)\n\n\ndefine\n \nstream\n \nStreamName\n \n(\nattribute1\n \nType1\n,\n \nattributeN\n \nTypeN\n);\n\n\n\n\n\n\nSink Mapper\n\n\nEach \n@sink\n annotation has a mapping denoted by the  \n@map\n annotation that converts the Siddhi event to an outgoing message format.\n\n\nThe \ntype\n parameter of the \n@map\n annotation defines the map type based on which the event is mapped. The other parameters to be configured depends on the mapper selected. Some of these parameters are optional and some have dynamic values. \n \n\n\nFor detailed information about the parameters see the documentation for the relevant mapping type.\n\n\n\n\nTip\n\n\nWhen the \n@map\n annotation is not provided, \n@map(type='passThrough')\n is used by default. This can be used when the sink publishes in the Siddhi event format, or when it does not need any mappings.\n\n\n\n\nMap Payload\n\n\n@payload\n is an optional annotation used with the \n@map\n annotation to define a custom mapping. When the \n@payload\n annotation is not provided, each mapper\nmaps the outgoing events to its own default data format. By defining the \n@payload\n annotation you can configure mappers to produce the output payload with attribute names of your choice, using dynamic properties by selectively assigning \nthe attributes in your preferred format. \n\n\nThere are two ways you can configure the \n@payload\n annotation. \n\n\n\n\nSome mappers such as \nXML\n, \nJSON\n, and \nTest\n accept only one output payload using the following format: \n\n\n@payload( 'This is a test message from {{user}}.' )\n \n\n\nSome mappers such \nkey-value\n accept series of mapping values defined as follows: \n\n\n@payload( key1='mapping_1', 'key2'='user : {{user}}')\n \n\nHere, apart from the dotted key names sush as \na.b.c\n, any constant string value such as \n'$abc'\n can also by used as a key. \n\n\n\n\nSupported Mapping Types\n\n\nThe following is a list of currently supported sink mapping types:\n\n\n\n\nWSO2Event\n\n\nXML\n\n\nTEXT\n\n\nJSON\n\n\nBinary\n\n\nKey Value\n\n\nCSV\n\n\nAvro\n\n\n\n\nExample\n\n\nFollowing query publishes events from the \nOutputStream\n stream to an \nHTTP\n endpoint. Here the events are mapped to the default \nJSON\n payloads and sent to \nhttp://localhost:8005/endpoint\n\n using the \nPOST\n method, with the\nAccept\n header, and secured via basic authentication where \nadmin\n is both the username and the password.\n\n\n@\nsink\n(\ntype\n=\nhttp\n,\n \npublisher\n.\nurl\n=\nhttp://localhost:8005/endpoint\n,\n \nmethod\n=\nPOST\n,\n \nheaders\n=\nAccept-Date:20/02/2017\n,\n \n  \nbasic\n.\nauth\n.\nusername\n=\nadmin\n,\n \nbasic\n.\nauth\n.\npassword\n=\nadmin\n,\n \nbasic\n.\nauth\n.\nenabled\n=\ntrue\n,\n\n  \n@\nmap\n(\ntype\n=\njson\n))\n\n\ndefine\n \nstream\n \nOutputStream\n \n(\nname\n \nstring\n,\n \nang\n \nint\n,\n \ncountry\n \nstring\n);\n\n\n\n\n\n\nFollowing query publishes events from the \nOutputStream\n stream to multiple the \nHTTP\n endpoints using partitioning strategy. Here the events sent to either \nhttp://localhost:8005/endpoint1\n\nor \nhttp://localhost:8006/endpoint2\n based on the partitioning key \ncountry\n. It uses default \nJSON\n mapping, \nPOST\n method, and used \nadmin\n as both the username and the password when publishing to both the endpoints.\n\n\n@\nsink\n(\ntype\n=\nhttp\n,\n \nmethod\n=\nPOST\n,\n \nbasic\n.\nauth\n.\nusername\n=\nadmin\n,\n \nbasic\n.\nauth\n.\npassword\n=\nadmin\n,\n \n  \nbasic\n.\nauth\n.\nenabled\n=\ntrue\n,\n \n@\nmap\n(\ntype\n=\njson\n),\n\n  \n@\ndistribution\n(\nstrategy\n=\npartitioned\n,\n \npartitionKey\n=\ncountry\n,\n\n     \n@\ndestination\n(\npublisher\n.\nurl\n=\nhttp://localhost:8005/endpoint1\n),\n\n     \n@\ndestination\n(\npublisher\n.\nurl\n=\nhttp://localhost:8006/endpoint2\n)))\n\n\ndefine\n \nstream\n \nOutputStream\n \n(\nname\n \nstring\n,\n \nang\n \nint\n,\n \ncountry\n \nstring\n);\n\n\n\n\n\n\nQuery\n\n\nEach Siddhi query can consume one or more streams, and 0-1 tables, process the events in a streaming manner, and then generate an\n output event to a stream or perform a CRUD operation to a table.\n\n\nPurpose\n\n\nA query enables you to perform complex event processing and stream processing operations by processing incoming events one by one in the order they arrive.\n\n\nSyntax\n\n\nAll queries contain an input and an output section. Some also contain a projection section. A simple query with all three sections is as follows.\n\n\nfrom\n \ninput\n \nstream\n \n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n/\ntable\n\n\n\n\n\n\nExample\n\n\nThis query included in a Siddhi Application consumes events from the \nTempStream\n stream (that is already defined) and outputs the room temperature and the room number to the \nRoomTempStream\n stream.\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \nTempStream\n \n\nselect\n \nroomNo\n,\n \ntemp\n\n\ninsert\n \ninto\n \nRoomTempStream\n;\n\n\n\n\n\n\n\n\nInferred Stream\n\n\nHere, the \nRoomTempStream\n is an inferred Stream, which means it can be used as any other defined stream \nwithout explicitly defining its stream definition. The definition of the \nRoomTempStream\n is inferred from the \nfirst query that produces the stream.  \n\n\n\n\nQuery Projection\n\n\nSiddhi queries supports the following for query projections.\n\n\n\n    \n\n        \nAction\n\n        \nDescription\n\n    \n\n    \n\n        \nSelecting required objects for projection\n\n        \nThis involves selecting only some of the attributes from the input stream to be inserted into an output stream.\n            \n\n            E.g., The following query selects only the `roomNo` and `temp` attributes from the `TempStream` stream.\n            \nfrom TempStream\nselect roomNo, temp\ninsert into RoomTempStream;\n\n        \n\n    \n\n    \n\n        \nSelecting all attributes for projection\n\n        \nSelecting all the attributes in an input stream to be inserted into an output stream. This can be done by using asterisk ( * ) or by omitting the `select` statement.\n            \n\n            E.g., Both the following queries select all the attributes in the `NewTempStream` stream.\n            \nfrom TempStream\nselect *\ninsert into NewTempStream;\n\n            or\n            \nfrom TempStream\ninsert into NewTempStream;\n\n        \n\n    \n\n    \n\n        \nRenaming attributes\n\n        \nThis selects attributes from the input streams and inserts them into the output stream with different names.\n            \n\n            E.g., This query renames `roomNo` to `roomNumber` and `temp` to `temperature`.\n            \nfrom TempStream \nselect roomNo as roomNumber, temp as temperature\ninsert into RoomTempStream;\n\n        \n\n    \n\n    \n\n        \nIntroducing the constant value\n\n        \nThis adds constant values by assigning it to an attribute using `as`.\n            \n\n            E.g., This query specifies 'C' to be used as the constant value for `scale` attribute. \n            \nfrom TempStream\nselect roomNo, temp, 'C' as scale\ninsert into RoomTempStream;\n\n        \n\n    \n\n    \n\n        \nUsing mathematical and logical expressions\n\n        \nThis uses attributes with mathematical and logical expressions in the precedence order given below, and assigns them to the output attribute using `as`.\n            \n\n            \nOperator precedence\n\n            \n\n                \n\n                    \nOperator\n\n                    \nDistribution\n\n                    \nExample\n\n                \n\n                \n\n                    \n\n                        ()\n                    \n\n                    \n\n                        Scope\n                    \n\n                    \n\n                        \n(cost + tax) * 0.05\n\n                    \n\n                \n\n                \n\n                    \n\n                         IS NULL\n                    \n\n                    \n\n                        Null check\n                    \n\n                    \n\n                        \ndeviceID is null\n\n                    \n\n                \n\n                \n\n                    \n\n                        NOT\n                    \n\n                    \n\n                        Logical NOT\n                    \n\n                    \n\n                        \nnot (price > 10)\n\n                    \n\n                \n\n                \n\n                    \n\n                         *   /   %  \n                    \n\n                    \n\n                        Multiplication, division, modulo\n                    \n\n                    \n\n                        \ntemp * 9/5 + 32\n\n                    \n\n                \n\n                \n\n                    \n\n                        +   -  \n                    \n\n                    \n\n                        Addition, substraction\n                    \n\n                    \n\n                        \ntemp * 9/5 - 32\n\n                    \n\n                \n\n                \n\n                    \n\n                        \n<\n   \n<\n=   >   >=\n                    \n\n                    \n\n                        Comparators: less-than, greater-than-equal, greater-than, less-than-equal\n                    \n\n                    \n\n                        \ntotalCost >= price * quantity\n\n                    \n\n                \n\n                \n\n                    \n\n                        ==   !=  \n                    \n\n                    \n\n                        Comparisons: equal, not equal\n                    \n\n                    \n\n                        \ntotalCost !=  price * quantity\n\n                    \n\n                \n\n                \n\n                    \n\n                        IN\n                    \n\n                    \n\n                        Contains in table\n                    \n\n                    \n\n                        \nroomNo in ServerRoomsTable\n\n                    \n\n                \n\n                \n\n                    \n\n                        AND\n                    \n\n                    \n\n                        Logical AND\n                    \n\n                    \n\n                        \ntemp \n<\n 40 and (humidity \n<\n 40 or humidity >= 60)\n\n                    \n\n                \n\n                \n\n                    \n\n                        OR\n                    \n\n                    \n\n                        Logical OR\n                    \n\n                    \n\n                        \ntemp \n<\n 40 or (humidity \n<\n 40 and humidity >= 60)\n\n                    \n\n                \n\n            \n\n            E.g., Converting Celsius to Fahrenheit and identifying rooms with room number between 10 and 15 as server rooms.\n            \nfrom TempStream\nselect roomNo, temp * 9/5 + 32 as temp, 'F' as scale, roomNo > 10 and roomNo \n<\n 15 as isServerRoom\ninsert into RoomTempStream;\n       \n    \n\n\n\n\n\n\nFunction\n\n\nA function consumes zero, one or more parameters and always produces a result value. It can be used in any location where\n an attribute can be used. \n\n\nPurpose\n\n\nFunctions encapsulates complex execution logic that makes Siddhi applications simple and easy to understand. \n\n\nFunction Parameters\n\n\nFunctions parameters can be attributes, constant values, results of other functions, results of mathematical or logical expressions or time parameters. \nFunction parameters vary depending on the function being called.\n\n\nTime is a special parameter that can be defined using the integer time value followed by its unit as \nint\n \nunit\n. \nFollowing are the supported unit types. Upon execution, time returns the value in the scale of milliseconds as a long value. \n\n\n\n    \n\n        \n\n            Unit  \n        \n\n        \n\n            Syntax\n        \n\n    \n\n    \n\n        \n\n            Year\n        \n\n        \n\n            year | years\n        \n\n    \n\n    \n\n        \n\n            Month\n        \n\n        \n\n            month | months\n        \n\n    \n\n    \n\n        \n\n            Week\n        \n\n        \n\n            week | weeks\n        \n\n    \n\n    \n\n        \n\n            Day\n        \n\n        \n\n            day | days\n        \n\n    \n\n    \n\n        \n\n            Hour\n        \n\n        \n\n           hour | hours\n        \n\n    \n\n    \n\n        \n\n           Minutes\n        \n\n        \n\n           minute | minutes | min\n        \n\n    \n\n    \n\n        \n\n           Seconds\n        \n\n        \n\n           second | seconds | sec\n        \n\n    \n\n    \n\n        \n\n           Milliseconds\n        \n\n        \n\n           millisecond | milliseconds\n        \n\n    \n\n\n\n\n\nE.g. Passing 1 hour and 25 minutes to \ntest()\n function.\n\n\ntest(1 hour 25 min)\n\n\n\n\n\nNote\n\n\nFunctions, mathematical expressions, and logical expressions can be used in a nested manner.\n\n\n\n\nFollowing are some inbuilt functions shipped with Siddhi, for more functions refer execution \nextensions\n.\n\n\n\n\neventTimestamp\n\n\nlog\n\n\nUUID\n\n\ndefault\n\n\ncast\n\n\nconvert\n\n\nifThenElse\n\n\nminimum\n\n\nmaximum\n\n\ncoalesce\n\n\ninstanceOfBoolean\n\n\ninstanceOfDouble\n\n\ninstanceOfFloat\n\n\ninstanceOfInteger\n\n\ninstanceOfLong\n\n\ninstanceOfString\n\n\n\n\nExample\n\n\nThe following configuration converts the \nroomNo\n to \nstring\n and adds a \nmessageID\n to each event using the \nconvert\n and \nUUID\n functions.\n\n\nfrom\n \nTempStream\n\n\nselect\n \nconvert\n(\nroomNo\n,\n \nstring\n)\n \nas\n \nroomNo\n,\n \ntemp\n,\n \nUUID\n()\n \nas\n \nmessageID\n\n\ninsert\n \ninto\n \nRoomTempStream\n;\n\n\n\n\n\n\nFilter\n\n\nFilters are included in queries to filter information from input streams based on a specified condition.\n\n\nPurpose\n\n\nA filter allows you to separate events that match a specific condition as the output, or for further processing.\n\n\nSyntax\n\n\nFilter conditions should be defined in square brackets next to the input stream name as shown below.\n\n\nfrom\n \ninput\n \nstream\n[\nfilter\n \ncondition\n]\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nExample\n\n\nThis query filters all server rooms of which the room number is within the range of 100-210, and having temperature greater than 40 degrees \nfrom the \nTempStream\n stream, and inserts the results into the \nHighTempStream\n stream.\n\n\nfrom\n \nTempStream\n[(\nroomNo\n \n=\n \n100\n \nand\n \nroomNo\n \n \n210\n)\n \nand\n \ntemp\n \n \n40\n]\n\n\nselect\n \nroomNo\n,\n \ntemp\n\n\ninsert\n \ninto\n \nHighTempStream\n;\n\n\n\n\n\n\nWindow\n\n\nWindows allow you to capture a subset of events based on a specific criterion from an input stream for calculation. \nEach input stream can only have a maximum of one window.\n\n\nPurpose\n\n\nTo create subsets of events within a stream based on time duration, number of events, etc for processing. \nA window can operate in a sliding or tumbling (batch) manner.\n\n\nSyntax\n\n\nThe \n#window\n prefix should be inserted next to the relevant stream in order to use a window.\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\nparameter\n,\n \nparameter\n,\n \n...\n \n)\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \nevent\n \ntype\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\nNote\n\n\nFilter condition can be applied both before and/or after the window\n\n\n\n\nExample\n\n\nIf you want to identify the maximum temperature out of the last 10 events, you need to define a \nlength\n window of 10 events.\n This window operates in a sliding mode where the following 3 subsets are calculated when a list of 12 events are received in a sequential order.\n\n\n\n\n\n\n\n\nSubset\n\n\nEvent Range\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1-10\n\n\n\n\n\n\n2\n\n\n2-11\n\n\n\n\n\n\n3\n\n\n3-12\n\n\n\n\n\n\n\n\nThe following query finds the maximum temperature out of \nlast 10 events\n from the \nTempStream\n stream, \nand inserts the results into the \nMaxTempStream\n stream.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\nlength\n(\n10\n)\n\n\nselect\n \nmax\n(\ntemp\n)\n \nas\n \nmaxTemp\n\n\ninsert\n \ninto\n \nMaxTempStream\n;\n\n\n\n\n\n\nIf you define the maximum temperature reading out of every 10 events, you need to define a \nlengthBatch\n window of 10 events.\nThis window operates as a batch/tumbling mode where the following 3 subsets are calculated when a list of 30 events are received in a sequential order.\n\n\n\n\n\n\n\n\nSubset\n\n\nEvent Range\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1-10\n\n\n\n\n\n\n2\n\n\n11-20\n\n\n\n\n\n\n3\n\n\n21-30\n\n\n\n\n\n\n\n\nThe following query finds the maximum temperature out of \nevery 10 events\n from the \nTempStream\n stream, \nand inserts the results into the \nMaxTempStream\n stream.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\nlengthBatch\n(\n10\n)\n\n\nselect\n \nmax\n(\ntemp\n)\n \nas\n \nmaxTemp\n\n\ninsert\n \ninto\n \nMaxTempStream\n;\n\n\n\n\n\n\n\n\nNote\n\n\nSimilar operations can be done based on time via \ntime\n windows and \ntimeBatch\n windows and for others. \nCode segments such as \n#window.time(10 min)\n considers events that arrive during the last 10 minutes in a sliding manner, and the \n#window.timeBatch(2 min)\n considers events that arrive every 2 minutes in a tumbling manner. \n\n\n\n\nFollowing are some inbuilt windows shipped with Siddhi. For more window types, see execution \nextensions\n.\n\n\n\n\ntime\n\n\ntimeBatch\n\n\nbatch\n\n\ntimeLength\n\n\nlength\n\n\nlengthBatch\n\n\nsort\n\n\nfrequent\n\n\nlossyFrequent\n\n\nsession\n\n\ncron\n\n\nexternalTime\n\n\nexternalTimeBatch\n\n\ndelay\n\n\n\n\nOutput event types\n \n\n\nProjection of the query depends on the output event types such as, \ncurrent\n and \nexpired\n event types.\n By default all queries produce \ncurrent\n events and only queries with windows produce \nexpired\n events \n when events expire from the window. You can specify whether the output of a query should be only current events, only expired events or both current and expired events.\n\n\nNote!\n Controlling the output event types does not alter the execution within the query, and it does not affect the accuracy of the query execution.  \n\n\nThe following keywords can be used with the output stream to manipulate output. \n\n\n\n\n\n\n\n\nOutput event types\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncurrent events\n\n\nOutputs events when incoming events arrive to be processed by the query. \n This is default when no specific output event type is specified.\n\n\n\n\n\n\nexpired events\n\n\nOutputs events when events expires from the window.\n\n\n\n\n\n\nall events\n\n\nOutputs events when incoming events arrive to be processed by the query as well as \n when events expire from the window.\n\n\n\n\n\n\n\n\nThe output event type keyword can be used between \ninsert\n and \ninto\n as shown in the following example.\n\n\nExample\n\n\nThis query delays all events in a stream by 1 minute.  \n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntime\n(\n1\n \nmin\n)\n\n\nselect\n \n*\n\n\ninsert\n \nexpired\n \nevents\n \ninto\n \nDelayedTempStream\n\n\n\n\n\n\nAggregate function\n\n\nAggregate functions perform aggregate calculations in the query. \nWhen a window is defined the aggregation is restricted within that window. If no window is provided aggregation is performed from the start of the Siddhi application.\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\nparameter\n,\n \nparameter\n,\n \n...\n \n)\n\n\nselect\n \naggregate\n \nfunction\n(\nparameter\n,\n \nparameter\n,\n \n...\n \n)\n \nas\n \nattribute\n \nname\n,\n \nattribute2\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nAggregate Parameters\n\n\nAggregate parameters can be attributes, constant values, results of other functions or aggregates, results of mathematical or logical expressions, or time parameters. \nAggregate parameters configured in a query  depends on the aggregate function being called.\n\n\nExample\n\n\nThe following query calculates the average value for the \ntemp\n attribute of the \nTempStream\n stream. This calculation is done for the last 10 minutes in a sliding manner, and the result is output as \navgTemp\n to the \nAvgTempStream\n output stream.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntime\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n,\n \ndeviceID\n\n\ninsert\n \ninto\n \nAvgTempStream\n;\n\n\n\n\n\n\nFollowing are some inbuilt aggregation functions shipped with Siddhi, for more aggregation functions, see execution \nextensions\n.\n\n\n\n\navg\n\n\nsum\n\n\nmax\n\n\nmin\n\n\ncount\n\n\ndistinctCount\n\n\nmaxForever\n\n\nminForever\n\n\nstdDev\n\n\n\n\nGroup By\n\n\nGroup By allows you to group the aggregate based on specified attributes.\n\n\nSyntax\n\nThe syntax for the Group By aggregate function is as follows:\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(...)\n\n\nselect\n \naggregate\n \nfunction\n(\n \nparameter\n,\n \nparameter\n,\n \n...)\n \nas\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n,\n \n...\n\n\ngroup\n \nby\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nExample\n\nThe following query calculates the average temperature per \nroomNo\n and \ndeviceID\n combination, for events that arrive at the \nTempStream\n stream\nfor a sliding time window of 10 minutes.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntime\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n,\n \ndeviceID\n\n\ngroup\n \nby\n \nroomNo\n,\n \ndeviceID\n\n\ninsert\n \ninto\n \nAvgTempStream\n;\n\n\n\n\n\n\nHaving\n\n\nHaving allows you to filter events after processing the \nselect\n statement.\n\n\nPurpose\n\nThis allows you to filter the aggregation output.\n\n\nSyntax\n\nThe syntax for the Having clause is as follows:\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\n \n...\n \n)\n\n\nselect\n \naggregate\n \nfunction\n(\n \nparameter\n,\n \nparameter\n,\n \n...)\n \nas\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n,\n \n...\n\n\ngroup\n \nby\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n \n...\n\n\nhaving\n \ncondition\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nExample\n\n\nThe following query calculates the average temperature per room for the last 10 minutes, and alerts if it exceeds 30 degrees.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntime\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n\n\ngroup\n \nby\n \nroomNo\n\n\nhaving\n \navgTemp\n \n \n30\n\n\ninsert\n \ninto\n \nAlertStream\n;\n\n\n\n\n\n\nOrder By\n\n\nOrder By allows you to order the aggregated result in ascending and/or descending order based on specified attributes. By default ordering will be done in\nascending manner. User can use 'desc' keyword to order in descending manner.\n\n\nSyntax\n\nThe syntax for the Order By clause is as follows:\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\n \n...\n \n)\n\n\nselect\n \naggregate\n \nfunction\n(\n \nparameter\n,\n \nparameter\n,\n \n...)\n \nas\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n,\n \n...\n\n\ngroup\n \nby\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n \n...\n\n\nhaving\n \ncondition\n\n\norder\n \nby\n \nattribute1\n \nname\n \n(\nasc\n \n|\n \ndesc\n)\n?\n,\n \nattribute2\n \nname\n \n(\nascend\n/\ndescend\n)\n?\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nExample\n\n\nThe following query calculates the average temperature per \nroomNo\n and \ndeviceID\n combination for every 10 minutes, and generate output events\nby ordering them in the ascending order of the room's avgTemp and then by the descending order of roomNo.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntimeBatch\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n,\n \ndeviceID\n\n\ngroup\n \nby\n \nroomNo\n,\n \ndeviceID\n\n\norder\n \nby\n \navgTemp\n,\n \nroomNo\n \ndesc\n\n\ninsert\n \ninto\n \nAvgTempStream\n;\n\n\n\n\n\n\nLimit \n Offset\n\n\nWhen events are emitted as a batch, offset allows you to offset beginning of the output event batch and limit allows you to limit the number of events in the batch from the defined offset. \nWith this users can specify which set of events need be emitted. \n\n\nSyntax\n\nThe syntax for the Limit \n Offset clause is as follows:\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\n \n...\n \n)\n\n\nselect\n \naggregate\n \nfunction\n(\n \nparameter\n,\n \nparameter\n,\n \n...)\n \nas\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n,\n \n...\n\n\ngroup\n \nby\n \nattribute1\n \nname\n,\n \nattribute2\n \nname\n \n...\n\n\nhaving\n \ncondition\n\n\norder\n \nby\n \nattribute1\n \nname\n \n(\nasc\n \n|\n \ndesc\n)\n?\n,\n \nattribute2\n \nname\n \n(\nascend\n/\ndescend\n)\n?\n,\n \n...\n\n\nlimit\n \npositive\n \ninterger\n?\n\n\noffset\n \npositive\n \ninterger\n?\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nHere both \nlimit\n and \noffset\n are optional where \nlimit\n by default output all the events and \noffset\n by default set to \n0\n.\n\n\nExample\n\nThe following query calculates the average temperature per \nroomNo\n and \ndeviceID\n combination, for events that arrive at the \nTempStream\n stream\nfor every 10 minutes and emits two events with highest average temperature.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntimeBatch\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n,\n \ndeviceID\n\n\ngroup\n \nby\n \nroomNo\n,\n \ndeviceID\n\n\norder\n \nby\n \navgTemp\n \ndesc\n\n\nlimit\n \n2\n\n\ninsert\n \ninto\n \nHighestAvgTempStream\n;\n\n\n\n\n\n\nThe following query calculates the average temperature per \nroomNo\n and \ndeviceID\n combination, for events that arrive at the \nTempStream\n stream\nfor every 10 minutes and emits third, forth and fifth events when sorted in descending order based on their average temperature.\n\n\nfrom\n \nTempStream\n#\nwindow\n.\ntimeBatch\n(\n10\n \nmin\n)\n\n\nselect\n \navg\n(\ntemp\n)\n \nas\n \navgTemp\n,\n \nroomNo\n,\n \ndeviceID\n\n\ngroup\n \nby\n \nroomNo\n,\n \ndeviceID\n\n\norder\n \nby\n \navgTemp\n \ndesc\n\n\nlimit\n \n3\n\n\noffset\n \n2\n\n\ninsert\n \ninto\n \nHighestAvgTempStream\n;\n\n\n\n\n\n\nJoin (Stream)\n\n\nJoins allow you to get a combined result from two streams in real-time based on a specified condition. \n\n\nPurpose\n\nStreams are stateless. Therefore, in order to join two streams, they need to be connected to a window so that there is a pool of events that can be used for joining. Joins also accept conditions to join the appropriate events from each stream.\n\n\nDuring the joining process each incoming event of each stream is matched against all the events in the other \nstream's window based on the given condition, and the output events are generated for all the matching event pairs.\n\n\n\n\nNote\n\n\nJoin can also be performed with \nstored data\n, \naggregation\n or externally \ndefined windows\n.\n\n\n\n\nSyntax\n\n\nThe syntax for a join is as follows:\n\n\nfrom\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\nparameter\n,\n \n...\n \n)\n \n{\nunidirectional\n}\n \n{\nas\n \nreference\n}\n\n         \njoin\n \ninput\n \nstream\n#\nwindow\n.\nwindow\n \nname\n(\nparameter\n,\n  \n...\n \n)\n \n{\nunidirectional\n}\n \n{\nas\n \nreference\n}\n\n    \non\n \njoin\n \ncondition\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nHere, the \njoin condition\n allows you to match the attributes from both the streams. \n\n\nUnidirectional join operation\n\n\nBy default, events arriving at either stream can trigger the joining process. However, if you want to control the \njoin execution, you can add the \nunidirectional\n keyword next to a stream in the join definition as depicted in the \nsyntax in order to enable that stream to trigger the join operation. Here, events arriving at other stream only update the \n window of that stream, and this stream does not trigger the join operation.\n\n\n\n\nNote\n\n\nThe \nunidirectional\n keyword cannot be applied to both the input streams because the default behaviour already allows both streams to trigger the join operation.\n\n\n\n\nExample\n\n\nAssuming that the temperature of regulators are updated every minute. \nFollowing is a Siddhi App that controls the temperature regulators if they are not already \non\n for all the rooms with a room temperature greater than 30 degrees.  \n\n\ndefine\n \nstream\n \nTempStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\ndefine\n \nstream\n \nRegulatorStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \nisOn\n \nbool\n);\n\n\n\nfrom\n \nTempStream\n[\ntemp\n \n \n30\n.\n0\n]\n#\nwindow\n.\ntime\n(\n1\n \nmin\n)\n \nas\n \nT\n\n  \njoin\n \nRegulatorStream\n[\nisOn\n \n==\n \nfalse\n]\n#\nwindow\n.\nlength\n(\n1\n)\n \nas\n \nR\n\n  \non\n \nT\n.\nroomNo\n \n==\n \nR\n.\nroomNo\n\n\nselect\n \nT\n.\nroomNo\n,\n \nR\n.\ndeviceID\n,\n \nstart\n \nas\n \naction\n\n\ninsert\n \ninto\n \nRegulatorActionStream\n;\n\n\n\n\n\n\nSupported join types\n \n\n\nFollowing are the supported operations of a join clause.\n\n\n\n\n\n\nInner join (join)\n \n\n\nThis is the default behaviour of a join operation. \njoin\n is used as the keyword to join both the streams. The output is generated only if there is a matching event in both the streams.\n\n\n\n\n\n\nLeft outer join\n \n\n\nThe \nleft outer join\n operation allows you to join two streams to be merged based on a condition. \nleft outer join\n is used as the keyword to join both the streams.\n\n\nHere, it returns all the events of left stream even if there are no matching events in the right stream by \nhaving null values for the attributes of the right stream.\n\n\nExample\n\n\nThe following query generates output events for all events from the \nStockStream\n stream regardless of whether a matching \nsymbol exists in the \nTwitterStream\n stream or not.\n\n\n\nfrom StockStream#window.time(1 min) as S\n  left outer join TwitterStream#window.length(1) as T\n  on S.symbol== T.symbol\nselect S.symbol as symbol, T.tweet, S.price\ninsert into outputStream ;    \n\n\n\n\n\n\nRight outer join\n \n\n\nThis is similar to a left outer join. \nRight outer join\n is used as the keyword to join both the streams.\nIt returns all the events of the right stream even if there are no matching events in the left stream. \n\n\n\n\n\n\nFull outer join\n \n\n\nThe full outer join combines the results of left outer join and right outer join. \nfull outer join\n is used as the keyword to join both the streams.\nHere, output event are generated for each incoming event even if there are no matching events in the other stream.\n\n\nExample\n\n\nThe following query generates output events for all the incoming events of each stream regardless of whether there is a \nmatch for the \nsymbol\n attribute in the other stream or not.\n\n\n\nfrom StockStream#window.time(1 min) as S\n  full outer join TwitterStream#window.length(1) as T\n  on S.symbol== T.symbol\nselect S.symbol as symbol, T.tweet, S.price\ninsert into outputStream ;    \n\n\n\n\n\n\nPattern\n\n\nThis is a state machine implementation that allows you to detect patterns in the events that arrive over time. This can correlate events within a single stream or between multiple streams. \n\n\nPurpose\n \n\n\nPatterns allow you to identify trends in events over a time period.\n\n\nSyntax\n\n\nThe following is the syntax for a pattern query:\n\n\nfrom\n \n(\nevery\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n]\n \n-\n \n    \n(\nevery\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n \n[\nfilter\n \ncondition\n]\n \n-\n \n    \n...\n \n    \n(\nwithin\n \ntime\n \ngap\n)\n?\n     \n\nselect\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\n\n\n\n\nItems\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-\n\n\nThis is used to indicate an event that should be following another event. The subsequent event does not necessarily have to occur immediately after the preceding event. The condition to be met by the preceding event should be added before the sign, and the condition to be met by the subsequent event should be added after the sign.\n\n\n\n\n\n\nevent reference\n\n\nThis allows you to add a reference to the the matching event so that it can be accessed later for further processing.\n\n\n\n\n\n\n(within \ntime gap\n)?\n\n\nThe \nwithin\n clause is optional. It defines the time duration within which all the matching events should occur.\n\n\n\n\n\n\nevery\n\n\nevery\n is an optional keyword. This defines whether the event matching should be triggered for every event arrival in the specified stream with the matching condition. \n When this keyword is not used, the matching is carried out only once.\n\n\n\n\n\n\n\n\nSiddhi also supports pattern matching with counting events and matching events in a logical order such as (\nand\n, \nor\n, and \nnot\n). These are described in detail further below in this guide.\n\n\nExample\n\n\nThis query sends an alert if the temperature of a room increases by 5 degrees within 10 min.\n\n\nfrom\n \nevery\n(\n \ne1\n=\nTempStream\n \n)\n \n-\n \ne2\n=\nTempStream\n[\n \ne1\n.\nroomNo\n \n==\n \nroomNo\n \nand\n \n(\ne1\n.\ntemp\n \n+\n \n5\n)\n \n=\n \ntemp\n \n]\n\n    \nwithin\n \n10\n \nmin\n\n\nselect\n \ne1\n.\nroomNo\n,\n \ne1\n.\ntemp\n \nas\n \ninitialTemp\n,\n \ne2\n.\ntemp\n \nas\n \nfinalTemp\n\n\ninsert\n \ninto\n \nAlertStream\n;\n\n\n\n\n\n\nHere, the matching process begins for each event in the \nTempStream\n stream (because \nevery\n is used with \ne1=TempStream\n), \nand if  another event arrives within 10 minutes with a value for the \ntemp\n attribute that is greater than or equal to \ne1.temp + 5\n \nof the event e1, an output is generated via the \nAlertStream\n.\n\n\nCounting Pattern\n\n\nCounting patterns allow you to match multiple events that may have been received for the same matching condition.\nThe number of events matched per condition can be limited via condition postfixes.\n\n\nSyntax\n\n\nEach matching condition can contain a collection of events with the minimum and maximum number of events to be matched as shown in the syntax below. \n\n\nfrom\n \n(\nevery\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n]\n \n(\nmin\n \ncount\n:\nmax\n \ncount\n)\n?\n \n-\n  \n    \n...\n \n    \n(\nwithin\n \ntime\n \ngap\n)\n?\n     \n\nselect\n \nevent\n \nreference\n([\nevent\n \nindex\n])\n?\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\n\n\n\n\nPostfix\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nn1:n2\n\n\nThis matches \nn1\n to \nn2\n events (including \nn1\n and not more than \nn2\n).\n\n\n1:4\n matches 1 to 4 events.\n\n\n\n\n\n\nn:\n\n\nThis matches \nn\n or more events (including \nn\n).\n\n\n2:\n matches 2 or more events.\n\n\n\n\n\n\n:n\n\n\nThis matches up to \nn\n events (excluding \nn\n).\n\n\n:5\n matches up to 5 events.\n\n\n\n\n\n\nn\n\n\nThis matches exactly \nn\n events.\n\n\n5\n matches exactly 5 events.\n\n\n\n\n\n\n\n\nSpecific occurrences of the event in a collection can be retrieved by using an event index with its reference.\nSquare brackets can be used to indicate the event index where \n1\n can be used as the index of the first event and \nlast\n can be used as the index\n for the \nlast\n available event in the event collection. If you provide an index greater then the last event index,\n the system returns \nnull\n. The following are some valid examples.\n\n\n\n\ne1[3]\n refers to the 3rd event.\n\n\ne1[last]\n refers to the last event.\n\n\ne1[last - 1]\n refers to the event before the last event.\n\n\n\n\nExample\n\n\nThe following Siddhi App calculates the temperature difference between two regulator events.\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\ndefine\n \nstream\n \nRegulatorStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntempSet\n \ndouble\n,\n \nisOn\n \nbool\n);\n\n\n\nfrom\n \nevery\n(\n \ne1\n=\nRegulatorStream\n)\n \n-\n \ne2\n=\nTempStream\n[\ne1\n.\nroomNo\n==\nroomNo\n]\n1\n:\n \n-\n \ne3\n=\nRegulatorStream\n[\ne1\n.\nroomNo\n==\nroomNo\n]\n\n\nselect\n \ne1\n.\nroomNo\n,\n \ne2\n[\n0\n].\ntemp\n \n-\n \ne2\n[\nlast\n].\ntemp\n \nas\n \ntempDiff\n\n\ninsert\n \ninto\n \nTempDiffStream\n;\n\n\n\n\n\n\nLogical Patterns\n\n\nLogical patterns match events that arrive in temporal order and correlate them with logical relationships such as \nand\n, \n\nor\n and \nnot\n. \n\n\nSyntax\n\n\nfrom\n \n(\nevery\n)\n?\n \n(\nnot\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n]\n \n          \n((\nand\n|\nor\n)\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n])\n?\n \n(\nwithin\n \ntime\n \ngap\n)\n?\n \n-\n  \n    \n...\n \n\nselect\n \nevent\n \nreference\n([\nevent\n \nindex\n])\n?\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nKeywords such as \nand\n, \nor\n, or \nnot\n can be used to illustrate the logical relationship.\n\n\n\n\n\n\n\n\nKey Word\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nand\n\n\nThis allows both conditions of \nand\n to be matched by two events in any order.\n\n\n\n\n\n\nor\n\n\nThe state succeeds if either condition of \nor\n is satisfied. Here the event reference of the other condition is \nnull\n.\n\n\n\n\n\n\nnot \ncondition1\n and \ncondition2\n\n\nWhen \nnot\n is included with \nand\n, it identifies the events that match \n arriving before any event that match \n.\n\n\n\n\n\n\nnot \ncondition\n for \ntime period\n\n\nWhen \nnot\n is included with \nfor\n, it allows you to identify a situation where no event that matches \ncondition1\n arrives during the specified \ntime period\n.  e.g.,\nfrom not TemperatureStream[temp \n 60] for 5 sec\n.\n\n\n\n\n\n\n\n\nHere the \nnot\n pattern can be followed by either an \nand\n clause or the effective period of \nnot\n can be concluded after a given \ntime period\n. Further in Siddhi more than two streams cannot be matched with logical conditions using \nand\n, \nor\n, or \nnot\n clauses at this point.\n\n\nDetecting Non-occurring Events\n\n\nSiddhi allows you to detect non-occurring events via multiple combinations of the key words specified above as shown in the table below.\n\n\nIn the patterns listed, P* can be either a regular event pattern, an absent event pattern or a logical pattern.\n\n\n\n\n\n\n\n\nPattern\n\n\nDetected Scenario\n\n\n\n\n\n\n\n\n\n\nnot A for \ntime period\n\n\nThe non-occurrence of event A within \ntime period\n after system start up.\n e.g., Generating an alert if a taxi has not reached its destination within 30 minutes, to indicate that the passenger might be in danger.\n\n\n\n\n\n\nnot A for \ntime period\n and B\n\n\nAfter system start up, event A does not occur within \ntime period\n, but event B occurs at some point in time. \n e.g., Generating an alert if a taxi has not reached its destination within 30 minutes, and the passenger marked that he/she is in danger at some point in time.\n\n\n\n\n\n\nnot A for \ntime period 1\n and not B for \ntime period 2\n\n\nAfter system start up, event A doess not occur within \ntime period 1\n, and event B also does not occur within \ntime period 2\n. \n e.g., Generating an alert if the driver of a taxi has not reached the destination within 30 minutes, and the passenger has not marked himself/herself to be in danger within that same time period.\n\n\n\n\n\n\nnot A for \ntime period\n or B\n\n\nAfter system start up, either event A does not occur within \ntime period\n, or event B occurs at some point in time. \n e.g., Generating an alert if the taxi has not reached its destination within 30 minutes, or if the passenger has marked that he/she is in danger at some point in time.\n\n\n\n\n\n\nnot A for \ntime period 1\n or not B for \ntime period 2\n\n\nAfter system start up, either event A does not occur within \ntime period 1\n, or event B occurs within \ntime period 2\n. \n e.g., Generating an alert to indicate that the driver is not on an expected route if the taxi has not reached destination A within 20 minutes, or reached destination B within 30 minutes.\n\n\n\n\n\n\nA \u2192 not B for \ntime period\n\n\nEvent B does not occur within \ntime period\n after the occurrence of event A. e.g., Generating an alert if the taxi has reached its destination, but this was not followed by a payment record.\n\n\n\n\n\n\nP* \u2192 not A for \ntime period\n and B\n\n\nAfter the occurrence of P*, event A does not occur within \ntime period\n, and event B occurs at some point in time. \n\n\n\n\n\n\nP* \u2192 not A for \ntime period 1\n and not B for \ntime period 2\n\n\nAfter the occurrence of P*, event A does not occur within \ntime period 1\n, and event B does not occur within \ntime period 2\n.\n\n\n\n\n\n\nP* \u2192 not A for \ntime period\n or B\n\n\nAfter the occurrence of P*, either event A does not occur within \ntime period\n, or event B occurs at some point in time.\n\n\n\n\n\n\nP* \u2192 not A for \ntime period 1\n or not B for \ntime period 2\n\n\nAfter the occurrence of P*, either event A does not occur within \ntime period 1\n, or event B does not occur within \ntime period 2\n.\n\n\n\n\n\n\nnot A for \ntime period\n \u2192 B\n\n\nEvent A does occur within \ntime period\n after the system start up, but event B occurs after that \ntime period\n has elapsed.\n\n\n\n\n\n\nnot A for \ntime period\n and B \u2192 P*\n\n\nEvent A does not occur within \ntime period\n, and event B occurs at some point in time. Then P* occurs after the \ntime period\n has elapsed, and after B has occurred.\n\n\n\n\n\n\nnot A for \ntime period 1\n and not B for \ntime period 2\n \u2192 P*\n\n\nAfter system start up, event A does not occur within \ntime period 1\n, and event B does not occur within \ntime period 2\n. However, P* occurs after both A and B.\n\n\n\n\n\n\nnot A for \ntime period\n or B \u2192 P*\n\n\nAfter system start up, event A does not occur within \ntime period\n or event B occurs at some point in time. The P* occurs after \ntime period\n has elapsed, or after B has occurred.\n\n\n\n\n\n\nnot A for \ntime period 1\n or not B for \ntime period 2\n \u2192 P*\n\n\nAfter system start up, either event A does not occur within \ntime period 1\n, or event B does not occur within \ntime period 2\n. Then P*  occurs after both \ntime period 1\n and \ntime period 2\n have elapsed.\n\n\n\n\n\n\nnot A and B\n\n\nEvent A does not occur before event B.\n\n\n\n\n\n\nA and not B\n\n\nEvent B does not occur before event A.\n\n\n\n\n\n\n\n\nExample\n\n\nFollowing Siddhi App, sends the \nstop\n control action to the regulator when the key is removed from the hotel room. \n\n\ndefine\n \nstream\n \nRegulatorStateChangeStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntempSet\n \ndouble\n,\n \naction\n \nstring\n);\n\n\ndefine\n \nstream\n \nRoomKeyStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \naction\n \nstring\n);\n\n\n\n\nfrom\n \nevery\n(\n \ne1\n=\nRegulatorStateChangeStream\n[\n \naction\n \n==\n \non\n \n]\n \n)\n \n-\n \n      \ne2\n=\nRoomKeyStream\n[\n \ne1\n.\nroomNo\n \n==\n \nroomNo\n \nand\n \naction\n \n==\n \nremoved\n \n]\n \nor\n \ne3\n=\nRegulatorStateChangeStream\n[\n \ne1\n.\nroomNo\n \n==\n \nroomNo\n \nand\n \naction\n \n==\n \noff\n]\n\n\nselect\n \ne1\n.\nroomNo\n,\n \nifThenElse\n(\n \ne2\n \nis\n \nnull\n,\n \nnone\n,\n \nstop\n \n)\n \nas\n \naction\n\n\nhaving\n \naction\n \n!=\n \nnone\n\n\ninsert\n \ninto\n \nRegulatorActionStream\n;\n\n\n\n\n\n\nThis Siddhi Application generates an alert if we have switch off the regulator before the temperature reaches 12 degrees.  \n\n\ndefine\n \nstream\n \nRegulatorStateChangeStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntempSet\n \ndouble\n,\n \naction\n \nstring\n);\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \ne1\n=\nRegulatorStateChangeStream\n[\naction\n \n==\n \nstart\n]\n \n-\n \nnot\n \nTempStream\n[\ne1\n.\nroomNo\n \n==\n \nroomNo\n \nand\n \ntemp\n \n \n12\n]\n \nand\n \ne2\n=\nRegulatorStateChangeStream\n[\naction\n \n==\n \noff\n]\n\n\nselect\n \ne1\n.\nroomNo\n \nas\n \nroomNo\n\n\ninsert\n \ninto\n \nAlertStream\n;\n\n\n\n\n\n\nThis Siddhi Application generates an alert if the temperature does not reduce to 12 degrees within 5 minutes of switching on the regulator.  \n\n\ndefine\n \nstream\n \nRegulatorStateChangeStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntempSet\n \ndouble\n,\n \naction\n \nstring\n);\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \ne1\n=\nRegulatorStateChangeStream\n[\naction\n \n==\n \nstart\n]\n \n-\n \nnot\n \nTempStream\n[\ne1\n.\nroomNo\n \n==\n \nroomNo\n \nand\n \ntemp\n \n \n12\n]\n \nfor\n \n5 min\n\n\nselect\n \ne1\n.\nroomNo\n \nas\n \nroomNo\n\n\ninsert\n \ninto\n \nAlertStream\n;\n\n\n\n\n\n\nSequence\n\n\nSequence is a state machine implementation that allows you to detect the sequence of event occurrences over time. \nHere \nall matching events need to arrive consecutively\n to match the sequence condition, and there cannot be any non-matching events arriving within a matching sequence of events.\nThis can correlate events within a single stream or between multiple streams. \n\n\nPurpose\n \n\n\nThis allows you to detect a specified event sequence over a specified time period. \n\n\nSyntax\n\n\nThe syntax for a sequence query is as follows:\n\n\nfrom\n \n(\nevery\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n],\n \n    \nevent\n \nreference\n=\ninput\n \nstream\n \n[\nfilter\n \ncondition\n],\n \n    \n...\n \n    \n(\nwithin\n \ntime\n \ngap\n)\n?\n     \n\nselect\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\n\n\n\n\nItems\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n,\n\n\nThis represents the immediate next event i.e., when an event that matches the first condition arrives, the event that arrives immediately after it should match the second condition.\n\n\n\n\n\n\nevent reference\n\n\nThis allows you to add a reference to the the matching event so that it can be accessed later for further processing.\n\n\n\n\n\n\n(within \ntime gap\n)?\n\n\nThe \nwithin\n clause is optional. It defines the time duration within which all the matching events should occur.\n\n\n\n\n\n\nevery\n\n\nevery\n is an optional keyword. This defines whether the matching event should be triggered for every event that arrives at the specified stream with the matching condition. \n When this keyword is not used, the matching is carried out only once.\n\n\n\n\n\n\n\n\nExample\n\n\nThis query generates an alert if the increase in the temperature between two consecutive temperature events exceeds one degree.\n\n\nfrom\n \nevery\n \ne1\n=\nTempStream\n,\n \ne2\n=\nTempStream\n[\ne1\n.\ntemp\n \n+\n \n1\n \n \ntemp\n]\n\n\nselect\n \ne1\n.\ntemp\n \nas\n \ninitialTemp\n,\n \ne2\n.\ntemp\n \nas\n \nfinalTemp\n\n\ninsert\n \ninto\n \nAlertStream\n;\n\n\n\n\n\n\nCounting Sequence\n\n\nCounting sequences allow you to match multiple events for the same matching condition.\nThe number of events matched per condition can be limited via condition postfixes such as \nCounting Patterns\n, or by using the \n\n*\n, \n+\n, and \n?\n operators.\n\n\nThe matching events can also be retrieved using event indexes, similar to how it is done in \nCounting Patterns\n.\n\n\nSyntax\n\n\nEach matching condition in a sequence can contain a collection of events as shown below. \n\n\nfrom\n \n(\nevery\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n](\n+|*|?\n)\n?\n,\n \n    \nevent\n \nreference\n=\ninput\n \nstream\n \n[\nfilter\n \ncondition\n](\n+|*|?\n)\n?\n,\n \n    \n...\n \n    \n(\nwithin\n \ntime\n \ngap\n)\n?\n     \n\nselect\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \nevent\n \nreference\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\n\n\n\n\nPostfix symbol\n\n\nRequired/Optional\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n+\n\n\nOptional\n\n\nThis matches \none or more\n events to the given condition.\n\n\n\n\n\n\n*\n\n\nOptional\n\n\nThis matches \nzero or more\n events to the given condition.\n\n\n\n\n\n\n?\n\n\nOptional\n\n\nThis matches \nzero or one\n events to the given condition.\n\n\n\n\n\n\n\n\nExample\n\n\nThis Siddhi application identifies temperature peeks.\n\n\ndefine\n \nstream\n \nTempStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \nevery\n \ne1\n=\nTempStream\n,\n \ne2\n=\nTempStream\n[\ne1\n.\ntemp\n \n=\n \ntemp\n]\n+\n,\n \ne3\n=\nTempStream\n[\ne2\n[\nlast\n].\ntemp\n \n \ntemp\n]\n\n\nselect\n \ne1\n.\ntemp\n \nas\n \ninitialTemp\n,\n \ne2\n[\nlast\n].\ntemp\n \nas\n \npeakTemp\n\n\ninsert\n \ninto\n \nPeekTempStream\n;\n\n\n\n\n\n\nLogical Sequence\n\n\nLogical sequences identify logical relationships using \nand\n, \nor\n and \nnot\n on consecutively arriving events.\n\n\nSyntax\n\nThe syntax for a logical sequence is as follows:\n\n\nfrom\n \n(\nevery\n)\n?\n \n(\nnot\n)\n?\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n]\n \n          \n((\nand\n|\nor\n)\n \nevent\n \nreference\n=\ninput\n \nstream\n[\nfilter\n \ncondition\n])\n?\n \n(\nwithin\n \ntime\n \ngap\n)\n?\n,\n \n    \n...\n \n\nselect\n \nevent\n \nreference\n([\nevent\n \nindex\n])\n?\n.\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nKeywords such as \nand\n, \nor\n, or \nnot\n can be used to illustrate the logical relationship, similar to how it is done in \nLogical Patterns\n. \n\n\nExample\n\n\nThis Siddhi application notifies the state when a regulator event is immediately followed by both temperature and humidity events. \n\n\ndefine\n \nstream\n \nTempStream\n(\ndeviceID\n \nlong\n,\n \ntemp\n \ndouble\n);\n\n\ndefine\n \nstream\n \nHumidStream\n(\ndeviceID\n \nlong\n,\n \nhumid\n \ndouble\n);\n\n\ndefine\n \nstream\n \nRegulatorStream\n(\ndeviceID\n \nlong\n,\n \nisOn\n \nbool\n);\n\n\n\nfrom\n \nevery\n \ne1\n=\nRegulatorStream\n,\n \ne2\n=\nTempStream\n \nand\n \ne3\n=\nHumidStream\n\n\nselect\n \ne2\n.\ntemp\n,\n \ne3\n.\nhumid\n\n\ninsert\n \ninto\n \nStateNotificationStream\n;\n\n\n\n\n\n\nOutput rate limiting\n\n\nOutput rate limiting allows queries to output events periodically based on a specified condition.\n\n\nPurpose\n\n\nThis allows you to limit the output to avoid overloading the subsequent executions, and to remove unnecessary information.\n\n\nSyntax\n\n\nThe syntax of an output rate limiting configuration is as follows:\n\n\nfrom\n \ninput\n \nstream\n \n...\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\noutput\n \nrate\n \nlimiting\n \nconfiguration\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nSiddhi supports three types of output rate limiting configurations as explained in the following table: \n\n\n\n\n\n\n\n\nRate limiting configuration\n\n\nSyntax\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBased on time\n\n\noutput event\n every \ntime interval\n\n\nThis outputs \noutput event\n every \ntime interval\n time interval.\n\n\n\n\n\n\nBased on number of events\n\n\noutput event\n every \nevent interval\n events\n\n\nThis outputs \noutput event\n for every \nevent interval\n number of events.\n\n\n\n\n\n\nSnapshot based output\n\n\nsnapshot every \ntime interval\n\n\nThis outputs all events in the window (or the last event if no window is defined in the query) for every given \ntime interval\n time interval.\n\n\n\n\n\n\n\n\nHere the \noutput event\n specifies the event(s) that should be returned as the output of the query. \nThe possible values are as follows:\n\n \nfirst\n : Only the first event processed by the query during the specified time interval/sliding window is emitted.\n\n \nlast\n : Only the last event processed by the query during the specified time interval/sliding window is emitted.\n* \nall\n : All the events processed by the query during the specified time interval/sliding window are emitted. \nWhen no \noutput event\n is defined, \nall\n is used by default.\n\n\nExamples\n\n\n\n\n\n\nReturning events based on the number of events\n\n\nHere, events are emitted every time the specified number of events arrive. You can also specify whether to emit only the first event/last event, or all the events out of the events that arrived.\n\n\nIn this example, the last temperature per sensor is emitted for every 10 events.\n\n\n\nfrom TempStreamselect \nselect temp, deviceID\ngroup by deviceID\noutput last every 10 events\ninsert into LowRateTempStream;    \n\n\n\n\n\n\nReturning events based on time\n\n\nHere events are emitted for every predefined time interval. You can also specify whether to emit only the first event, last event, or all events out of the events that arrived during the specified time interval.\n\n\nIn this example, emits all temperature events every 10 seconds  \n\n\n\nfrom TempStreamoutput \noutput every 10 sec\ninsert into LowRateTempStream;    \n\n\n\n\n\n\nReturning a periodic snapshot of events\n\n\nThis method works best with windows. When an input stream is connected to a window, snapshot rate limiting emits all the current events that have arrived and do not have corresponding expired events for every predefined time interval. \nIf the input stream is not connected to a window, only the last current event for each predefined time interval is emitted.\n\n\nThis query emits a snapshot of the events in a time window of 5 seconds every 1 second. \n\n\n\nfrom TempStream#window.time(5 sec)\noutput snapshot every 1 sec\ninsert into SnapshotTempStream;    \n\n\n\n\n\n\nPartition\n\n\nPartitions divide streams and queries into isolated groups in  order to process them in parallel and in isolation. \nA partition can contain one or more queries and there can be multiple instances where the same queries and streams are replicated for each partition. \nEach partition is tagged with a partition key. Those partitions only process the events that match the corresponding partition key. \n\n\nPurpose\n \n\n\nPartitions allow you to process the events groups in isolation so that event processing can be performed using the same set of queries for each group. \n\n\nPartition key generation\n\n\nA partition key can be generated in the following two methods:\n\n\n\n\n\n\nPartition by value\n\n\nThis is created by generating unique values using input stream attributes.\n\n\nSyntax\n\n\n\npartition with ( \nexpression\n of \nstream name\n, \nexpression\n of \nstream name\n, ... )\nbegin\n    \nquery\n\n    \nquery\n\n    ...\nend; \n\n\nExample\n\n\nThis query calculates the maximum temperature recorded within the last 10 events per \ndeviceID\n.\n\n\n\npartition with ( deviceID of TempStream )\nbegin\n    from TempStream#window.length(10)\n    select roomNo, deviceID, max(temp) as maxTemp\n    insert into DeviceTempStream;\nend;\n\n\n\n\n\n\n\nPartition by range\n\n\nThis is created by mapping each partition key to a range condition of the input streams numerical attribute.\n\n\nSyntax\n\n\n\npartition with ( \ncondition\n as \npartition key\n or \ncondition\n as \npartition key\n or ... of \nstream name\n, ... )\nbegin\n    \nquery\n\n    \nquery\n\n    ...\nend;\n\n\n\nExample\n\n\nThis query calculates the average temperature for the last 10 minutes per office area.\n\n\n\npartition with ( roomNo \n= 1030 as 'serverRoom' or \n                 roomNo \n 1030 and roomNo \n= 330 as 'officeRoom' or \n                 roomNo \n 330 as 'lobby' of TempStream)\nbegin\n    from TempStream#window.time(10 min)\n    select roomNo, deviceID, avg(temp) as avgTemp\n    insert into AreaTempStream\nend;\n\n  \n\n\n\n\n\n\nInner Stream\n\n\nQueries inside a partition block can use inner streams to communicate with each other while preserving partition isolation.\nInner streams are denoted by a \"#\" placed before the stream name, and these streams cannot be accessed outside a partition block. \n\n\nPurpose\n\n\nInner streams allow you to connect queries within the partition block so that the output of a query can be used as an input only by another query \nwithin the same partition. Therefore, you do not need to repartition the streams if they are communicating within the partition.\n\n\nExample\n\n\nThis partition calculates the average temperature of every 10 events for each sensor, and sends an output to the \nDeviceTempIncreasingStream\n stream if the consecutive average temperature values increase by more than \n5 degrees.\n\n\n\npartition with ( deviceID of TempStream )\nbegin\n    from TempStream#window.lengthBatch(10)\n    select roomNo, deviceID, avg(temp) as avgTemp\n    insert into #AvgTempStream\n\n    from every (e1=#AvgTempStream),e2=#AvgTempStream[e1.avgTemp + 5 \n<\n avgTemp]\n    select e1.deviceID, e1.avgTemp as initialAvgTemp, e2.avgTemp as finalAvgTemp\n    insert into DeviceTempIncreasingStream\nend;\n\n\n\n\nTable\n\n\nA table is a stored version of an stream or a table of events. Its schema is defined via the \ntable definition\n that is\nsimilar to a stream definition. These events are by default stored \nin-memory\n, but Siddhi also provides store extensions to work with data/events stored in various data stores through the \ntable abstraction.\n\n\nPurpose\n\n\nTables allow Siddhi to work with stored events. By defining a schema for tables Siddhi enables them to be processed by queries using their defined attributes with the streaming data. You can also interactively query the state of the stored events in the table.\n\n\nSyntax\n\n\nThe syntax for a new table definition is as follows:\n\n\ndefine\n \ntable\n \ntable\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n);\n\n\n\n\n\n\nThe following parameters are configured in a table definition:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntable name\n\n\nThe name of the table defined. (\nPascalCase\n is used for table name as a convention.)\n\n\n\n\n\n\nattribute name\n\n\nThe schema of the table is defined by its attributes with uniquely identifiable attribute names (\ncamelCase\n is used for attribute names as a convention.)\n\n\n\n\n\n\nattribute type\n\n\nThe type of each attribute defined in the schema. \n This can be \nSTRING\n, \nINT\n, \nLONG\n, \nDOUBLE\n, \nFLOAT\n, \nBOOL\n or \nOBJECT\n.\n\n\n\n\n\n\n\n\nExample\n\n\nThe following defines a table named \nRoomTypeTable\n with \nroomNo\n and \ntype\n attributes of data types \nint\n and \nstring\n respectively.\n\n\ndefine\n \ntable\n \nRoomTypeTable\n \n(\n \nroomNo\n \nint\n,\n \ntype\n \nstring\n \n);\n\n\n\n\n\n\nPrimary Keys\n\n\nTables can be configured with primary keys to avoid the duplication of data. \n\n\nPrimary keys are configured by including the \n@PrimaryKey( 'key1', 'key2' )\n annotation to the table definition. \nEach event table configuration can have only one \n@PrimaryKey\n annotation. \nThe number of attributes supported differ based on the table implementations. When more than one attribute \n is used for the primary key, the uniqueness of the events stored in the table is determined based on the combination of values for those attributes.\n\n\nExamples\n\n\nThis query creates an event table with the \nsymbol\n attribute as the primary key. \nTherefore each entry in this table must have a unique value for \nsymbol\n attribute.\n\n\n@\nPrimaryKey\n(\nsymbol\n)\n\n\ndefine\n \ntable\n \nStockTable\n \n(\nsymbol\n \nstring\n,\n \nprice\n \nfloat\n,\n \nvolume\n \nlong\n);\n\n\n\n\n\n\nIndexes\n\n\nIndexes allow tables to be searched/modified much faster. \n\n\nIndexes are configured by including the \n@Index( 'key1', 'key2' )\n annotation to the table definition.\n Each event table configuration can have 0-1 \n@Index\n annotations. \n Support for the \n@Index\n annotation and the number of attributes supported differ based on the table implementations. \n When more then one attribute is used for index, each one of them is used to index the table for fast access of the data. \n Indexes can be configured together with primary keys. \n\n\nExamples\n\n\nThis query creates an indexed event table named \nRoomTypeTable\n with the \nroomNo\n attribute as the index key.\n\n\n@\nIndex\n(\nroomNo\n)\n\n\ndefine\n \ntable\n \nRoomTypeTable\n \n(\nroomNo\n \nint\n,\n \ntype\n \nstring\n);\n\n\n\n\n\n\nStore\n\n\nStore is a table that refers to data/events stored in data stores outside of Siddhi such as RDBMS, Cassandra, etc. \nStore is defined via the \n@store\n annotation, and the store schema is defined via a \ntable definition\n associated with it.\n\n\nPurpose\n\n\nStore allows Siddhi to search, retrieve and manipulate data stored in external data stores through Siddhi queries. \n\n\nSyntax\n\n\nThe syntax for a defining store and it's associated table definition is as follows:\n\n\n@\nstore\n(\ntype\n=\nstore_type\n,\n \nstatic\n.\noption\n.\nkey1\n=\nstatic_option_value1\n,\n \nstatic\n.\noption\n.\nkeyN\n=\nstatic_option_valueN\n)\n\n\ndefine\n \ntable\n \nTableName\n \n(\nattribute1\n \nType1\n,\n \nattributeN\n \nTypeN\n);\n\n\n\n\n\n\nExample\n\n\nThe following defines a RDBMS data store pointing to a MySQL database with name \nhotel\n hosted in \nloacalhost:3306\n \nhaving a table \nRoomTypeTable\n with columns \nroomNo\n of \nINTEGER\n and \ntype\n of \nVARCHAR(255)\n mapped to Siddhi data types \nint\n and \nstring\n respectively.\n\n\n@\nStore\n(\ntype\n=\nrdbms\n,\n \njdbc\n.\nurl\n=\njdbc:mysql://localhost:3306/hotel\n,\n \nusername\n=\nsiddhi\n,\n \npassword\n=\n123\n,\n \n       \njdbc\n.\ndriver\n.\nname\n=\ncom.mysql.jdbc.Driver\n)\n\n\ndefine\n \ntable\n \nRoomTypeTable\n \n(\n \nroomNo\n \nint\n,\n \ntype\n \nstring\n \n);\n\n\n\n\n\n\nSupported Store Types\n\n\nThe following is a list of currently supported store types:\n\n\n\n\nRDBMS (MySQL, Oracle, SQL Server, PostgreSQL, DB2, H2)\n\n\nSolr\n\n\nMongoDB\n\n\nHBase\n\n\nRedis\n\n\nCassandra\n\n\n\n\nOperators on Table (and Store)\n\n\nThe following operators can be performed on tables (and stores).\n\n\nInsert\n\n\nThis allows events to be inserted into tables. This is similar to inserting events into streams. \n\n\n\n\nWarning\n\n\nIf the table is defined with primary keys, and if you insert duplicate data, primary key constrain violations can occur. \nIn such cases use the \nupdate or insert into\n operation. \n\n\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n \n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \ntable\n\n\n\n\n\n\nSimilar to streams, you need to use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword between \ninsert\n and \ninto\n keywords in order to insert only the specific output event types. \nFor more information, see \noutput event type\n\n\nExample\n\n\nThis query inserts all the events from the \nTempStream\n stream to the \nTempTable\n table.\n\n\nfrom\n \nTempStream\n\n\nselect\n \n*\n\n\ninsert\n \ninto\n \nTempTable\n;\n\n\n\n\n\n\nJoin (Table)\n\n\nThis allows a stream to retrieve information from a table in a streaming manner.\n\n\n\n\nNote\n\n\nJoins can also be performed with \ntwo streams\n, \naggregation\n or against externally \ndefined windows\n.\n\n\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n \njoin\n \ntable\n\n    \non\n \ncondition\n\n\nselect\n \n(\ninput\n \nstream\n|\ntable\n).\nattribute\n \nname\n,\n \n(\ninput\n \nstream\n|\ntable\n).\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\n\n\nNote\n\n\nA table can only be joint with a stream. Two tables cannot be joint because there must be at least one active \nentity to trigger the join operation.\n\n\n\n\nExample\n\n\nThis Siddhi App performs a join to retrieve the room type from \nRoomTypeTable\n table based on the room number, so that it can filter the events related to \nserver-room\ns.\n\n\ndefine\n \ntable\n \nRoomTypeTable\n \n(\nroomNo\n \nint\n,\n \ntype\n \nstring\n);\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \nTempStream\n \njoin\n \nRoomTypeTable\n\n    \non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \nTempStream\n.\nroomNo\n\n\nselect\n \ndeviceID\n,\n \nRoomTypeTable\n.\ntype\n \nas\n \nroomType\n,\n \ntype\n,\n \ntemp\n\n    \nhaving\n \nroomType\n \n==\n \nserver-room\n\n\ninsert\n \ninto\n \nServerRoomTempStream\n;\n\n\n\n\n\n\nSupported join types\n \n\n\nTable join supports following join operations.\n\n\n\n\n\n\nInner join (join)\n \n\n\nThis is the default behaviour of a join operation. \njoin\n is used as the keyword to join the stream with the table. The output is generated only if there is a matching event in both the stream and the table.\n\n\n\n\n\n\nLeft outer join\n \n\n\nThe \nleft outer join\n operation allows you to join a stream on left side with a table on the right side based on a condition.\nHere, it returns all the events of left stream even if there are no matching events in the right table by \nhaving null values for the attributes of the right table.\n\n\n\n\n\n\nRight outer join\n \n\n\nThis is similar to a \nleft outer join\n. \nright outer join\n is used as the keyword to join a stream on right side with a table on the left side based on a condition.\nIt returns all the events of the right stream even if there are no matching events in the left table. \n\n\n\n\n\n\nDelete\n\n\nTo delete selected events that are stored in a table.\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n \n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ndelete\n \ntable\n \n(\nfor\n \noutput\n \nevent\n \ntype\n)\n?\n\n    \non\n \ncondition\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected to be deleted. \nWhen specifying the condition, table attributes should be referred to with the table name.\n\n\nTo execute delete for specific output event types, use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword with \nfor\n as shown\nin the syntax. For more information, see \noutput event type\n\n\n\n\nNote\n\n\nTable attributes must be always referred to with the table name as follows: \n\ntable name\n.\nattibute name\n\n\n\n\nExample\n\n\nIn this example, the script deletes a record in the \nRoomTypeTable\n table if it has a value for the \nroomNo\n attribute that matches the value for the \nroomNumber\n attribute of an event in the \nDeleteStream\n stream.\n\n\ndefine\n \ntable\n \nRoomTypeTable\n \n(\nroomNo\n \nint\n,\n \ntype\n \nstring\n);\n\n\n\ndefine\n \nstream\n \nDeleteStream\n \n(\nroomNumber\n \nint\n);\n\n\n\nfrom\n \nDeleteStream\n\n\ndelete\n \nRoomTypeTable\n\n    \non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \nroomNumber\n;\n\n\n\n\n\n\nUpdate\n\n\nThis operator updates selected event attributes stored in a table based on a condition. \n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n \n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\nupdate\n \ntable\n \n(\nfor\n \noutput\n \nevent\n \ntype\n)\n?\n \n    \nset\n \ntable\n.\nattribute\n \nname\n \n=\n \n(\nattribute\n \nname\n|\nexpression\n)\n?\n,\n \ntable\n.\nattribute\n \nname\n \n=\n \n(\nattribute\n \nname\n|\nexpression\n)\n?\n,\n \n...\n\n    \non\n \ncondition\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected to be updated.\nWhen specifying the \ncondition\n, table attributes must be referred to with the table name.\n\n\nYou can use the \nset\n keyword to update selected attributes from the table. Here, for each assignment, the attribute specified in the left must be the table attribute, and the one specified in the right can be a stream/table attribute a mathematical operation, or other. When the \nset\n clause is not provided, all the attributes in the table are updated.\n\n\nTo execute an update for specific output event types use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword with \nfor\n as shown\nin the syntax. For more information, see \noutput event type\n.\n\n\n\n\nNote\n\n\nTable attributes must be always referred to with the table name as shown below:\n \ntable name\n.\nattibute name\n.\n\n\n\n\nExample\n\n\nThis Siddhi application updates the room occupancy in the \nRoomOccupancyTable\n table for each room number based on new arrivals and exits from the \nUpdateStream\n stream.\n\n\ndefine\n \ntable\n \nRoomOccupancyTable\n \n(\nroomNo\n \nint\n,\n \npeople\n \nint\n);\n\n\ndefine\n \nstream\n \nUpdateStream\n \n(\nroomNumber\n \nint\n,\n \narrival\n \nint\n,\n \nexit\n \nint\n);\n\n\n\nfrom\n \nUpdateStream\n\n\nselect\n \n*\n\n\nupdate\n \nRoomOccupancyTable\n\n    \nset\n \nRoomOccupancyTable\n.\npeople\n \n=\n \nRoomOccupancyTable\n.\npeople\n \n+\n \narrival\n \n-\n \nexit\n\n    \non\n \nRoomOccupancyTable\n.\nroomNo\n \n==\n \nroomNumber\n;\n\n\n\n\n\n\nUpdate or Insert\n\n\nThis allows you update if the event attributes already exist in the table based on a condition, or \nelse insert the entry as a new attribute.\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n \n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\nupdate\n \nor\n \ninsert\n \ninto\n \ntable\n \n(\nfor\n \noutput\n \nevent\n \ntype\n)\n?\n \n    \nset\n \ntable\n.\nattribute\n \nname\n \n=\n \nexpression\n,\n \ntable\n.\nattribute\n \nname\n \n=\n \nexpression\n,\n \n...\n\n    \non\n \ncondition\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected for update.\nWhen specifying the \ncondition\n, table attributes should be referred to with the table name. \nIf a record that matches the condition does not already exist in the table, the arriving event is inserted into the table.\n\n\nThe \nset\n clause is only used when an update is performed during the insert/update operation. \nWhen \nset\n clause is used, the attribute to the left is always a table attribute, and the attribute to the right can be a stream/table attribute, mathematical \noperation or other. The attribute to the left (i.e., the attribute in the event table) is updated with the value of the attribute to the right if the given condition is met. When the \nset\n clause is not provided, all the attributes in the table are updated. \n\n\n\n\nNote\n\n\nWhen the attribute to the right is a table attribute, the operations supported differ based on the database type.\n\n\n\n\nTo execute update upon specific output event types use the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword with \nfor\n as shown\nin the syntax. To understand more see \noutput event type\n.\n\n\n\n\nNote\n\n\nTable attributes should be always referred to with the table name as \ntable name\n.\nattibute name\n.\n\n\n\n\nExample\n\n\nThe following query update for events in the \nUpdateTable\n event table that have room numbers that match the same in the \nUpdateStream\n stream. When such events are found in the event table, they are updated. When a room number available in the stream is not found in the event table, it is inserted from the stream.\n\n\ndefine\n \ntable\n \nRoomAssigneeTable\n \n(\nroomNo\n \nint\n,\n \ntype\n \nstring\n,\n \nassignee\n \nstring\n);\n\n\ndefine\n \nstream\n \nRoomAssigneeStream\n \n(\nroomNumber\n \nint\n,\n \ntype\n \nstring\n,\n \nassignee\n \nstring\n);\n\n\n\nfrom\n \nRoomAssigneeStream\n\n\nselect\n \nroomNumber\n \nas\n \nroomNo\n,\n \ntype\n,\n \nassignee\n\n\nupdate\n \nor\n \ninsert\n \ninto\n \nRoomAssigneeTable\n\n    \nset\n \nRoomAssigneeTable\n.\nassignee\n \n=\n \nassignee\n\n    \non\n \nRoomAssigneeTable\n.\nroomNo\n \n==\n \nroomNo\n;\n\n\n\n\n\n\nIn\n\n\nThis allows the stream to check whether the expected value exists in the table as a part of a conditional operation.\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n[\ncondition\n \nin\n \ntable\n]\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which events are selected to be compared. \nWhen constructing the \ncondition\n, the table attribute must be always referred to with the table name as shown below:\n\ntable\n.\nattibute name\n.\n\n\nExample\n\n\nThis Siddhi application filters only room numbers that are listed in the \nServerRoomTable\n table.\n\n\ndefine\n \ntable\n \nServerRoomTable\n \n(\nroomNo\n \nint\n);\n\n\ndefine\n \nstream\n \nTempStream\n \n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \nTempStream\n[\nServerRoomTable\n.\nroomNo\n \n==\n \nroomNo\n \nin\n \nServerRoomTable\n]\n\n\ninsert\n \ninto\n \nServerRoomTempStream\n;\n\n\n\n\n\n\nIncremental Aggregation\n\n\nIncremental aggregation allows you to obtain aggregates in an incremental manner for a specified set of time periods.\n\n\nThis not only allows you to calculate aggregations with varied time granularity, but also allows you to access them in an interactive\n manner for reports, dashboards, and for further processing. Its schema is defined via the \naggregation definition\n.\n\n\nIncremental aggregation granularity data holders are automatically purged every 15 minutes. When carrying out data purging, the retention period you have specified for each granularity in the incremental aggregation query is taken into account. The retention period defined for a granularity needs to be greater than or equal to its minimum retention period as specified in the table below. If no valid retention period is defined for a granularity, the default retention period (as specified in the table below) is applied. \n\n\n\n\n\n\n\n\nGranularity\n\n\nDefault retention\n\n\nMinimum retention\n\n\n\n\n\n\n\n\n\n\nsecond\n\n\n120\n seconds\n\n\n120\n seconds\n\n\n\n\n\n\nminute\n\n\n24\n  hours\n\n\n120\n minutes\n\n\n\n\n\n\nhour\n\n\n30\n  days\n\n\n25\n  hours\n\n\n\n\n\n\nday\n\n\n1\n   year\n\n\n32\n  days\n\n\n\n\n\n\nmonth\n\n\nAll\n\n\n13\n  month\n\n\n\n\n\n\nyear\n\n\nAll\n\n\nnone\n\n\n\n\n\n\n\n\nPurpose\n\n\nIncremental aggregation allows you to retrieve the aggregate values for different time durations. \nThat is, it allows you to obtain aggregates such as \nsum\n, \ncount\n, \navg\n, \nmin\n, \nmax\n, \ncount\n and \ndistinctCount\n\nof stream attributes for durations such as \nsec\n, \nmin\n, \nhour\n, etc.\n\n\nThis is of considerable importance in many Analytics scenarios because aggregate values are often needed for several time periods. \nFurthermore, this ensures that the aggregations are not lost due to unexpected system failures because aggregates can be stored in different persistence \nstores\n.\n\n\nSyntax\n\n\n@\nstore\n(\ntype\n=\nstore type\n,\n \n...)\n\n\n@\npurge\n(\nenable\n=\ntrue or false\n,\ninterval\n=\npurging\n \ninterval\n,\n@\nretentionPeriod\n(\ngranularity\n \n=\n \nretention\n \nperiod\n,\n \n...)\n \n)\n\n\ndefine\n \naggregation\n \naggregator\n \nname\n\n\nfrom\n \ninput\n \nstream\n\n\nselect\n \nattribute\n \nname\n,\n \naggregate\n \nfunction\n(\nattribute\n \nname\n)\n \nas\n \nattribute\n \nname\n,\n \n...\n\n    \ngroup\n \nby\n \nattribute\n \nname\n\n    \naggregate\n \nby\n \ntimestamp\n \nattribute\n \nevery\n \ntime\n \nperiods\n \n;\n\n\n\n\n\n\nThe above syntax includes the following:\n\n\n\n\n\n\n\n\nItem\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n@BufferSize\n\n\nDEPRECIATED FROM V4.2.0\n. This identifies the number of expired events to retain in a buffer in order\nto handle out of order event processing. This is an optional\nparameter that is applicable only if aggregation is based on external\ntimestamps (because events aggregated based on event arrival\ntime cannot be out of order). Siddhi determines whether an event is expired or not\nbased on the timestamp of the latest event and the most granular duration for\nwhich aggregation is calculated.\n e.g., If the aggregation is calculated for \nsec\u2026year\n, the most granular duration is seconds. Therefore, if the buffer size is \n3\n and events arrive during 51st, 52nd, 53rd and 54th seconds, all of the older aggregations (i.e., for 51st, 52nd and 53rd seconds) are kept in the buffer because the latest event arrived during the 54th second. \nThe default value is \n0\n.\n\n\n\n\n\n\n@IgnoreEventsOlderThanBuffer\n\n\nDEPRECIATED FROM V4.2.0\n.This annotation specifies whether or not to aggregate events older than the \nbuffer. If this parameter is set to \nfalse\n (which is default), any event \nolder than the buffer is aggregated with the oldest event in buffer. If \nthis parameter is set to \ntrue\n, any event older than the buffer is dropped. This is an optional annotation.\n\n\n\n\n\n\n@store\n\n\nThis annotation is used to refer to the data store where the calculated \naggregate results are stored. This annotation is optional. When \nno annotation is provided, the data is stored in the \nin-memory\n store.\n\n\n\n\n\n\n@purge\n\n\nThis annotation is used to configure purging in aggregation granularities.\n If this annotation is not provided, the default purging mentioned above is applied.\n If you want to disable automatic data purging, you can use this annotation as follows:\n'@purge(enable=false)\n/You should disable data purging if the aggregation query in included in the Siddhi application for read-only purposes.\n\n\n\n\n\n\n@retentionPeriod\n\n\nThis annotation is used to specify the length of time the data needs to be retained when carrying out data purging.\n If this annotation is not provided, the default retention period is applied.\n\n\n\n\n\n\naggregator name\n\n\nThis specifies a unique name for the aggregation so that it can be referred \nwhen accessing aggregate results.\n\n\n\n\n\n\ninput stream\n\n\nThe stream that feeds the aggregation. \nNote! this stream should be \nalready defined.\n\n\n\n\n\n\ngroup by \nattribute name\n\n\nThe \ngroup by\n clause is optional. If it is included in a Siddhi application, aggregate values \n are calculated per each \ngroup by\n attribute. If it is not used, all the\n events are aggregated together.\n\n\n\n\n\n\nby \ntimestamp attribute\n\n\nThis clause is optional. This defines the attribute that should be used as\n the timestamp. If this clause is not used, the event time is used by default.\n The timestamp could be given as either a \nstring\n or a \nlong\n value. If it is a \nlong\n value,\n the unix timestamp in milliseconds is expected (e.g. \n1496289950000\n). If it is \na \nstring\n value, the supported formats are \nyyyy\n-\nMM\n-\ndd\n \nHH\n:\nmm\n:\nss\n \n(if time is in GMT) and  \nyyyy\n-\nMM\n-\ndd\n \nHH\n:\nmm\n:\nss\n \nZ\n (if time is \nnot in GMT), here the ISO 8601 UTC offset must be provided for \nZ\n .\n(e.g., \n+05:30\n, \n-11:00\n).\n\n\n\n\n\n\ntime periods\n\n\nTime periods can be specified as a range where the minimum and the maximum value are separated by three dots, or as comma-separated values. \n e.g., A range can be specified as sec...year where aggregation is done per second, minute, hour, day, month and year. Comma-separated values can be specified as min, hour. \n Skipping time durations (e.g., min, day where the hour duration is skipped) when specifying comma-separated values is supported only from v4.1.1 onwards\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nFrom V4.2.0 onwards, aggregation is carried out at calendar start times for each granularity with the GMT timezone\n\n\n\n\n\n\nNote\n\n\nFrom V4.2.6 onwards, the same aggregation can be defined in multiple Siddhi apps for joining, however, \nonly one siddhi app should carry out the processing\n (i.e. the aggregation input stream should only feed events to one aggregation definition). \n\n\n\n\nExample\n\n\nThis Siddhi Application defines an aggregation named \nTradeAggregation\n to calculate the average and sum for the \nprice\n attribute of events arriving at the \nTradeStream\n stream. These aggregates are calculated per every time granularity in the second-year range.\n\n\ndefine\n \nstream\n \nTradeStream\n \n(\nsymbol\n \nstring\n,\n \nprice\n \ndouble\n,\n \nvolume\n \nlong\n,\n \ntimestamp\n \nlong\n);\n\n\n\n@\npurge\n(\nenable\n=\ntrue\n,\n \ninterval\n=\n10 sec\n,\n@\nretentionPeriod\n(\nsec\n=\n120 sec\n,\nmin\n=\n24 hours\n,\nhours\n=\n30 days\n,\ndays\n=\n1 year\n,\nmonths\n=\nall\n,\nyears\n=\nall\n))\n\n\ndefine\n \naggregation\n \nTradeAggregation\n\n  \nfrom\n \nTradeStream\n\n  \nselect\n \nsymbol\n,\n \navg\n(\nprice\n)\n \nas\n \navgPrice\n,\n \nsum\n(\nprice\n)\n \nas\n \ntotal\n\n    \ngroup\n \nby\n \nsymbol\n\n    \naggregate\n \nby\n \ntimestamp\n \nevery\n \nsec\n \n...\n \nyear\n;\n\n\n\n\n\n\nDistributed Aggregation\n\n\n\n\nNote\n\n\nDistributed Aggregation is only supported after v4.3.0\n\n\n\n\nDistributed Aggregation allows you to partially process aggregations in different shards. This allows Siddhi\napp in one shard to be responsible only for processing a part of the aggregation.\nHowever for this, all aggregations must be based on a common physical database(@store).\n\n\nSyntax\n\n\n@\nstore\n(\ntype\n=\nstore type\n,\n \n...)\n\n\n@\nPartitionById\n\n\ndefine\n \naggregation\n \naggregator\n \nname\n\n\nfrom\n \ninput\n \nstream\n\n\nselect\n \nattribute\n \nname\n,\n \naggregate\n \nfunction\n(\nattribute\n \nname\n)\n \nas\n \nattribute\n \nname\n,\n \n...\n\n    \ngroup\n \nby\n \nattribute\n \nname\n\n    \naggregate\n \nby\n \ntimestamp\n \nattribute\n \nevery\n \ntime\n \nperiods\n \n;\n\n\n\n\n\n\nFollowing table includes the \nannotation\n to be used to enable distributed aggregation, \n\n\n\n\n\n\n\n\nItem\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n@PartitionById\n\n\nIf the annotation is given, then the distributed aggregation is enabled. Further this can be disabled by using \nenable\n element, \n@PartitionById(enable='false')\n.\n\n\n\n\n\n\n\n\nFurther, following system properties are also available,\n\n\n\n\n\n\n\n\nSystem Property\n\n\nDescription\n\n\nPossible Values\n\n\nOptional\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nshardId\n\n\nThe id of the shard one of the distributed aggregation is running in. This should be unique to a single shard\n\n\nAny string\n\n\nNo\n\n\n\n\n\n\n\n\npartitionById\n\n\nThis allows user to enable/disable distributed aggregation for all aggregations running in one siddhi manager .(Available from v4.3.3)\n\n\ntrue/false\n\n\nYesio\n\n\nfalse\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nShardIds should not be changed after the first configuration in order to keep data consistency.\n\n\n\n\nJoin (Aggregation)\n\n\nThis allows a stream to retrieve calculated aggregate values from the aggregation. \n\n\n\n\nNote\n\n\nA join can also be performed with \ntwo streams\n, with a \ntable\n and a stream, or with a stream against externally \ndefined windows\n.\n\n\n\n\nSyntax\n\n\nA join with aggregation is similer to the join with \ntable\n, but with additional \nwithin\n and \nper\n clauses. \n\n\nfrom\n \ninput\n \nstream\n \njoin\n \naggrigation\n \n  \non\n \njoin\n \ncondition\n \n  \nwithin\n \ntime\n \nrange\n \n  \nper\n \ntime\n \ngranularity\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n;\n\n\n\n\n\n\nApart from constructs of \ntable join\n this includes the following. Please note that the 'on' condition is optional :\n\n\n\n\n\n\n\n\nItem\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwithin  \ntime range\n\n\nThis allows you to specify the time interval for which the aggregate values need to be retrieved. This can be specified by providing the start and end time separated by a comma as \nstring\n or \nlong\n values, or by using the wildcard \nstring\n specifying the data range. For details refer examples.\n\n\n\n\n\n\nper \ntime granularity\n\n\nThis specifies the time granularity by which the aggregate values must be grouped and returned. e.g., If you specify \ndays\n, the retrieved aggregate values are grouped for each day within the selected time interval.\n\n\n\n\n\n\nAGG_TIMESTAMP\n\n\nThis specifies the start time of the aggregations and can be used in the select clause.\n\n\n\n\n\n\n\n\nwithin\n and \nper\n clauses also accept attribute values from the stream.\n\n\n\n\nNote\n\n\nThe timestamp of the aggregations can be accessed through the \nAGG_TIMESTAMP\n attribute.\n\n\n\n\nExample\n\n\nFollowing aggregation definition will be used for the examples. \n\n\ndefine\n \nstream\n \nTradeStream\n \n(\nsymbol\n \nstring\n,\n \nprice\n \ndouble\n,\n \nvolume\n \nlong\n,\n \ntimestamp\n \nlong\n);\n\n\n\ndefine\n \naggregation\n \nTradeAggregation\n\n  \nfrom\n \nTradeStream\n\n  \nselect\n \nAGG_TIMESTAMP\n,\n \nsymbol\n,\n \navg\n(\nprice\n)\n \nas\n \navgPrice\n,\n \nsum\n(\nprice\n)\n \nas\n \ntotal\n\n    \ngroup\n \nby\n \nsymbol\n\n    \naggregate\n \nby\n \ntimestamp\n \nevery\n \nsec\n \n...\n \nyear\n;\n\n\n\n\n\n\nThis query retrieves daily aggregations within the time range \n\"2014-02-15 00:00:00 +05:30\", \"2014-03-16 00:00:00 +05:30\"\n (Please note that +05:30 can be omitted if timezone is GMT)\n\n\ndefine\n \nstream\n \nStockStream\n \n(\nsymbol\n \nstring\n,\n \nvalue\n \nint\n);\n\n\n\nfrom\n \nStockStream\n \nas\n \nS\n \njoin\n \nTradeAggregation\n \nas\n \nT\n\n  \non\n \nS\n.\nsymbol\n \n==\n \nT\n.\nsymbol\n \n  \nwithin\n \n2014-02-15 00:00:00 +05:30\n,\n \n2014-03-16 00:00:00 +05:30\n \n  \nper\n \ndays\n \n\nselect\n \nS\n.\nsymbol\n,\n \nT\n.\ntotal\n,\n \nT\n.\navgPrice\n \n\ninsert\n \ninto\n \nAggregateStockStream\n;\n\n\n\n\n\n\nThis query retrieves hourly aggregations within the day \n2014-02-15\n.\n\n\ndefine\n \nstream\n \nStockStream\n \n(\nsymbol\n \nstring\n,\n \nvalue\n \nint\n);\n\n\n\nfrom\n \nStockStream\n \nas\n \nS\n \njoin\n \nTradeAggregation\n \nas\n \nT\n\n  \non\n \nS\n.\nsymbol\n \n==\n \nT\n.\nsymbol\n \n  \nwithin\n \n2014-02-15 **:**:** +05:30\n\n  \nper\n \nhours\n \n\nselect\n \nS\n.\nsymbol\n,\n \nT\n.\ntotal\n,\n \nT\n.\navgPrice\n \n\ninsert\n \ninto\n \nAggregateStockStream\n;\n\n\n\n\n\n\nThis query retrieves all aggregations per \nperValue\n stream attribute within the time period \nbetween timestamps \n1496200000000\n and \n1596434876000\n.\n\n\ndefine\n \nstream\n \nStockStream\n \n(\nsymbol\n \nstring\n,\n \nvalue\n \nint\n,\n \nperValue\n \nstring\n);\n\n\n\nfrom\n \nStockStream\n \nas\n \nS\n \njoin\n \nTradeAggregation\n \nas\n \nT\n\n  \non\n \nS\n.\nsymbol\n \n==\n \nT\n.\nsymbol\n \n  \nwithin\n \n1496200000000\nL\n,\n \n1596434876000\nL\n\n  \nper\n \nS\n.\nperValue\n\n\nselect\n \nS\n.\nsymbol\n,\n \nT\n.\ntotal\n,\n \nT\n.\navgPrice\n \n\ninsert\n \ninto\n \nAggregateStockStream\n;\n\n\n\n\n\n\nSupported join types\n \n\n\nAggregation join supports following join operations.\n\n\n\n\n\n\nInner join (join)\n \n\n\nThis is the default behaviour of a join operation. \njoin\n is used as the keyword to join the stream with the aggregation. The output is generated only if there is a matching event in the stream and the aggregation.\n\n\n\n\n\n\nLeft outer join\n \n\n\nThe \nleft outer join\n operation allows you to join a stream on left side with a aggregation on the right side based on a condition.\nHere, it returns all the events of left stream even if there are no matching events in the right aggregation by \nhaving null values for the attributes of the right aggregation.\n\n\n\n\n\n\nRight outer join\n \n\n\nThis is similar to a \nleft outer join\n. \nright outer join\n is used as the keyword to join a stream on right side with a aggregation on the left side based on a condition.\nIt returns all the events of the right stream even if there are no matching events in the left aggregation. \n\n\n\n\n\n\n(Defined)\n Window\n\n\nA defined window is a window that can be shared across multiple queries. \nEvents can be inserted to a defined window from one or more queries and it can produce output events based on the defined window type.\n\n\nSyntax\n\n\nThe syntax for a defined window is as follows:\n\n\ndefine\n \nwindow\n \nwindow\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n)\n \nwindow\n \ntype\n(\nparameter\n,\n \nparameter\n,\n \n\u2026\n)\n \noutput\n \nevent\n \ntype\n;\n\n\n\n\n\n\nThe following parameters are configured in a table definition:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwindow name\n\n\nThe name of the window defined. (\nPascalCase\n is used for window names as a convention.)\n\n\n\n\n\n\nattribute name\n\n\nThe schema of the window is defined by its attributes with uniquely identifiable attribute names (\ncamelCase\n is used for attribute names as a convention.)\n\n\n\n\n\n\nattribute type\n\n\nThe type of each attribute defined in the schema. \n This can be \nSTRING\n, \nINT\n, \nLONG\n, \nDOUBLE\n, \nFLOAT\n, \nBOOL\n or \nOBJECT\n.\n\n\n\n\n\n\nwindow type\n(\nparameter\n, ...)\n\n\nThe window type associated with the window and its parameters.\n\n\n\n\n\n\noutput \noutput event type\n\n\nThis is optional. Keywords such as \ncurrent events\n, \nexpired events\n and \nall events\n (the default) can be used to specify when the window output should be exposed. For more information, see \noutput event type\n.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\nReturning all output when events arrive and when events expire from the window.\n\n\nIn this query, the output event type is not specified. Therefore, it returns both current and expired events as the output.\n\n\n\n\n\n\n  \ndefine\n \nwindow\n \nSensorWindow\n \n(\nname\n \nstring\n,\n \nvalue\n \nfloat\n,\n \nroomNo\n \nint\n,\n \ndeviceID\n \nstring\n)\n \ntimeBatch\n(\n1\n \nsecond\n);\n\n\n\n\n\n\n\n\n\n\nReturning an output only when events expire from the window.\n\n\nIn this query, the output event type of the window is \nexpired events\n. Therefore, it only returns the events that have expired from the window as the output.\n\n\n\n\n\n\n  \ndefine\n \nwindow\n \nSensorWindow\n \n(\nname\n \nstring\n,\n \nvalue\n \nfloat\n,\n \nroomNo\n \nint\n,\n \ndeviceID\n \nstring\n)\n \ntimeBatch\n(\n1\n \nsecond\n)\n \noutput\n \nexpired\n \nevents\n;\n\n\n\n\n\n\nOperators on Defined Windows\n\n\nThe following operators can be performed on defined windows.\n\n\nInsert\n\n\nThis allows events to be inserted into windows. This is similar to inserting events into streams. \n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n \n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \nwindow\n\n\n\n\n\n\nTo insert only events of a specific output event type, add the \ncurrent events\n, \nexpired events\n or the \nall events\n keyword between \ninsert\n and \ninto\n keywords (similar to how it is done for streams).\n\n\nFor more information, see \noutput event type\n.\n\n\nExample\n\n\nThis query inserts all events from the \nTempStream\n stream to the \nOneMinTempWindow\n window.\n\n\ndefine\n \nstream\n \nTempStream\n(\ntempId\n \nstring\n,\n \ntemp\n \ndouble\n);\n\n\ndefine\n \nwindow\n \nOneMinTempWindow\n(\ntempId\n \nstring\n,\n \ntemp\n \ndouble\n)\n \ntime\n(\n1\n \nmin\n);\n\n\n\nfrom\n \nTempStream\n\n\nselect\n \n*\n\n\ninsert\n \ninto\n \nOneMinTempWindow\n;\n\n\n\n\n\n\nJoin (Window)\n\n\nTo allow a stream to retrieve information from a window based on a condition.\n\n\n\n\nNote\n\n\nA join can also be performed with \ntwo streams\n, \naggregation\n or with tables \ntables\n.\n\n\n\n\nSyntax\n\n\nfrom\n \ninput\n \nstream\n \njoin\n \nwindow\n\n    \non\n \ncondition\n\n\nselect\n \n(\ninput\n \nstream\n|\nwindow\n).\nattribute\n \nname\n,\n \n(\ninput\n \nstream\n|\nwindow\n).\nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nExample\n\n\nThis Siddhi Application performs a join count the number of temperature events having more then 40 degrees \n within the last 2 minutes. \n\n\ndefine\n \nwindow\n \nTwoMinTempWindow\n \n(\nroomNo\n \nint\n,\n \ntemp\n \ndouble\n)\n \ntime\n(\n2\n \nmin\n);\n\n\ndefine\n \nstream\n \nCheckStream\n \n(\nrequestId\n \nstring\n);\n\n\n\nfrom\n \nCheckStream\n \nas\n \nC\n \njoin\n \nTwoMinTempWindow\n \nas\n \nT\n\n    \non\n \nT\n.\ntemp\n \n \n40\n\n\nselect\n \nrequestId\n,\n \ncount\n(\nT\n.\ntemp\n)\n \nas\n \ncount\n\n\ninsert\n \ninto\n \nHighTempCountStream\n;\n\n\n\n\n\n\nSupported join types\n \n\n\nWindow join supports following operations of a join clause.\n\n\n\n\n\n\nInner join (join)\n \n\n\nThis is the default behaviour of a join operation. \njoin\n is used as the keyword to join two windows or a stream with a window. The output is generated only if there is a matching event in both stream/window.\n\n\n\n\n\n\nLeft outer join\n \n\n\nThe \nleft outer join\n operation allows you to join two windows or a stream with a window to be merged based on a condition. \nHere, it returns all the events of left stream/window even if there are no matching events in the right stream/window by \nhaving null values for the attributes of the right stream/window.\n\n\n\n\n\n\nRight outer join\n \n\n\nThis is similar to a left outer join. \nRight outer join\n is used as the keyword to join two windows or a stream with a window.\nIt returns all the events of the right stream/window even if there are no matching events in the left stream/window. \n\n\n\n\n\n\nFull outer join\n \n\n\nThe full outer join combines the results of \nleft outer join\n and \nright outer join\n. \nfull outer join\n is used as the keyword to join two windows or a stream with a window.\nHere, output event are generated for each incoming event even if there are no matching events in the other stream/window.\n\n\n\n\n\n\nFrom\n\n\nA window can be an input to a query, similar to streams. \n\n\nNote !!!\n     When window is used as an input to a query, another window cannot be applied on top of this.\n\n\nSyntax\n\n\nfrom\n \nwindow\n \n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \noutput\n \nstream\n\n\n\n\n\n\nExample\n\nThis Siddhi Application calculates the maximum temperature within the last 5 minutes.\n\n\ndefine\n \nwindow\n \nFiveMinTempWindow\n \n(\nroomNo\n \nint\n,\n \ntemp\n \ndouble\n)\n \ntime\n(\n5\n \nmin\n);\n\n\n\n\nfrom\n \nFiveMinTempWindow\n\n\nselect\n \nmax\n(\ntemp\n)\n \nas\n \nmaxValue\n,\n \nroomNo\n\n\ninsert\n \ninto\n \nMaxSensorReadingStream\n;\n\n\n\n\n\n\nTrigger\n\n\nTriggers allow events to be periodically generated. \nTrigger definition\n can be used to define a trigger. \nA trigger also works like a stream with a predefined schema.\n\n\nPurpose\n\n\nFor some use cases the system should be able to periodically generate events based on a specified time interval to perform \nsome periodic executions. \n\n\nA trigger can be performed for a \n'start'\n operation, for a given \ntime interval\n, or for a given \n'\ncron expression\n'\n.\n\n\nSyntax\n\n\nThe syntax for a trigger definition is as follows.\n\n\ndefine\n \ntrigger\n \ntrigger\n \nname\n \nat\n \n(\nstart\n|\n \nevery\n \ntime\n \ninterval\n|\n \ncron expression\n);\n\n\n\n\n\n\nSimilar to streams, triggers can be used as inputs. They adhere to the following stream definition and produce the \ntriggered_time\n attribute of the \nlong\n type.\n\n\ndefine\n \nstream\n \ntrigger\n \nname\n \n(\ntriggered_time\n \nlong\n);\n\n\n\n\n\n\nThe following types of triggeres are currently supported:\n\n\n\n\n\n\n\n\nTrigger type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n'start'\n\n\nAn event is triggered when Siddhi is started.\n\n\n\n\n\n\nevery \ntime interval\n\n\nAn event is triggered periodically at the given time interval.\n\n\n\n\n\n\n'\ncron expression\n'\n\n\nAn event is triggered periodically based on the given cron expression. For configuration details, see \nquartz-scheduler\n.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\nTriggering events regularly at specific time intervals\n\n\nThe following query triggers events every 5 minutes.\n\n\n\n\n\n\n     \ndefine\n \ntrigger\n \nFiveMinTriggerStream\n \nat\n \nevery\n \n5\n \nmin\n;\n\n\n\n\n\n\n\n\n\n\nTriggering events at a specific time on specified days\n\n\nThe following query triggers an event at 10.15 AM on every weekdays.\n\n\n\n\n\n\n     \ndefine\n \ntrigger\n \nFiveMinTriggerStream\n \nat\n \n0 15 10 ? * MON-FRI\n;\n\n\n\n\n\n\nScript\n\n\nScripts allow you to write functions in other programming languages and execute them within Siddhi queries. \nFunctions defined via scripts can be accessed in queries similar to any other inbuilt function. \n\nFunction definitions\n can be used to define these scripts.\n\n\nFunction parameters are passed into the function logic as \nObject[]\n and with the name \ndata\n . \n\n\nPurpose\n\n\nScripts allow you to define a function operation that is not provided in Siddhi core or its extension. It is not required to write an extension to define the function logic.\n\n\nSyntax\n\n\nThe syntax for a Script definition is as follows.\n\n\ndefine\n \nfunction\n \nfunction\n \nname\n[\nlanguage\n \nname\n]\n \nreturn\n \nreturn\n \ntype\n \n{\n\n    \noperation\n \nof\n \nthe\n \nfunction\n\n\n}\n;\n\n\n\n\n\n\nThe following parameters are configured when defining a script.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunction name\n\n\nThe name of the function (\ncamelCase\n is used for the function name) as a convention.\n\n\n\n\n\n\nlanguage name\n\n\nThe name of the programming language used to define the script, such as \njavascript\n, \nr\n and \nscala\n.\n\n\n\n\n\n\nreturn type\n\n\nThe attribute type of the function\u2019s return. This can be \nint\n, \nlong\n, \nfloat\n, \ndouble\n, \nstring\n, \nbool\n or \nobject\n. Here the function implementer should be responsible for returning the output attribute on the defined return type for proper functionality.\n\n\n\n\n\n\noperation of the function\n\n\nHere, the execution logic of the function is added. This logic should be written in the language specified under the \nlanguage name\n, and it should return the output in the data type specified via the \nreturn type\n parameter.\n\n\n\n\n\n\n\n\nExamples\n\n\nThis query performs concatenation using JavaScript, and returns the output as a string.\n\n\ndefine\n \nfunction\n \nconcatFn\n[\njavascript\n]\n \nreturn\n \nstring\n \n{\n\n    \nvar\n \nstr1\n \n=\n \ndata\n[\n0\n];\n\n    \nvar\n \nstr2\n \n=\n \ndata\n[\n1\n];\n\n    \nvar\n \nstr3\n \n=\n \ndata\n[\n2\n];\n\n    \nvar\n \nresponce\n \n=\n \nstr1\n \n+\n \nstr2\n \n+\n \nstr3\n;\n\n    \nreturn\n \nresponce\n;\n\n\n}\n;\n\n\n\ndefine\n \nstream\n \nTempStream\n(\ndeviceID\n \nlong\n,\n \nroomNo\n \nint\n,\n \ntemp\n \ndouble\n);\n\n\n\nfrom\n \nTempStream\n\n\nselect\n \nconcatFn\n(\nroomNo\n,\n-\n,\ndeviceID\n)\n \nas\n \nid\n,\n \ntemp\n \n\ninsert\n \ninto\n \nDeviceTempStream\n;\n\n\n\n\n\n\nStore Query\n\n\nSiddhi store queries are a set of on-demand queries that can be used to perform operations on Siddhi tables, windows, and aggregators.\n\n\nPurpose\n\n\nStore queries allow you to execute the following operations on Siddhi tables, windows, and aggregators without the intervention of streams.\n\n\nQueries supported for tables:\n\n\n\n\nSELECT\n\n\nINSERT\n\n\nDELETE\n\n\nUPDATE\n\n\nUPDATE OR INSERT\n\n\n\n\nQueries supported for windows and aggregators:\n\n\n\n\nSELECT\n\n\n\n\nThis is be done by submitting the store query to the Siddhi application runtime using its \nquery()\n method.\n\n\nIn order to execute store queries, the Siddhi application of the Siddhi application runtime you are using, should have\n a store defined, which contains the table that needs to be queried.\n\n\nExample\n\n\nIf you need to query the table named \nRoomTypeTable\n the it should have been defined in the Siddhi application.\n\n\nIn order to execute a store query on \nRoomTypeTable\n, you need to submit the store query using \nquery()\n \nmethod of \nSiddhiAppRuntime\n instance as below.\n\n\nsiddhiAppRuntime\n.\nquery\n(\nstore\n \nquery\n);\n\n\n\n\n\n\n(Table/Window)\n Select\n\n\nThe \nSELECT\n store query retrieves records from the specified table or window, based on the given condition.\n\n\nSyntax\n\n\nfrom\n \ntable\n/\nwindow\n\n\non\n \ncondition\n?\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ngroup\n \nby\n?\n \n\nhaving\n?\n \n\norder\n \nby\n?\n \n\nlimit\n?\n\n\n\n\n\n\nExample\n\n\nThis query retrieves room numbers and types of the rooms starting from room no 10.\n\n\nfrom\n \nroomTypeTable\n\n\non\n \nroomNo\n \n=\n \n10\n;\n\n\nselect\n \nroomNo\n,\n \ntype\n\n\n\n\n\n\n(Aggregation)\n Select\n\n\nThe \nSELECT\n store query retrieves records from the specified aggregation, based on the given condition, time range, \nand granularity.\n\n\nSyntax\n\n\nfrom\n \naggregation\n\n\non\n \ncondition\n?\n\n\nwithin\n \ntime\n \nrange\n\n\nper\n \ntime\n \ngranularity\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ngroup\n \nby\n?\n \n\nhaving\n?\n \n\norder\n \nby\n?\n \n\nlimit\n?\n\n\n\n\n\n\nExample\n\n\nFollowing aggregation definition will be used for the examples. \n\n\ndefine\n \nstream\n \nTradeStream\n \n(\nsymbol\n \nstring\n,\n \nprice\n \ndouble\n,\n \nvolume\n \nlong\n,\n \ntimestamp\n \nlong\n);\n\n\n\ndefine\n \naggregation\n \nTradeAggregation\n\n  \nfrom\n \nTradeStream\n\n  \nselect\n \nsymbol\n,\n \navg\n(\nprice\n)\n \nas\n \navgPrice\n,\n \nsum\n(\nprice\n)\n \nas\n \ntotal\n\n    \ngroup\n \nby\n \nsymbol\n\n    \naggregate\n \nby\n \ntimestamp\n \nevery\n \nsec\n \n...\n \nyear\n;\n\n\n\n\n\n\nThis query retrieves daily aggregations within the time range \n\"2014-02-15 00:00:00 +05:30\", \"2014-03-16 00:00:00 +05:30\"\n (Please note that +05:30 can be omitted if timezone is GMT)\n\n\nfrom\n \nTradeAggregation\n\n  \nwithin\n \n2014-02-15 00:00:00 +05:30\n,\n \n2014-03-16 00:00:00 +05:30\n \n  \nper\n \ndays\n \n\nselect\n \nsymbol\n,\n \ntotal\n,\n \navgPrice\n \n;\n\n\n\n\n\n\nThis query retrieves hourly aggregations of \"FB\" symbol within the day \n2014-02-15\n.\n\n\nfrom\n \nTradeAggregation\n\n  \non\n \nsymbol\n \n==\n \nFB\n \n  \nwithin\n \n2014-02-15 **:**:** +05:30\n\n  \nper\n \nhours\n \n\nselect\n \nsymbol\n,\n \ntotal\n,\n \navgPrice\n;\n\n\n\n\n\n\nInsert\n\n\nThis allows you to insert a new record to the table with the attribute values you define in the \nselect\n section.\n\n\nSyntax\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\ninsert\n \ninto\n \ntable\n;\n\n\n\n\n\n\nExample\n\n\nThis store query inserts a new record to the table \nRoomOccupancyTable\n, with the specified attribute values.\n\n\nselect\n \n10\n \nas\n \nroomNo\n,\n \n2\n \nas\n \npeople\n\n\ninsert\n \ninto\n \nRoomOccupancyTable\n \n\n\n\n\n\nDelete\n\n\nThe \nDELETE\n store query deletes selected records from a specified table.\n\n\nSyntax\n\n\nselect\n?\n  \n\ndelete\n \ntable\n  \n\non\n \nconditional\n \nexpresssion\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which records are selected to be deleted.\n\n\n\n\nNote\n\n\nTable attributes must always be referred to with the table name as shown below: \n\n \ntable name\n.\nattibute name\n.\n\n\n\n\nExample\n\n\nIn this example, query deletes a record in the table named \nRoomTypeTable\n if it has value for the \nroomNo\n \nattribute that matches the value for the \nroomNumber\n attribute of the selection which has 10 as the actual value.\n\n\nselect\n \n10\n \nas\n \nroomNumber\n\n\ndelete\n \nRoomTypeTable\n\n\non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \nroomNumber\n;\n\n\n\n\n\n\ndelete\n \nRoomTypeTable\n\n\non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \n10\n;\n\n\n\n\n\n\nUpdate\n\n\nThe \nUPDATE\n store query updates selected attributes stored in a specific table, based on a given condition.\n\n\nSyntax\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n?\n\n\nupdate\n \ntable\n\n    \nset\n \ntable\n.\nattribute\n \nname\n \n=\n \n(\nattribute\n \nname\n|\nexpression\n)\n?\n,\n \ntable\n.\nattribute\n \nname\n \n=\n \n(\nattribute\n \nname\n|\nexpression\n)\n?\n,\n \n...\n\n    \non\n \ncondition\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which records are selected to be updated.\nWhen specifying the \ncondition\n, table attributes must be referred to with the table name.\n\n\nYou can use the \nset\n keyword to update selected attributes from the table. Here, for each assignment, the attribute specified in the left must be the table attribute, and the one specified in the right can be a stream/table attribute a mathematical operation, or other. When the \nset\n clause is not provided, all the attributes in the table are updated.\n\n\n\n\nNote\n\n\nTable attributes must always be referred to with the table name as shown below: \n\n \ntable name\n.\nattibute name\n.\n\n\n\n\nExample\n\n\nThe following query updates the room occupancy by increasing the value of \npeople\n by 1, in the \nRoomOccupancyTable\n \ntable for each room number greater than 10.\n\n\nselect\n \n10\n \nas\n \nroomNumber\n,\n \n1\n \nas\n \narrival\n\n\nupdate\n \nRoomTypeTable\n\n    \nset\n \nRoomTypeTable\n.\npeople\n \n=\n \nRoomTypeTable\n.\npeople\n \n+\n \narrival\n\n    \non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \nroomNumber\n;\n\n\n\n\n\n\nupdate\n \nRoomTypeTable\n\n    \nset\n \nRoomTypeTable\n.\npeople\n \n=\n \nRoomTypeTable\n.\npeople\n \n+\n \n1\n\n    \non\n \nRoomTypeTable\n.\nroomNo\n \n==\n \n10\n;\n\n\n\n\n\n\nUpdate or Insert\n\n\nThis allows you to update selected attributes if a record that meets the given conditions already exists in the specified  table. \nIf a matching record does not exist, the entry is inserted as a new record.\n\n\nSyntax\n\n\nselect\n \nattribute\n \nname\n,\n \nattribute\n \nname\n,\n \n...\n\n\nupdate\n \nor\n \ninsert\n \ninto\n \ntable\n\n    \nset\n \ntable\n.\nattribute\n \nname\n \n=\n \nexpression\n,\n \ntable\n.\nattribute\n \nname\n \n=\n \nexpression\n,\n \n...\n\n    \non\n \ncondition\n\n\n\n\n\n\nThe \ncondition\n element specifies the basis on which records are selected for update.\nWhen specifying the \ncondition\n, table attributes should be referred to with the table name.\nIf a record that matches the condition does not already exist in the table, the arriving event is inserted into the table.\n\n\nThe \nset\n clause is only used when an update is performed during the insert/update operation.\nWhen \nset\n clause is used, the attribute to the left is always a table attribute, and the attribute to the right can be a stream/table attribute, mathematical\noperation or other. The attribute to the left (i.e., the attribute in the event table) is updated with the value of the attribute to the right if the given condition is met. When the \nset\n clause is not provided, all the attributes in the table are updated.\n\n\n\n\nNote\n\n\nTable attributes must always be referred to with the table name as shown below: \n\n \ntable name\n.\nattibute name\n.\n\n\n\n\nExample\n\n\nThe following query tries to update the records in the \nRoomAssigneeTable\n table that have room numbers that match the\n same in the selection. If such records are not found, it inserts a new record based on the values provided in the selection. \n\n\nselect\n \n10\n \nas\n \nroomNo\n,\n \nsingle\n \nas\n \ntype\n,\n \nabc\n \nas\n \nassignee\n\n\nupdate\n \nor\n \ninsert\n \ninto\n \nRoomAssigneeTable\n\n    \nset\n \nRoomAssigneeTable\n.\nassignee\n \n=\n \nassignee\n\n    \non\n \nRoomAssigneeTable\n.\nroomNo\n \n==\n \nroomNo\n;\n\n\n\n\n\n\nExtensions\n\n\nSiddhi supports an extension architecture to enhance its functionality by incorporating other libraries in a seamless manner. \n\n\nPurpose\n\n\nExtensions are supported because, Siddhi core cannot have all the functionality that's needed for all the use cases, mostly use cases require \ndifferent type of functionality, and for some cases there can be gaps and you need to write the functionality by yourself.\n\n\nAll extensions have a namespace. This is used to identify the relevant extensions together, and to let you specifically call the extension.\n\n\nSyntax\n\n\nExtensions follow the following syntax;\n\n\nnamespace\n:\nfunction\n \nname\n(\nparameter\n,\n \nparameter\n,\n \n...\n \n)\n\n\n\n\n\n\nThe following parameters are configured when referring a script function.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnamespace\n\n\nAllows Siddhi to identify the extension without conflict\n\n\n\n\n\n\nfunction name\n\n\nThe name of the function referred.\n\n\n\n\n\n\nparameter\n\n\nThe function input parameter for function execution.\n\n\n\n\n\n\n\n\n\n\nExtension Types\n\n\nSiddhi supports following extension types:\n\n\n\n\n\n\nFunction\n\n\nFor each event, it consumes zero or more parameters as input parameters and returns a single attribute. This can be used to manipulate existing event attributes to generate new attributes like any Function operation.\n\n\nThis is implemented by extending \nio.siddhi.core.executor.function.FunctionExecutor\n.\n\n\nExample : \n\n\nmath:sin(x)\n \n\n\nHere, the \nsin\n function of \nmath\n extension returns the sin value for the \nx\n parameter.\n\n\n\n\n\n\nAggregate Function\n\n\nFor each event, it consumes zero or more parameters as input parameters and returns a single attribute with aggregated results. This can be used in conjunction with a window in order to find the aggregated results based on the given window like any Aggregate Function operation. \n\n\nThis is implemented by extending \nio.siddhi.core.query.selector.attribute.aggregator.AttributeAggregatorExecutor\n.\n\n\nExample : \n\n\ncustom:std(x)\n \n\n\nHere, the \nstd\n aggregate function of \ncustom\n extension returns the standard deviation of the \nx\n value based on its assigned window query. \n\n\n\n\n\n\nWindow\n \n\n\nThis allows events to be \ncollected, generated, dropped and expired anytime\n \nwithout altering\n the event format based on the given input parameters, similar to any other Window operator. \n\n\nThis is implemented by extending \nio.siddhi.core.query.processor.stream.window.WindowProcessor\n.\n\n\nExample : \n\n\ncustom:unique(key)\n \n\n\nHere, the \nunique\n window of the \ncustom\n extension retains one event for each unique \nkey\n parameter.\n\n\n\n\n\n\nStream Function\n\n\nThis allows events to be  \ngenerated or dropped only during event arrival\n and \naltered\n by adding one or more attributes to it. \n\n\nThis is implemented by extending  \nio.siddhi.core.query.processor.stream.function.StreamFunctionProcessor\n.\n\n\nExample :  \n\n\ncustom:pol2cart(theta,rho)\n \n\n\nHere, the \npol2cart\n function of the \ncustom\n extension returns all the events by calculating the cartesian coordinates \nx\n \n \ny\n and adding them as new attributes to the events.\n\n\n\n\n\n\nStream Processor\n\n\nThis allows events to be \ncollected, generated, dropped and expired anytime\n by \naltering\n the event format by adding one or more attributes to it based on the given input parameters. \n\n\nImplemented by extending \nio.siddhi.core.query.processor.stream.StreamProcessor\n.\n\n\nExample :  \n\n\ncustom:perMinResults(\nparameter\n, \nparameter\n, ...)\n \n\n\nHere, the \nperMinResults\n function of the \ncustom\n extension returns all events by adding one or more attributes to the events based on the conversion logic. Altered events are output every minute regardless of event arrivals.\n\n\n\n\n\n\nSink\n\n\nSinks provide a way to \npublish Siddhi events to external systems\n in the preferred data format. Sinks publish events from the streams via multiple transports to external endpoints in various data formats.\n\n\nImplemented by extending \nio.siddhi.core.stream.output.sink.Sink\n.\n\n\nExample : \n\n\n@sink(type='sink_type', static_option_key1='static_option_value1')\n\n\nTo configure a stream to publish events via a sink, add the sink configuration to a stream definition by adding the @sink annotation with the required parameter values. The sink syntax is as above\n\n\n\n\n\n\nSource\n\n\nSource allows Siddhi to \nconsume events from external systems\n, and map the events to adhere to the associated stream. Sources receive events via multiple transports and in various data formats, and direct them into streams for processing.\n\n\nImplemented by extending \nio.siddhi.core.stream.input.source.Source\n.\n\n\nExample : \n\n\n@source(type='source_type', static.option.key1='static_option_value1')\n\n\nTo configure a stream that consumes events via a source, add the source configuration to a stream definition by adding the @source annotation with the required parameter values. The source syntax is as above\n\n\n\n\n\n\nStore\n\n\nYou can use Store extension type to work with data/events \nstored in various data stores through the table abstraction\n. You can find more information about these extension types under the heading 'Extension types' in this document. \n\n\nImplemented by extending \nio.siddhi.core.table.record.AbstractRecordTable\n.\n\n\n\n\n\n\nScript\n\n\nScripts allow you to \ndefine a function\n operation that is not provided in Siddhi core or its extension. It is not required to write an extension to define the function logic. Scripts allow you to write functions in other programming languages and execute them within Siddhi queries. Functions defined via scripts can be accessed in queries similar to any other inbuilt function.\n\n\nImplemented by extending \nio.siddhi.core.function.Script\n.\n\n\n\n\n\n\nSource Mapper\n\n\nEach \n@source\n configuration has a mapping denoted by the \n@map\n annotation that \nconverts the incoming messages format to Siddhi events\n.The type parameter of the @map defines the map type to be used to map the data. The other parameters to be configured depends on the mapper selected. Some of these parameters are optional. \n\n\nImplemented by extending \nio.siddhi.core.stream.output.sink.SourceMapper\n.\n\n\nExample :\n\n\n@map(type='map_type', static_option_key1='static_option_value1')\n\n\n\n\n\n\nSink Mapper\n\n\nEach \n@sink\n configuration has a mapping denoted by the \n@map\n annotation that \nconverts the outgoing Siddhi events to configured messages format\n.The type parameter of the @map defines the map type to be used to map the data. The other parameters to be configured depends on the mapper selected. Some of these parameters are optional. \n\n\nImplemented by extending \nio.siddhi.core.stream.output.sink.SinkMapper\n.\n\n\nExample :\n\n\n@map(type='map_type', static_option_key1='static_option_value1')\n\n\n\n\n\n\nExample\n\n\nA window extension created with namespace \nfoo\n and function name \nunique\n can be referred as follows:\n\n\nfrom\n \nStockExchangeStream\n[\nprice\n \n=\n \n20\n]\n#\nwindow\n.\nfoo\n:\nunique\n(\nsymbol\n)\n\n\nselect\n \nsymbol\n,\n \nprice\n\n\ninsert\n \ninto\n \nStockQuote\n\n\n\n\n\n\nAvailable Extensions\n\n\nSiddhi currently has several pre written extensions that are available \nhere\n\n\nWe value your contribution on improving Siddhi and its extensions further.\n\n\nWriting Custom Extensions\n\n\nCustom extensions can be written in order to cater use case specific logic that are not available in Siddhi out of the box or as an existing extension.\n\n\nThere are five types of Siddhi extensions that you can write to cater your specific use cases. These \nextension types and the related maven archetypes are given below. You can use these archetypes to generate Maven projects for each \nextension type.\n\n\n\n\nFollow the procedure for the required archetype, based on your project:\n\n\n\n\n\n\nNote\n\n\nWhen using the generated archetype please make sure you uncomment @Extension annotation and complete the\nannotation with proper values. This annotation will be used to identify and document the extension, hence your\nextension will not work without @Extension annotation.\n\n\n\n\nsiddhi-execution\n\n\nSiddhi-execution provides following extension types:\n\n\n\n\nFunction\n\n\nAggregate Function\n\n\nStream Function\n\n\nStream Processor\n\n\nWindow\n\n\n\n\nYou can use one or more from above mentioned extension types and implement according to your requirement. \n\n\nFor more information about these extension types, see \nExtension Types\n.\n\n\nTo install and implement the siddhi-io extension archetype, follow the procedure below:\n\n\n\n\n\n\nIssue the following command from your CLI.\n\n\n        mvn archetype:generate\n            -DarchetypeGroupId=io.siddhi.extension.archetype\n            -DarchetypeArtifactId=siddhi-archetype-execution\n            -DgroupId=io.extension.siddhi.execution\n            -Dversion=1.0.0-SNAPSHOT\n\n\n\n\n\n\n\n\n\nEnter the required execution name in the message that pops up as shown in the example below.\n\n\n    Define value for property \nexecutionType\n: ML\n\n\n\n\n\n\n\n\n\nTo confirm that all property values are correct, type \nY\n in the console. If not, press \nN\n.\n\n\n\n\n\n\nsiddhi-io\n\n\nSiddhi-io provides following extension types:\n\n\n\n\nSink\n\n\nSource\n\n\n\n\nYou can use one or more from above mentioned extension types and implement according to your requirement. siddhi-io is generally used to work with IO operations as follows:\n * The Source extension type gets inputs to your Siddhi application.\n * The Sink extension publishes outputs from your Siddhi application. \n\n\nFor more information about these extension types, see \nExtension Types\n.\n\n\nTo implement the siddhi-io extension archetype, follow the procedure below:\n\n\n\n\n\n\nIssue the following command from your CLI.\n\n\n       mvn archetype:generate\n           -DarchetypeGroupId=io.siddhi.extension.archetype\n           -DarchetypeArtifactId=siddhi-archetype-io\n           -DgroupId=io.extension.siddhi.io\n           -Dversion=1.0.0-SNAPSHOT\n\n\n\n\n\n\n\n\n\nEnter the required execution name (the transport type in this scenario) in the message that pops up as shown in the example below.\n\n\n Define value for property \ntypeOf_IO\n: http\n\n\n\n\n\n\n\n\n\nTo confirm that all property values are correct, type \nY\n in the console. If not, press \nN\n.\n\n\n\n\n\n\nsiddhi-map\n\n\nSiddhi-map provides following extension types,\n\n\n\n\nSink Mapper\n\n\nSource Mapper\n\n\n\n\nYou can use one or more from above mentioned extension types and implement according to your requirement as follows.\n\n\n\n\nThe Source Mapper maps events to a predefined data format (such as XML, JSON, binary, etc), and publishes them to external endpoints (such as E-mail, TCP, Kafka, HTTP, etc).\n\n\nThe Sink Mapper also maps events to a predefined data format, but it does it at the time of publishing events from a Siddhi application.\n\n\n\n\nFor more information about these extension types, see \nExtension Types\n.\n\n\nTo implement the siddhi-map extension archetype, follow the procedure below:\n\n\n\n\n\n\nIssue the following command from your CLI.                \n\n\n        mvn archetype:generate\n            -DarchetypeGroupId=io.siddhi.extension.archetype\n            -DarchetypeArtifactId=siddhi-archetype-map\n            -DgroupId=io.extension.siddhi.map\n            -Dversion=1.0.0-SNAPSHOT\n\n\n\n\n\n\n\n\n\nEnter the required execution name (the map type in this scenario) in the message that pops up as shown in the example below.\n\n\n    Define value for property \nmapType\n:CSV\n\n\n\n\n\n\n\n\n\nTo confirm that all property values are correct, type \nY\n in the console. If not, press \nN\n.\n\n\n\n\n\n\nsiddhi-script\n\n\nSiddhi-script provides the \nScript\n extension type.\n\n\nThe script extension type allows you to write functions in other programming languages and execute them within Siddhi queries. Functions defined via scripts can be accessed in queries similar to any other inbuilt function. \n\n\nFor more information about these extension types, see \nExtension Types\n.\n\n\nTo implement the siddhi-script extension archetype, follow the procedure below:\n\n\n\n\n\n\nIssue the following command from your CLI.                   \n\n\n       mvn archetype:generate\n           -DarchetypeGroupId=io.siddhi.extension.archetype\n           -DarchetypeArtifactId=siddhi-archetype-script\n           -DgroupId=io.extension.siddhi.script\n           -Dversion=1.0.0-SNAPSHOT\n\n\n\n\n\n\n\n\n\nEnter the required execution name in the message that pops up as shown in the example below.\n\n\n Define value for property \ntypeOfScript\n:\n\n\n\n\n\n\n\n\n\nTo confirm that all property values are correct, type \nY\n in the console. If not, press \nN\n.\n\n\n\n\n\n\nsiddhi-store\n\n\nSiddhi-store provides the \nStore\n extension type.\n\n\nThe Store extension type allows you to work with data/events stored in various data stores through the table abstraction. \n\n\nFor more information about these extension types, see \nExtension Types\n.\n\n\nTo implement the siddhi-store extension archetype, follow the procedure below:\n\n\n\n\n\n\nIssue the following command from your CLI.                      \n\n\n       mvn archetype:generate\n          -DarchetypeGroupId=io.siddhi.extension.archetype\n          -DarchetypeArtifactId=siddhi-archetype-store\n          -DgroupId=io.extension.siddhi.store\n          -Dversion=1.0.0-SNAPSHOT\n\n\n\n\n\n\n\n\n\nEnter the required execution name in the message that pops up as shown in the example below.\n\n\n  Define value for property \nstoreType\n: RDBMS\n\n\n\n\n\n\n\n\n\nTo confirm that all property values are correct, type \nY\n in the console. If not, press \nN\n.\n\n\n\n\n\n\nConfiguring and Monitoring Siddhi Applications\n\n\nThreading and Asynchronous\n\n\nWhen \n@Async\n annotation is added to the Streams it enable the Streams to introduce asynchronous and multi-threading \nbehaviour. \n\n\n@\nAsync\n(\nbuffer\n.\nsize\n=\n256\n,\n \nworkers\n=\n2\n,\n \nbatch\n.\nsize\n.\nmax\n=\n5\n)\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n);\n\n\n\n\n\n\nThe following elements are configured with this annotation.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nDescription\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nbuffer.size\n\n\nThe size of the event buffer that will be used to handover the execution to other threads.\n\n\n-\n\n\n\n\n\n\nworkers\n\n\nNumber of worker threads that will be be used to process the buffered events.\n\n\n1\n\n\n\n\n\n\nbatch.size.max\n\n\nThe maximum number of events that will be processed together by a worker thread at a given time.\n\n\nbuffer.size\n\n\n\n\n\n\n\n\nFault Streams\n\n\nWhen the \n@OnError\n annotation is added to a stream definition, it handles failover scenarios that occur during runtime gracefully.\n\n\n@\nOnError\n(\naction\n=\non_error_action\n)\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n);\n\n\n\n\n\n\nThe action parameter of the \n@OnError\n annotation defines the action to be executed during failure scenarios. \n\n\nThe following action types can be specified via the \n@OnError\n annotation when defining a stream. If this annotation is not added, \nLOG\n is the action type by default.\n\n\n\n\nLOG\n : Logs the event with an error, and then drops the event.\n\n\nSTREAM\n: A fault stream is automatically created for the base stream. The definition of the fault stream includes all the attributes of the base stream as well as an additional attribute named \n_error\n.\nThe events are inserted into the fault stream during a failure. The error identified is captured as the value for the \n_error\n attribute.\n\n\n\n\ne.g., the following is a Siddhi application that includes the \n@OnError\n annotation to handle failures during runtime.\n\n\n@\nOnError\n(\nname\n=\nSTREAM\n)\n\n\ndefine\n \nstream\n \nStreamA\n \n(\nsymbol\n \nstring\n,\n \nvolume\n \nlong\n);\n\n\n\nfrom\n \nStreamA\n[\ncustom\n:\nfault\n()\n \n \nvolume\n]\n \n\ninsert\n \ninto\n \nStreamB\n;\n\n\n\nfrom\n \n!\nStreamA\n#\nlog\n(\nError Occured\n)\n\n\nselect\n \nsymbol\n,\n \nvolume\n \nlong\n,\n \n_error\n\n\ninsert\n \ninto\n \ntempStream\n;\n\n\n\n\n\n\n!StreamA\n, fault stream is automatically created when you add the \n@OnError\n annotation with the following attributes.\n\n\nsymbol\n \nstring\n,\n \nvolume\n \nlong\n,\n \n_error\n \nobject\n\n\n\n\n\n\nIf you include the \non.error\n parameter in the sink configuration, failures are handled by Siddhi at the time the events are published from the \nSink\n.\n\n\n@\nsink\n(\ntype\n=\nsink_type\n,\n \non\n.\nerror\n=\non.error.action\n)\n\n\ndefine\n \nstream\n \nstream\n \nname\n \n(\nattribute\n \nname\n \nattribute\n \ntype\n,\n \nattribute\n \nname\n \nattribute\n \ntype\n,\n \n...\n \n);\n\n\n\n\n\n\nThe action types that can be specified via the \non.error\n parameter when configuring a sink are as follows. If this parameter is not included in the sink configuration, \nLOG\n is the action type by default.\n\n\n\n\nLOG\n : Logs the event with the error, and then drops the event.\n\n\nWAIT\n : The thread waits in the \nback-off and re-trying\n state, and reconnects once the connection is re-established.\n\n\nSTREAM\n: Corresponding fault stream is populated with the failed event and the error while publishing. \n\n\n\n\nStatistics\n\n\nUse \n@app:statistics\n app level annotation to evaluate the performance of an application, you can enable the statistics of a Siddhi application to be published. This is done via the \n@app:statistics\n annotation that can be added to a Siddhi application as shown in the following example.\n\n\n@\napp\n:\nstatistics\n(\nreporter\n \n=\n \nconsole\n)\n\n\n\n\n\n\nThe following elements are configured with this annotation.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nDescription\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nreporter\n\n\nThe interface in which statistics for the Siddhi application are published. Possible values are as follows:\n \nconsole\n \njmx\n\n\nconsole\n\n\n\n\n\n\ninterval\n\n\nThe time interval (in seconds) at  which the statistics for the Siddhi application are reported.\n\n\n60\n\n\n\n\n\n\ninclude\n\n\nIf this parameter is added, only the types of metrics you specify are included in the reporting. The required metric types can be specified as a comma-separated list. It is also possible to use wild cards\n\n\nAll (\n.\n)\n\n\n\n\n\n\n\n\nThe metrics are reported in the following format.\n\nio.siddhi.SiddhiApps.\nSiddhiAppName\n.Siddhi.\nComponent Type\n.\nComponent Name\n. \nMetrics name\n\n\nThe following table lists the types of metrics supported for different Siddhi application component types.\n\n\n\n\n\n\n\n\nComponent Type\n\n\nMetrics Type\n\n\n\n\n\n\n\n\n\n\nStream\n\n\nThroughput\nThe size of the buffer if parallel processing is enabled via the @async annotation.\n\n\n\n\n\n\nTrigger\n\n\nThroughput (Trigger and Stream)\n\n\n\n\n\n\nSource\n\n\nThroughput\n\n\n\n\n\n\nSink\n\n\nThroughput\n\n\n\n\n\n\nMapper\n\n\nLatency\nInput/output throughput\n\n\n\n\n\n\nTable\n\n\nMemory\nThroughput (For all operations)\nThroughput (For all operations)\n\n\n\n\n\n\nQuery\n\n\nMemory\nLatency\n\n\n\n\n\n\nWindow\n\n\nThroughput (For all operations)\nLatency (For all operation)\n\n\n\n\n\n\nPartition\n\n\nThroughput (For all operations)\nLatency (For all operation)\n\n\n\n\n\n\n\n\ne.g., the following is a Siddhi application that includes the \n@app\n annotation to report performance statistics.\n\n\n@\nApp\n:\nname\n(\nTestMetrics\n)\n\n\n@\nApp\n:\nStatistics\n(\nreporter\n \n=\n \nconsole\n)\n\n\n\ndefine\n \nstream\n \nTestStream\n \n(\nmessage\n \nstring\n);\n\n\n\n@\ninfo\n(\nname\n=\nlogQuery\n)\n\n\nfrom\n \nTestSream\n#\nlog\n(\nMessage:\n)\n\n\ninsert\n \ninto\n \nTempSream\n;\n\n\n\n\n\n\nStatistics are reported for this Siddhi application as shown in the extract below.\n\n\n\n  \nClick to view the extract\n\n11/26/17 8:01:20 PM ============================================================\n\n\n-- Gauges ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Queries.logQuery.memory\n              value = 5760\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TestStream.size\n              value = 0\n\n\n-- Meters ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Sources.TestStream.http.throughput\n              count = 0\n          mean rate = 0.00 events/second\n      1-minute rate = 0.00 events/second\n      5-minute rate = 0.00 events/second\n     15-minute rate = 0.00 events/second\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TempSream.throughput\n              count = 2\n          mean rate = 0.04 events/second\n      1-minute rate = 0.03 events/second\n      5-minute rate = 0.01 events/second\n     15-minute rate = 0.00 events/second\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TestStream.throughput\n              count = 2\n          mean rate = 0.04 events/second\n      1-minute rate = 0.03 events/second\n      5-minute rate = 0.01 events/second\n     15-minute rate = 0.00 events/second\n\n\n-- Timers ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Queries.logQuery.latency\n              count = 2\n          mean rate = 0.11 calls/second\n      1-minute rate = 0.34 calls/second\n      5-minute rate = 0.39 calls/second\n     15-minute rate = 0.40 calls/second\n                min = 0.61 milliseconds\n                max = 1.08 milliseconds\n               mean = 0.84 milliseconds\n             stddev = 0.23 milliseconds\n             median = 0.61 milliseconds\n               75% \n= 1.08 milliseconds\n               95% \n= 1.08 milliseconds\n               98% \n= 1.08 milliseconds\n               99% \n= 1.08 milliseconds\n             99.9% \n= 1.08 milliseconds\n\n\n\n\nEvent Playback\n\n\nWhen \n@app:playback\n annotation is added to the app, the timestamp of the event (specified via an attribute) is treated as the current time. This results in events being processed faster.\nThe following elements are configured with this annotation.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nidle.time\n\n\nIf no events are received during a time interval specified (in milliseconds) via this element, the Siddhi system time is incremented by a number of seconds specified via the \nincrement\n element.\n\n\n\n\n\n\nincrement\n\n\nThe number of seconds by which the Siddhi system time must be incremented if no events are received during the time interval specified via the \nidle.time\n element.\n\n\n\n\n\n\n\n\ne.g., In the following example, the Siddhi system time is incremented by two seconds if no events arrive for a time interval of 100 milliseconds.\n\n\n@app:playback(idle.time = '100 millisecond', increment = '2 sec')", 
            "title": "Siddhi Query Guide"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#siddhi-4x-streaming-sql-guide", 
            "text": "Info  Please find the latest Siddhi Streaming SQL Guide  here", 
            "title": "Siddhi 4.x Streaming SQL Guide"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#introduction", 
            "text": "Siddhi Streaming SQL is designed to process event streams in a streaming manner, detect complex event occurrences, \nand notify them in real-time.", 
            "title": "Introduction"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#siddhi-application", 
            "text": "Streaming processing and Complex Event Processing rules can be written is Siddhi Streaming SQL and they can be put \ntogether as a  SiddhiApp  in a single file.   Purpose  Each Siddhi Application is an isolated processing unit that allows you to deploy and execute queries independent of other Siddhi applications in the system.  The following diagram depicts how  event flows  work with some of the key Siddhi Streaming SQL elements \nof the Siddhi Application.   Below table provides brief description of a few key elements in the Siddhi Streaming SQL Language.     Elements  Description      Stream  A logical series of events ordered in time with a uniquely identifiable name, and set of defined attributes with specific data types defining its schema.    Event  An event is associated with only one stream, and all events of that stream have an identical set of attributes that are assigned specific types (or the same schema). An event contains a timestamp and set of attribute values according to the schema.    Table  A structured representation of data stored with a defined schema. Stored data can be backed by  In-Memory ,  RDBMs ,  MongoDB , etc. to be accessed and manipulated at runtime.    Query  A logical construct that processes events in streaming manner by combining existing streams and/or tables, and generates events to an output stream or table. A query consumes one or more input streams, and zero or one table. Then it processes these events in a streaming manner and publishes the output events to streams or tables for further processing or to generate notifications.    Source  A contract that consumes data from external sources (such as  TCP ,  Kafka ,  HTTP , etc)in the form of events, then converts each event (which can be in  XML ,  JSON ,  binary , etc. format) to a Siddhi event, and passes that to a Stream for processing.    Sink  A contract that takes events arriving at a stream, maps them to a predefined data format (such as  XML ,  JSON ,  binary , etc), and publishes them to external endpoints (such as  E-mail ,  TCP ,  Kafka ,  HTTP , etc).    Input Handler  A mechanism to programmatically inject events into streams.    Stream/Query Callback  A mechanism to programmatically consume output events from streams and queries.    Partition  A logical container that isolates the processing of queries based on partition keys. Here, a separate instance of queries is generated for each partition key to achieve isolation.    Inner Stream  A positionable stream that connects portioned queries within their partitions, preserving isolation.     Grammar  An element of Siddhi SQL can be composed together as a script in a Siddhi application, Here each construct must be separated \nby a semicolon  ( ; )  as shown in the below syntax.   siddhi app   : \n         app annotation  * \n        (  stream definition  |  table definition  | ... ) + \n        (  query  |  partition  ) +\n        ;  Example \nSiddhi Application named  Temperature-Analytics  defined with a stream named  TempStream  and a query \nnamed  5minAvgQuery  for processing it.  @ app : name ( Temperature-Analytics )  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  @ name ( 5minAvgQuery )  from   TempStream # window . time ( 5   min )  select   roomNo ,   avg ( temp )   as   avgTemp \n   group   by   roomNo  insert   into   OutputStream ;", 
            "title": "Siddhi Application"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#stream", 
            "text": "A stream is a logical series of events ordered in time. Its schema is defined via the  stream definition .\nA stream definition contains a unique name and a set of attributes with specific types and uniquely identifiable names within the stream.\nAll the events that are selected to be received into a specific stream have the same schema (i.e., have the same attributes in the same order).   Purpose  By defining a schema it unifies common types of events together. This enables them to be processed via queries using their defined attributes in a streaming manner, and allow sinks and sources to map events to/from various data formats.  Syntax  The syntax for defining a new stream is as follows.  define   stream   stream   name   ( attribute   name   attribute   type ,   attribute   name   attribute   type ,   ...   );   The following parameters are configured in a stream definition.     Parameter  Description      stream name  The name of the stream created. (It is recommended to define a stream name in  PascalCase .)    attribute name  The schema of an stream is defined by its attributes with uniquely identifiable attribute names. (It is recommended to define attribute names in  camelCase .)    attribute type  The type of each attribute defined in the schema.   This can be  STRING ,  INT ,  LONG ,  DOUBLE ,  FLOAT ,  BOOL  or  OBJECT .     To use and refer stream and attribute names that do not follow  [a-zA-Z_][a-zA-Z_0-9]*  format enclose them in  `. E.g. ``` $test(0)` ```.  To make the stream process events in asynchronous and multi-threading manner use the  @Async  annotation as shown in  Threading and Asynchronous  configuration section.  Example  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );   The above creates a stream named  TempStream  with the following attributes.   deviceID  of type  long  roomNo  of type  int    temp  of type  double", 
            "title": "Stream"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#source", 
            "text": "Sources receive events via multiple transports and in various data formats, and direct them into streams for processing.  A source configuration allows you to define a mapping in order to convert each incoming event from its native data format to a Siddhi event. When customizations to such mappings are not provided, Siddhi assumes that the arriving event adheres to the predefined format based on the stream definition and the selected message format.   Purpose  Source allows Siddhi to consume events from external systems, and map the events to adhere to the associated stream.   Syntax  To configure a stream that consumes events via a source, add the source configuration to a stream definition by adding the  @source  annotation with the required parameter values. \nThe source syntax is as follows:  @ source ( type = source_type ,   static . option . key1 = static_option_value1 ,   static . option . keyN = static_option_valueN , \n     @ map ( type = map_type ,   static . option_key1 = static_option_value1 ,   static . option . keyN = static_option_valueN , \n         @ attributes (   attributeN = attribute_mapping_N ,   attribute1 = attribute_mapping_1 ) \n     )  )  define   stream   StreamName   ( attribute1   Type1 ,   attributeN   TypeN );   This syntax includes the following annotations. Source  The  type  parameter of  @source  defines the source type that receives events. The other parameters to be configured \ndepends on the source type selected, some of the the parameters are optional.   For detailed information about the parameters see the documentation for the relevant source.  The following is the list of source types that are currently supported:   HTTP  Kafka  TCP  In-memory  WSO2Event  Email  JMS  File  RabbitMQ  MQTT  WebSocket  Twitter  Amazon SQS  CDC  Prometheus", 
            "title": "Source"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#source-mapper", 
            "text": "Each  @source  configuration has a mapping denoted by the  @map  annotation that converts the incoming messages format to Siddhi events.  The  type  parameter of the  @map  defines the map type to be used to map the data. The other parameters to be \nconfigured depends on the mapper selected. Some of these parameters are optional.  \nFor detailed information about the parameters see the documentation for the relevant mapper.   Tip  When the  @map  annotation is not provided,  @map(type='passThrough')  is used as default. This default mapper type can be used when source consumes Siddhi events and when it does not need any mappings.   Map Attributes  @attributes  is an optional annotation used with  @map  to define custom mapping. When  @attributes  is not provided, each mapper\nassumes that the incoming events  adhere to its own default data format. By adding the  @attributes  annotation, you \ncan configure mappers to extract data from the incoming message selectively, and assign them to attributes.   There are two ways you can configure map attributes.    Defining attributes as keys and mapping content as values in the following format:   @attributes( attributeN='mapping_N', attribute1='mapping_1')    Defining the mapping content of all attributes in the same order as how the attributes are defined in stream definition:   @attributes( 'mapping_1', 'mapping_N')     Supported Mapping Types  The following is a list of currently supported source mapping types:   WSO2Event  XML  TEXT  JSON  Binary  Key Value  CSV  Avro   Example  This query receives events via the  HTTP  source in the  JSON  data format, and directs them to the  InputStream  stream for processing. \nHere the HTTP source is configured to receive events on all network interfaces on the  8080 port, on the  foo  context, and \nit is secured via basic authentication.  @ source ( type = http ,   receiver . url = http://0.0.0.0:8080/foo ,   basic . auth . enabled = true ,  \n   @ map ( type = json ))  define   stream   InputStream   ( name   string ,   age   int ,   country   string );", 
            "title": "Source Mapper"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#sink", 
            "text": "Sinks publish events from the streams via multiple transports to external endpoints in various data formats.  A sink configuration allows you to define a mapping to convert the Siddhi event to the required output data format (such as  JSON ,  TEXT ,  XML , etc.).\nWhen customization to such mappings is not provided, Siddhi converts events to its default format based on the stream definition and \nthe selected data format to publish the events.  Purpose  Sinks provide a way to publish Siddhi events to external systems in the preferred data format.   Syntax  To configure a stream to publish events via a sink, add the sink configuration to a stream definition by adding the  @sink  \nannotation with the required parameter values. The sink syntax is as follows:  @ sink ( type = sink_type ,   static_option_key1 = static_option_value1 ,   dynamic_option_key1 = {{dynamic_option_value1}} , \n     @ map ( type = map_type ,   static_option_key1 = static_option_value1 ,   dynamic_option_key1 = {{dynamic_option_value1}} , \n         @ payload ( payload_mapping ) \n     )  )  define   stream   StreamName   ( attribute1   Type1 ,   attributeN   TypeN );    Dynamic Properties  The sink and sink mapper properties that are categorized as  dynamic  have the ability to absorb attributes values \nfrom their associated streams. This can be done by using the attribute names in double curly braces as  {{...}}  when configuring the property value.   Some valid dynamic properties values are:    '{{attribute1}}'  'This is {{attribute1}}'    {{attribute1}}   {{attributeN}}      Here the attribute names in the double curly braces will be replaced with event values during execution.    This syntax includes the following annotations.  Sink  The  type  parameter of the  @sink  annotation defines the sink type that publishes the events. The other parameters to be configured \ndepends on the sink type selected. Some of these parameters are optional, and some can have dynamic values.   For detailed information about the parameters see documentation for the relevant sink.  The following is a list of currently supported sink types.   HTTP  Kafka  TCP  In-memory  Log  WSO2Event  Email    JMS    File    RabbitMQ  MQTT  WebSocket  Amazon SQS  Prometheus", 
            "title": "Sink"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#distributed-sink", 
            "text": "Distributed Sinks publish events from a defined stream to multiple destination endpoints using load balancing and partitioning strategies.  Any ordinary sink can be used as a distributed sink. A distributed sink configuration allows you to define a common mapping to convert the Siddhi events for all its destination endpoints, \nallows you to define a distribution strategy (e.g.  roundRobin ,  partitioned ), and configuration for each specific endpoint destination.   Purpose  Distributed sinks provide a way to publish Siddhi events to multiple destination endpoints in the preferred data format.   Syntax  To configure a stream to publish events via a distributed sink, add the sink configuration to a stream definition by adding the  @sink  \nannotation and add the configuration parameters that are common of all the destination endpoints inside the  @sink  annotation \nalong with  @distribution  and  @destination  annotations providing distribution strategy and endpoint specific configurations. \nThe distributed sink syntax is as follows:  RoundRobin Distributed Sink  Publishes events to defined destinations in a round robin manner.   @ sink ( type = sink_type ,   common_option_key1 = common_option_value1 ,   common_option_key2 = {{common_option_value1}} , \n     @ map ( type = map_type ,   option_key1 = option_value1 ,   option_key2 = {{option_value1}} , \n         @ payload ( payload_mapping ) \n     ) \n     @ distribution ( strategy = roundRobin , \n         @ destination ( specific_option_key1 = specific_option_value1 ), \n         @ destination ( specific_option_key1 = specific_option_value2 )))  )  define   stream   StreamName   ( attribute1   Type1 ,   attributeN   TypeN );   Partitioned Distributed Sink  Publishes events to defined destinations by partitioning based on the hashcode of the events partition key.   @ sink ( type = sink_type ,   common_option_key1 = common_option_value1 ,   common_option_key2 = {{common_option_value1}} , \n     @ map ( type = map_type ,   option_key1 = option_value1 ,   option_key2 = {{option_value1}} , \n         @ payload ( payload_mapping ) \n     ) \n     @ distribution ( strategy = partitioned ,   partitionKey = partition_key , \n         @ destination ( specific_option_key1 = specific_option_value1 ), \n         @ destination ( specific_option_key1 = specific_option_value2 )))  )  define   stream   StreamName   ( attribute1   Type1 ,   attributeN   TypeN );", 
            "title": "Distributed Sink"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#sink-mapper", 
            "text": "Each  @sink  annotation has a mapping denoted by the   @map  annotation that converts the Siddhi event to an outgoing message format.  The  type  parameter of the  @map  annotation defines the map type based on which the event is mapped. The other parameters to be configured depends on the mapper selected. Some of these parameters are optional and some have dynamic values.     For detailed information about the parameters see the documentation for the relevant mapping type.   Tip  When the  @map  annotation is not provided,  @map(type='passThrough')  is used by default. This can be used when the sink publishes in the Siddhi event format, or when it does not need any mappings.   Map Payload  @payload  is an optional annotation used with the  @map  annotation to define a custom mapping. When the  @payload  annotation is not provided, each mapper\nmaps the outgoing events to its own default data format. By defining the  @payload  annotation you can configure mappers to produce the output payload with attribute names of your choice, using dynamic properties by selectively assigning \nthe attributes in your preferred format.   There are two ways you can configure the  @payload  annotation.    Some mappers such as  XML ,  JSON , and  Test  accept only one output payload using the following format:   @payload( 'This is a test message from {{user}}.' )    Some mappers such  key-value  accept series of mapping values defined as follows:   @payload( key1='mapping_1', 'key2'='user : {{user}}')   \nHere, apart from the dotted key names sush as  a.b.c , any constant string value such as  '$abc'  can also by used as a key.    Supported Mapping Types  The following is a list of currently supported sink mapping types:   WSO2Event  XML  TEXT  JSON  Binary  Key Value  CSV  Avro   Example  Following query publishes events from the  OutputStream  stream to an  HTTP  endpoint. Here the events are mapped to the default  JSON  payloads and sent to  http://localhost:8005/endpoint \n using the  POST  method, with the Accept  header, and secured via basic authentication where  admin  is both the username and the password.  @ sink ( type = http ,   publisher . url = http://localhost:8005/endpoint ,   method = POST ,   headers = Accept-Date:20/02/2017 ,  \n   basic . auth . username = admin ,   basic . auth . password = admin ,   basic . auth . enabled = true , \n   @ map ( type = json ))  define   stream   OutputStream   ( name   string ,   ang   int ,   country   string );   Following query publishes events from the  OutputStream  stream to multiple the  HTTP  endpoints using partitioning strategy. Here the events sent to either  http://localhost:8005/endpoint1 \nor  http://localhost:8006/endpoint2  based on the partitioning key  country . It uses default  JSON  mapping,  POST  method, and used  admin  as both the username and the password when publishing to both the endpoints.  @ sink ( type = http ,   method = POST ,   basic . auth . username = admin ,   basic . auth . password = admin ,  \n   basic . auth . enabled = true ,   @ map ( type = json ), \n   @ distribution ( strategy = partitioned ,   partitionKey = country , \n      @ destination ( publisher . url = http://localhost:8005/endpoint1 ), \n      @ destination ( publisher . url = http://localhost:8006/endpoint2 )))  define   stream   OutputStream   ( name   string ,   ang   int ,   country   string );", 
            "title": "Sink Mapper"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#query", 
            "text": "Each Siddhi query can consume one or more streams, and 0-1 tables, process the events in a streaming manner, and then generate an\n output event to a stream or perform a CRUD operation to a table.  Purpose  A query enables you to perform complex event processing and stream processing operations by processing incoming events one by one in the order they arrive.  Syntax  All queries contain an input and an output section. Some also contain a projection section. A simple query with all three sections is as follows.  from   input   stream   select   attribute   name ,   attribute   name ,   ...  insert   into   output   stream / table   Example  This query included in a Siddhi Application consumes events from the  TempStream  stream (that is already defined) and outputs the room temperature and the room number to the  RoomTempStream  stream.  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  from   TempStream   select   roomNo ,   temp  insert   into   RoomTempStream ;    Inferred Stream  Here, the  RoomTempStream  is an inferred Stream, which means it can be used as any other defined stream \nwithout explicitly defining its stream definition. The definition of the  RoomTempStream  is inferred from the \nfirst query that produces the stream.", 
            "title": "Query"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#query-projection", 
            "text": "Siddhi queries supports the following for query projections.  \n     \n         Action \n         Description \n     \n     \n         Selecting required objects for projection \n         This involves selecting only some of the attributes from the input stream to be inserted into an output stream.\n             \n            E.g., The following query selects only the `roomNo` and `temp` attributes from the `TempStream` stream.\n             from TempStream select roomNo, temp insert into RoomTempStream; \n         \n     \n     \n         Selecting all attributes for projection \n         Selecting all the attributes in an input stream to be inserted into an output stream. This can be done by using asterisk ( * ) or by omitting the `select` statement.\n             \n            E.g., Both the following queries select all the attributes in the `NewTempStream` stream.\n             from TempStream select * insert into NewTempStream; \n            or\n             from TempStream insert into NewTempStream; \n         \n     \n     \n         Renaming attributes \n         This selects attributes from the input streams and inserts them into the output stream with different names.\n             \n            E.g., This query renames `roomNo` to `roomNumber` and `temp` to `temperature`.\n             from TempStream  select roomNo as roomNumber, temp as temperature insert into RoomTempStream; \n         \n     \n     \n         Introducing the constant value \n         This adds constant values by assigning it to an attribute using `as`.\n             \n            E.g., This query specifies 'C' to be used as the constant value for `scale` attribute. \n             from TempStream select roomNo, temp, 'C' as scale insert into RoomTempStream; \n         \n     \n     \n         Using mathematical and logical expressions \n         This uses attributes with mathematical and logical expressions in the precedence order given below, and assigns them to the output attribute using `as`.\n             \n             Operator precedence \n             \n                 \n                     Operator \n                     Distribution \n                     Example \n                 \n                 \n                     \n                        ()\n                     \n                     \n                        Scope\n                     \n                     \n                         (cost + tax) * 0.05 \n                     \n                 \n                 \n                     \n                         IS NULL\n                     \n                     \n                        Null check\n                     \n                     \n                         deviceID is null \n                     \n                 \n                 \n                     \n                        NOT\n                     \n                     \n                        Logical NOT\n                     \n                     \n                         not (price > 10) \n                     \n                 \n                 \n                     \n                         *   /   %  \n                     \n                     \n                        Multiplication, division, modulo\n                     \n                     \n                         temp * 9/5 + 32 \n                     \n                 \n                 \n                     \n                        +   -  \n                     \n                     \n                        Addition, substraction\n                     \n                     \n                         temp * 9/5 - 32 \n                     \n                 \n                 \n                     \n                         <     < =   >   >=\n                     \n                     \n                        Comparators: less-than, greater-than-equal, greater-than, less-than-equal\n                     \n                     \n                         totalCost >= price * quantity \n                     \n                 \n                 \n                     \n                        ==   !=  \n                     \n                     \n                        Comparisons: equal, not equal\n                     \n                     \n                         totalCost !=  price * quantity \n                     \n                 \n                 \n                     \n                        IN\n                     \n                     \n                        Contains in table\n                     \n                     \n                         roomNo in ServerRoomsTable \n                     \n                 \n                 \n                     \n                        AND\n                     \n                     \n                        Logical AND\n                     \n                     \n                         temp  <  40 and (humidity  <  40 or humidity >= 60) \n                     \n                 \n                 \n                     \n                        OR\n                     \n                     \n                        Logical OR\n                     \n                     \n                         temp  <  40 or (humidity  <  40 and humidity >= 60) \n                     \n                 \n             \n            E.g., Converting Celsius to Fahrenheit and identifying rooms with room number between 10 and 15 as server rooms.\n             from TempStream select roomNo, temp * 9/5 + 32 as temp, 'F' as scale, roomNo > 10 and roomNo  <  15 as isServerRoom insert into RoomTempStream;", 
            "title": "Query Projection"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#function", 
            "text": "A function consumes zero, one or more parameters and always produces a result value. It can be used in any location where\n an attribute can be used.   Purpose  Functions encapsulates complex execution logic that makes Siddhi applications simple and easy to understand.   Function Parameters  Functions parameters can be attributes, constant values, results of other functions, results of mathematical or logical expressions or time parameters. \nFunction parameters vary depending on the function being called.  Time is a special parameter that can be defined using the integer time value followed by its unit as  int   unit . \nFollowing are the supported unit types. Upon execution, time returns the value in the scale of milliseconds as a long value.   \n     \n         \n            Unit  \n         \n         \n            Syntax\n         \n     \n     \n         \n            Year\n         \n         \n            year | years\n         \n     \n     \n         \n            Month\n         \n         \n            month | months\n         \n     \n     \n         \n            Week\n         \n         \n            week | weeks\n         \n     \n     \n         \n            Day\n         \n         \n            day | days\n         \n     \n     \n         \n            Hour\n         \n         \n           hour | hours\n         \n     \n     \n         \n           Minutes\n         \n         \n           minute | minutes | min\n         \n     \n     \n         \n           Seconds\n         \n         \n           second | seconds | sec\n         \n     \n     \n         \n           Milliseconds\n         \n         \n           millisecond | milliseconds\n         \n       E.g. Passing 1 hour and 25 minutes to  test()  function.  test(1 hour 25 min)   Note  Functions, mathematical expressions, and logical expressions can be used in a nested manner.   Following are some inbuilt functions shipped with Siddhi, for more functions refer execution  extensions .   eventTimestamp  log  UUID  default  cast  convert  ifThenElse  minimum  maximum  coalesce  instanceOfBoolean  instanceOfDouble  instanceOfFloat  instanceOfInteger  instanceOfLong  instanceOfString   Example  The following configuration converts the  roomNo  to  string  and adds a  messageID  to each event using the  convert  and  UUID  functions.  from   TempStream  select   convert ( roomNo ,   string )   as   roomNo ,   temp ,   UUID ()   as   messageID  insert   into   RoomTempStream ;", 
            "title": "Function"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#filter", 
            "text": "Filters are included in queries to filter information from input streams based on a specified condition.  Purpose  A filter allows you to separate events that match a specific condition as the output, or for further processing.  Syntax  Filter conditions should be defined in square brackets next to the input stream name as shown below.  from   input   stream [ filter   condition ]  select   attribute   name ,   attribute   name ,   ...  insert   into   output   stream   Example  This query filters all server rooms of which the room number is within the range of 100-210, and having temperature greater than 40 degrees \nfrom the  TempStream  stream, and inserts the results into the  HighTempStream  stream.  from   TempStream [( roomNo   =   100   and   roomNo     210 )   and   temp     40 ]  select   roomNo ,   temp  insert   into   HighTempStream ;", 
            "title": "Filter"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#window", 
            "text": "Windows allow you to capture a subset of events based on a specific criterion from an input stream for calculation. \nEach input stream can only have a maximum of one window.  Purpose  To create subsets of events within a stream based on time duration, number of events, etc for processing. \nA window can operate in a sliding or tumbling (batch) manner.  Syntax  The  #window  prefix should be inserted next to the relevant stream in order to use a window.  from   input   stream # window . window   name ( parameter ,   parameter ,   ...   )  select   attribute   name ,   attribute   name ,   ...  insert   event   type   into   output   stream    Note  Filter condition can be applied both before and/or after the window   Example  If you want to identify the maximum temperature out of the last 10 events, you need to define a  length  window of 10 events.\n This window operates in a sliding mode where the following 3 subsets are calculated when a list of 12 events are received in a sequential order.     Subset  Event Range      1  1-10    2  2-11    3  3-12     The following query finds the maximum temperature out of  last 10 events  from the  TempStream  stream, \nand inserts the results into the  MaxTempStream  stream.  from   TempStream # window . length ( 10 )  select   max ( temp )   as   maxTemp  insert   into   MaxTempStream ;   If you define the maximum temperature reading out of every 10 events, you need to define a  lengthBatch  window of 10 events.\nThis window operates as a batch/tumbling mode where the following 3 subsets are calculated when a list of 30 events are received in a sequential order.     Subset  Event Range      1  1-10    2  11-20    3  21-30     The following query finds the maximum temperature out of  every 10 events  from the  TempStream  stream, \nand inserts the results into the  MaxTempStream  stream.  from   TempStream # window . lengthBatch ( 10 )  select   max ( temp )   as   maxTemp  insert   into   MaxTempStream ;    Note  Similar operations can be done based on time via  time  windows and  timeBatch  windows and for others. \nCode segments such as  #window.time(10 min)  considers events that arrive during the last 10 minutes in a sliding manner, and the  #window.timeBatch(2 min)  considers events that arrive every 2 minutes in a tumbling manner.    Following are some inbuilt windows shipped with Siddhi. For more window types, see execution  extensions .   time  timeBatch  batch  timeLength  length  lengthBatch  sort  frequent  lossyFrequent  session  cron  externalTime  externalTimeBatch  delay   Output event types    Projection of the query depends on the output event types such as,  current  and  expired  event types.\n By default all queries produce  current  events and only queries with windows produce  expired  events \n when events expire from the window. You can specify whether the output of a query should be only current events, only expired events or both current and expired events.  Note!  Controlling the output event types does not alter the execution within the query, and it does not affect the accuracy of the query execution.    The following keywords can be used with the output stream to manipulate output.      Output event types  Description      current events  Outputs events when incoming events arrive to be processed by the query.   This is default when no specific output event type is specified.    expired events  Outputs events when events expires from the window.    all events  Outputs events when incoming events arrive to be processed by the query as well as   when events expire from the window.     The output event type keyword can be used between  insert  and  into  as shown in the following example.  Example  This query delays all events in a stream by 1 minute.    from   TempStream # window . time ( 1   min )  select   *  insert   expired   events   into   DelayedTempStream", 
            "title": "Window"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#aggregate-function", 
            "text": "Aggregate functions perform aggregate calculations in the query. \nWhen a window is defined the aggregation is restricted within that window. If no window is provided aggregation is performed from the start of the Siddhi application.  Syntax  from   input   stream # window . window   name ( parameter ,   parameter ,   ...   )  select   aggregate   function ( parameter ,   parameter ,   ...   )   as   attribute   name ,   attribute2   name ,   ...  insert   into   output   stream ;   Aggregate Parameters  Aggregate parameters can be attributes, constant values, results of other functions or aggregates, results of mathematical or logical expressions, or time parameters. \nAggregate parameters configured in a query  depends on the aggregate function being called.  Example  The following query calculates the average value for the  temp  attribute of the  TempStream  stream. This calculation is done for the last 10 minutes in a sliding manner, and the result is output as  avgTemp  to the  AvgTempStream  output stream.  from   TempStream # window . time ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo ,   deviceID  insert   into   AvgTempStream ;   Following are some inbuilt aggregation functions shipped with Siddhi, for more aggregation functions, see execution  extensions .   avg  sum  max  min  count  distinctCount  maxForever  minForever  stdDev", 
            "title": "Aggregate function"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#group-by", 
            "text": "Group By allows you to group the aggregate based on specified attributes.  Syntax \nThe syntax for the Group By aggregate function is as follows:  from   input   stream # window . window   name (...)  select   aggregate   function (   parameter ,   parameter ,   ...)   as   attribute1   name ,   attribute2   name ,   ...  group   by   attribute1   name ,   attribute2   name   ...  insert   into   output   stream ;   Example \nThe following query calculates the average temperature per  roomNo  and  deviceID  combination, for events that arrive at the  TempStream  stream\nfor a sliding time window of 10 minutes.  from   TempStream # window . time ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo ,   deviceID  group   by   roomNo ,   deviceID  insert   into   AvgTempStream ;", 
            "title": "Group By"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#having", 
            "text": "Having allows you to filter events after processing the  select  statement.  Purpose \nThis allows you to filter the aggregation output.  Syntax \nThe syntax for the Having clause is as follows:  from   input   stream # window . window   name (   ...   )  select   aggregate   function (   parameter ,   parameter ,   ...)   as   attribute1   name ,   attribute2   name ,   ...  group   by   attribute1   name ,   attribute2   name   ...  having   condition  insert   into   output   stream ;   Example  The following query calculates the average temperature per room for the last 10 minutes, and alerts if it exceeds 30 degrees.  from   TempStream # window . time ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo  group   by   roomNo  having   avgTemp     30  insert   into   AlertStream ;", 
            "title": "Having"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#order-by", 
            "text": "Order By allows you to order the aggregated result in ascending and/or descending order based on specified attributes. By default ordering will be done in\nascending manner. User can use 'desc' keyword to order in descending manner.  Syntax \nThe syntax for the Order By clause is as follows:  from   input   stream # window . window   name (   ...   )  select   aggregate   function (   parameter ,   parameter ,   ...)   as   attribute1   name ,   attribute2   name ,   ...  group   by   attribute1   name ,   attribute2   name   ...  having   condition  order   by   attribute1   name   ( asc   |   desc ) ? ,   attribute2   name   ( ascend / descend ) ? ,   ...  insert   into   output   stream ;   Example  The following query calculates the average temperature per  roomNo  and  deviceID  combination for every 10 minutes, and generate output events\nby ordering them in the ascending order of the room's avgTemp and then by the descending order of roomNo.  from   TempStream # window . timeBatch ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo ,   deviceID  group   by   roomNo ,   deviceID  order   by   avgTemp ,   roomNo   desc  insert   into   AvgTempStream ;", 
            "title": "Order By"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#limit-offset", 
            "text": "When events are emitted as a batch, offset allows you to offset beginning of the output event batch and limit allows you to limit the number of events in the batch from the defined offset. \nWith this users can specify which set of events need be emitted.   Syntax \nThe syntax for the Limit   Offset clause is as follows:  from   input   stream # window . window   name (   ...   )  select   aggregate   function (   parameter ,   parameter ,   ...)   as   attribute1   name ,   attribute2   name ,   ...  group   by   attribute1   name ,   attribute2   name   ...  having   condition  order   by   attribute1   name   ( asc   |   desc ) ? ,   attribute2   name   ( ascend / descend ) ? ,   ...  limit   positive   interger ?  offset   positive   interger ?  insert   into   output   stream ;   Here both  limit  and  offset  are optional where  limit  by default output all the events and  offset  by default set to  0 .  Example \nThe following query calculates the average temperature per  roomNo  and  deviceID  combination, for events that arrive at the  TempStream  stream\nfor every 10 minutes and emits two events with highest average temperature.  from   TempStream # window . timeBatch ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo ,   deviceID  group   by   roomNo ,   deviceID  order   by   avgTemp   desc  limit   2  insert   into   HighestAvgTempStream ;   The following query calculates the average temperature per  roomNo  and  deviceID  combination, for events that arrive at the  TempStream  stream\nfor every 10 minutes and emits third, forth and fifth events when sorted in descending order based on their average temperature.  from   TempStream # window . timeBatch ( 10   min )  select   avg ( temp )   as   avgTemp ,   roomNo ,   deviceID  group   by   roomNo ,   deviceID  order   by   avgTemp   desc  limit   3  offset   2  insert   into   HighestAvgTempStream ;", 
            "title": "Limit &amp; Offset"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#join-stream", 
            "text": "Joins allow you to get a combined result from two streams in real-time based on a specified condition.   Purpose \nStreams are stateless. Therefore, in order to join two streams, they need to be connected to a window so that there is a pool of events that can be used for joining. Joins also accept conditions to join the appropriate events from each stream.  During the joining process each incoming event of each stream is matched against all the events in the other \nstream's window based on the given condition, and the output events are generated for all the matching event pairs.   Note  Join can also be performed with  stored data ,  aggregation  or externally  defined windows .   Syntax  The syntax for a join is as follows:  from   input   stream # window . window   name ( parameter ,   ...   )   { unidirectional }   { as   reference } \n          join   input   stream # window . window   name ( parameter ,    ...   )   { unidirectional }   { as   reference } \n     on   join   condition  select   attribute   name ,   attribute   name ,   ...  insert   into   output   stream   Here, the  join condition  allows you to match the attributes from both the streams.   Unidirectional join operation  By default, events arriving at either stream can trigger the joining process. However, if you want to control the \njoin execution, you can add the  unidirectional  keyword next to a stream in the join definition as depicted in the \nsyntax in order to enable that stream to trigger the join operation. Here, events arriving at other stream only update the \n window of that stream, and this stream does not trigger the join operation.   Note  The  unidirectional  keyword cannot be applied to both the input streams because the default behaviour already allows both streams to trigger the join operation.   Example  Assuming that the temperature of regulators are updated every minute. \nFollowing is a Siddhi App that controls the temperature regulators if they are not already  on  for all the rooms with a room temperature greater than 30 degrees.    define   stream   TempStream ( deviceID   long ,   roomNo   int ,   temp   double );  define   stream   RegulatorStream ( deviceID   long ,   roomNo   int ,   isOn   bool );  from   TempStream [ temp     30 . 0 ] # window . time ( 1   min )   as   T \n   join   RegulatorStream [ isOn   ==   false ] # window . length ( 1 )   as   R \n   on   T . roomNo   ==   R . roomNo  select   T . roomNo ,   R . deviceID ,   start   as   action  insert   into   RegulatorActionStream ;   Supported join types    Following are the supported operations of a join clause.    Inner join (join)    This is the default behaviour of a join operation.  join  is used as the keyword to join both the streams. The output is generated only if there is a matching event in both the streams.    Left outer join    The  left outer join  operation allows you to join two streams to be merged based on a condition.  left outer join  is used as the keyword to join both the streams.  Here, it returns all the events of left stream even if there are no matching events in the right stream by \nhaving null values for the attributes of the right stream.  Example  The following query generates output events for all events from the  StockStream  stream regardless of whether a matching \nsymbol exists in the  TwitterStream  stream or not.  \nfrom StockStream#window.time(1 min) as S\n  left outer join TwitterStream#window.length(1) as T\n  on S.symbol== T.symbol\nselect S.symbol as symbol, T.tweet, S.price\ninsert into outputStream ;        Right outer join    This is similar to a left outer join.  Right outer join  is used as the keyword to join both the streams.\nIt returns all the events of the right stream even if there are no matching events in the left stream.     Full outer join    The full outer join combines the results of left outer join and right outer join.  full outer join  is used as the keyword to join both the streams.\nHere, output event are generated for each incoming event even if there are no matching events in the other stream.  Example  The following query generates output events for all the incoming events of each stream regardless of whether there is a \nmatch for the  symbol  attribute in the other stream or not.  \nfrom StockStream#window.time(1 min) as S\n  full outer join TwitterStream#window.length(1) as T\n  on S.symbol== T.symbol\nselect S.symbol as symbol, T.tweet, S.price\ninsert into outputStream ;", 
            "title": "Join (Stream)"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#pattern", 
            "text": "This is a state machine implementation that allows you to detect patterns in the events that arrive over time. This can correlate events within a single stream or between multiple streams.   Purpose    Patterns allow you to identify trends in events over a time period.  Syntax  The following is the syntax for a pattern query:  from   ( every ) ?   event   reference = input   stream [ filter   condition ]   -  \n     ( every ) ?   event   reference = input   stream   [ filter   condition ]   -  \n     ...  \n     ( within   time   gap ) ?       select   event   reference . attribute   name ,   event   reference . attribute   name ,   ...  insert   into   output   stream      Items  Description      -  This is used to indicate an event that should be following another event. The subsequent event does not necessarily have to occur immediately after the preceding event. The condition to be met by the preceding event should be added before the sign, and the condition to be met by the subsequent event should be added after the sign.    event reference  This allows you to add a reference to the the matching event so that it can be accessed later for further processing.    (within  time gap )?  The  within  clause is optional. It defines the time duration within which all the matching events should occur.    every  every  is an optional keyword. This defines whether the event matching should be triggered for every event arrival in the specified stream with the matching condition.   When this keyword is not used, the matching is carried out only once.     Siddhi also supports pattern matching with counting events and matching events in a logical order such as ( and ,  or , and  not ). These are described in detail further below in this guide.  Example  This query sends an alert if the temperature of a room increases by 5 degrees within 10 min.  from   every (   e1 = TempStream   )   -   e2 = TempStream [   e1 . roomNo   ==   roomNo   and   ( e1 . temp   +   5 )   =   temp   ] \n     within   10   min  select   e1 . roomNo ,   e1 . temp   as   initialTemp ,   e2 . temp   as   finalTemp  insert   into   AlertStream ;   Here, the matching process begins for each event in the  TempStream  stream (because  every  is used with  e1=TempStream ), \nand if  another event arrives within 10 minutes with a value for the  temp  attribute that is greater than or equal to  e1.temp + 5  \nof the event e1, an output is generated via the  AlertStream .", 
            "title": "Pattern"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#counting-pattern", 
            "text": "Counting patterns allow you to match multiple events that may have been received for the same matching condition.\nThe number of events matched per condition can be limited via condition postfixes.  Syntax  Each matching condition can contain a collection of events with the minimum and maximum number of events to be matched as shown in the syntax below.   from   ( every ) ?   event   reference = input   stream [ filter   condition ]   ( min   count : max   count ) ?   -   \n     ...  \n     ( within   time   gap ) ?       select   event   reference ([ event   index ]) ? . attribute   name ,   ...  insert   into   output   stream      Postfix  Description  Example      n1:n2  This matches  n1  to  n2  events (including  n1  and not more than  n2 ).  1:4  matches 1 to 4 events.    n:  This matches  n  or more events (including  n ).  2:  matches 2 or more events.    :n  This matches up to  n  events (excluding  n ).  :5  matches up to 5 events.    n  This matches exactly  n  events.  5  matches exactly 5 events.     Specific occurrences of the event in a collection can be retrieved by using an event index with its reference.\nSquare brackets can be used to indicate the event index where  1  can be used as the index of the first event and  last  can be used as the index\n for the  last  available event in the event collection. If you provide an index greater then the last event index,\n the system returns  null . The following are some valid examples.   e1[3]  refers to the 3rd event.  e1[last]  refers to the last event.  e1[last - 1]  refers to the event before the last event.   Example  The following Siddhi App calculates the temperature difference between two regulator events.  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  define   stream   RegulatorStream   ( deviceID   long ,   roomNo   int ,   tempSet   double ,   isOn   bool );  from   every (   e1 = RegulatorStream )   -   e2 = TempStream [ e1 . roomNo == roomNo ] 1 :   -   e3 = RegulatorStream [ e1 . roomNo == roomNo ]  select   e1 . roomNo ,   e2 [ 0 ]. temp   -   e2 [ last ]. temp   as   tempDiff  insert   into   TempDiffStream ;", 
            "title": "Counting Pattern"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#logical-patterns", 
            "text": "Logical patterns match events that arrive in temporal order and correlate them with logical relationships such as  and ,  or  and  not .   Syntax  from   ( every ) ?   ( not ) ?   event   reference = input   stream [ filter   condition ]  \n           (( and | or )   event   reference = input   stream [ filter   condition ]) ?   ( within   time   gap ) ?   -   \n     ...   select   event   reference ([ event   index ]) ? . attribute   name ,   ...  insert   into   output   stream   Keywords such as  and ,  or , or  not  can be used to illustrate the logical relationship.     Key Word  Description      and  This allows both conditions of  and  to be matched by two events in any order.    or  The state succeeds if either condition of  or  is satisfied. Here the event reference of the other condition is  null .    not  condition1  and  condition2  When  not  is included with  and , it identifies the events that match   arriving before any event that match  .    not  condition  for  time period  When  not  is included with  for , it allows you to identify a situation where no event that matches  condition1  arrives during the specified  time period .  e.g., from not TemperatureStream[temp   60] for 5 sec .     Here the  not  pattern can be followed by either an  and  clause or the effective period of  not  can be concluded after a given  time period . Further in Siddhi more than two streams cannot be matched with logical conditions using  and ,  or , or  not  clauses at this point.", 
            "title": "Logical Patterns"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#detecting-non-occurring-events", 
            "text": "Siddhi allows you to detect non-occurring events via multiple combinations of the key words specified above as shown in the table below.  In the patterns listed, P* can be either a regular event pattern, an absent event pattern or a logical pattern.     Pattern  Detected Scenario      not A for  time period  The non-occurrence of event A within  time period  after system start up.  e.g., Generating an alert if a taxi has not reached its destination within 30 minutes, to indicate that the passenger might be in danger.    not A for  time period  and B  After system start up, event A does not occur within  time period , but event B occurs at some point in time.   e.g., Generating an alert if a taxi has not reached its destination within 30 minutes, and the passenger marked that he/she is in danger at some point in time.    not A for  time period 1  and not B for  time period 2  After system start up, event A doess not occur within  time period 1 , and event B also does not occur within  time period 2 .   e.g., Generating an alert if the driver of a taxi has not reached the destination within 30 minutes, and the passenger has not marked himself/herself to be in danger within that same time period.    not A for  time period  or B  After system start up, either event A does not occur within  time period , or event B occurs at some point in time.   e.g., Generating an alert if the taxi has not reached its destination within 30 minutes, or if the passenger has marked that he/she is in danger at some point in time.    not A for  time period 1  or not B for  time period 2  After system start up, either event A does not occur within  time period 1 , or event B occurs within  time period 2 .   e.g., Generating an alert to indicate that the driver is not on an expected route if the taxi has not reached destination A within 20 minutes, or reached destination B within 30 minutes.    A \u2192 not B for  time period  Event B does not occur within  time period  after the occurrence of event A. e.g., Generating an alert if the taxi has reached its destination, but this was not followed by a payment record.    P* \u2192 not A for  time period  and B  After the occurrence of P*, event A does not occur within  time period , and event B occurs at some point in time.     P* \u2192 not A for  time period 1  and not B for  time period 2  After the occurrence of P*, event A does not occur within  time period 1 , and event B does not occur within  time period 2 .    P* \u2192 not A for  time period  or B  After the occurrence of P*, either event A does not occur within  time period , or event B occurs at some point in time.    P* \u2192 not A for  time period 1  or not B for  time period 2  After the occurrence of P*, either event A does not occur within  time period 1 , or event B does not occur within  time period 2 .    not A for  time period  \u2192 B  Event A does occur within  time period  after the system start up, but event B occurs after that  time period  has elapsed.    not A for  time period  and B \u2192 P*  Event A does not occur within  time period , and event B occurs at some point in time. Then P* occurs after the  time period  has elapsed, and after B has occurred.    not A for  time period 1  and not B for  time period 2  \u2192 P*  After system start up, event A does not occur within  time period 1 , and event B does not occur within  time period 2 . However, P* occurs after both A and B.    not A for  time period  or B \u2192 P*  After system start up, event A does not occur within  time period  or event B occurs at some point in time. The P* occurs after  time period  has elapsed, or after B has occurred.    not A for  time period 1  or not B for  time period 2  \u2192 P*  After system start up, either event A does not occur within  time period 1 , or event B does not occur within  time period 2 . Then P*  occurs after both  time period 1  and  time period 2  have elapsed.    not A and B  Event A does not occur before event B.    A and not B  Event B does not occur before event A.     Example  Following Siddhi App, sends the  stop  control action to the regulator when the key is removed from the hotel room.   define   stream   RegulatorStateChangeStream ( deviceID   long ,   roomNo   int ,   tempSet   double ,   action   string );  define   stream   RoomKeyStream ( deviceID   long ,   roomNo   int ,   action   string );  from   every (   e1 = RegulatorStateChangeStream [   action   ==   on   ]   )   -  \n       e2 = RoomKeyStream [   e1 . roomNo   ==   roomNo   and   action   ==   removed   ]   or   e3 = RegulatorStateChangeStream [   e1 . roomNo   ==   roomNo   and   action   ==   off ]  select   e1 . roomNo ,   ifThenElse (   e2   is   null ,   none ,   stop   )   as   action  having   action   !=   none  insert   into   RegulatorActionStream ;   This Siddhi Application generates an alert if we have switch off the regulator before the temperature reaches 12 degrees.    define   stream   RegulatorStateChangeStream ( deviceID   long ,   roomNo   int ,   tempSet   double ,   action   string );  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  from   e1 = RegulatorStateChangeStream [ action   ==   start ]   -   not   TempStream [ e1 . roomNo   ==   roomNo   and   temp     12 ]   and   e2 = RegulatorStateChangeStream [ action   ==   off ]  select   e1 . roomNo   as   roomNo  insert   into   AlertStream ;   This Siddhi Application generates an alert if the temperature does not reduce to 12 degrees within 5 minutes of switching on the regulator.    define   stream   RegulatorStateChangeStream ( deviceID   long ,   roomNo   int ,   tempSet   double ,   action   string );  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  from   e1 = RegulatorStateChangeStream [ action   ==   start ]   -   not   TempStream [ e1 . roomNo   ==   roomNo   and   temp     12 ]   for   5 min  select   e1 . roomNo   as   roomNo  insert   into   AlertStream ;", 
            "title": "Detecting Non-occurring Events"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#sequence", 
            "text": "Sequence is a state machine implementation that allows you to detect the sequence of event occurrences over time. \nHere  all matching events need to arrive consecutively  to match the sequence condition, and there cannot be any non-matching events arriving within a matching sequence of events.\nThis can correlate events within a single stream or between multiple streams.   Purpose    This allows you to detect a specified event sequence over a specified time period.   Syntax  The syntax for a sequence query is as follows:  from   ( every ) ?   event   reference = input   stream [ filter   condition ],  \n     event   reference = input   stream   [ filter   condition ],  \n     ...  \n     ( within   time   gap ) ?       select   event   reference . attribute   name ,   event   reference . attribute   name ,   ...  insert   into   output   stream      Items  Description      ,  This represents the immediate next event i.e., when an event that matches the first condition arrives, the event that arrives immediately after it should match the second condition.    event reference  This allows you to add a reference to the the matching event so that it can be accessed later for further processing.    (within  time gap )?  The  within  clause is optional. It defines the time duration within which all the matching events should occur.    every  every  is an optional keyword. This defines whether the matching event should be triggered for every event that arrives at the specified stream with the matching condition.   When this keyword is not used, the matching is carried out only once.     Example  This query generates an alert if the increase in the temperature between two consecutive temperature events exceeds one degree.  from   every   e1 = TempStream ,   e2 = TempStream [ e1 . temp   +   1     temp ]  select   e1 . temp   as   initialTemp ,   e2 . temp   as   finalTemp  insert   into   AlertStream ;   Counting Sequence  Counting sequences allow you to match multiple events for the same matching condition.\nThe number of events matched per condition can be limited via condition postfixes such as  Counting Patterns , or by using the  * ,  + , and  ?  operators.  The matching events can also be retrieved using event indexes, similar to how it is done in  Counting Patterns .  Syntax  Each matching condition in a sequence can contain a collection of events as shown below.   from   ( every ) ?   event   reference = input   stream [ filter   condition ]( +|*|? ) ? ,  \n     event   reference = input   stream   [ filter   condition ]( +|*|? ) ? ,  \n     ...  \n     ( within   time   gap ) ?       select   event   reference . attribute   name ,   event   reference . attribute   name ,   ...  insert   into   output   stream      Postfix symbol  Required/Optional  Description      +  Optional  This matches  one or more  events to the given condition.    *  Optional  This matches  zero or more  events to the given condition.    ?  Optional  This matches  zero or one  events to the given condition.     Example  This Siddhi application identifies temperature peeks.  define   stream   TempStream ( deviceID   long ,   roomNo   int ,   temp   double );  from   every   e1 = TempStream ,   e2 = TempStream [ e1 . temp   =   temp ] + ,   e3 = TempStream [ e2 [ last ]. temp     temp ]  select   e1 . temp   as   initialTemp ,   e2 [ last ]. temp   as   peakTemp  insert   into   PeekTempStream ;   Logical Sequence  Logical sequences identify logical relationships using  and ,  or  and  not  on consecutively arriving events.  Syntax \nThe syntax for a logical sequence is as follows:  from   ( every ) ?   ( not ) ?   event   reference = input   stream [ filter   condition ]  \n           (( and | or )   event   reference = input   stream [ filter   condition ]) ?   ( within   time   gap ) ? ,  \n     ...   select   event   reference ([ event   index ]) ? . attribute   name ,   ...  insert   into   output   stream   Keywords such as  and ,  or , or  not  can be used to illustrate the logical relationship, similar to how it is done in  Logical Patterns .   Example  This Siddhi application notifies the state when a regulator event is immediately followed by both temperature and humidity events.   define   stream   TempStream ( deviceID   long ,   temp   double );  define   stream   HumidStream ( deviceID   long ,   humid   double );  define   stream   RegulatorStream ( deviceID   long ,   isOn   bool );  from   every   e1 = RegulatorStream ,   e2 = TempStream   and   e3 = HumidStream  select   e2 . temp ,   e3 . humid  insert   into   StateNotificationStream ;", 
            "title": "Sequence"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#output-rate-limiting", 
            "text": "Output rate limiting allows queries to output events periodically based on a specified condition.  Purpose  This allows you to limit the output to avoid overloading the subsequent executions, and to remove unnecessary information.  Syntax  The syntax of an output rate limiting configuration is as follows:  from   input   stream   ...  select   attribute   name ,   attribute   name ,   ...  output   rate   limiting   configuration  insert   into   output   stream   Siddhi supports three types of output rate limiting configurations as explained in the following table:      Rate limiting configuration  Syntax  Description      Based on time  output event  every  time interval  This outputs  output event  every  time interval  time interval.    Based on number of events  output event  every  event interval  events  This outputs  output event  for every  event interval  number of events.    Snapshot based output  snapshot every  time interval  This outputs all events in the window (or the last event if no window is defined in the query) for every given  time interval  time interval.     Here the  output event  specifies the event(s) that should be returned as the output of the query. \nThe possible values are as follows:   first  : Only the first event processed by the query during the specified time interval/sliding window is emitted.   last  : Only the last event processed by the query during the specified time interval/sliding window is emitted.\n*  all  : All the events processed by the query during the specified time interval/sliding window are emitted.  When no  output event  is defined,  all  is used by default.  Examples    Returning events based on the number of events  Here, events are emitted every time the specified number of events arrive. You can also specify whether to emit only the first event/last event, or all the events out of the events that arrived.  In this example, the last temperature per sensor is emitted for every 10 events.  \nfrom TempStreamselect \nselect temp, deviceID\ngroup by deviceID\noutput last every 10 events\ninsert into LowRateTempStream;        Returning events based on time  Here events are emitted for every predefined time interval. You can also specify whether to emit only the first event, last event, or all events out of the events that arrived during the specified time interval.  In this example, emits all temperature events every 10 seconds    \nfrom TempStreamoutput \noutput every 10 sec\ninsert into LowRateTempStream;        Returning a periodic snapshot of events  This method works best with windows. When an input stream is connected to a window, snapshot rate limiting emits all the current events that have arrived and do not have corresponding expired events for every predefined time interval. \nIf the input stream is not connected to a window, only the last current event for each predefined time interval is emitted.  This query emits a snapshot of the events in a time window of 5 seconds every 1 second.   \nfrom TempStream#window.time(5 sec)\noutput snapshot every 1 sec\ninsert into SnapshotTempStream;", 
            "title": "Output rate limiting"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#partition", 
            "text": "Partitions divide streams and queries into isolated groups in  order to process them in parallel and in isolation. \nA partition can contain one or more queries and there can be multiple instances where the same queries and streams are replicated for each partition. \nEach partition is tagged with a partition key. Those partitions only process the events that match the corresponding partition key.   Purpose    Partitions allow you to process the events groups in isolation so that event processing can be performed using the same set of queries for each group.   Partition key generation  A partition key can be generated in the following two methods:    Partition by value  This is created by generating unique values using input stream attributes.  Syntax  \npartition with (  expression  of  stream name ,  expression  of  stream name , ... )\nbegin\n     query \n     query \n    ...\nend;   Example  This query calculates the maximum temperature recorded within the last 10 events per  deviceID .  \npartition with ( deviceID of TempStream )\nbegin\n    from TempStream#window.length(10)\n    select roomNo, deviceID, max(temp) as maxTemp\n    insert into DeviceTempStream;\nend;    Partition by range  This is created by mapping each partition key to a range condition of the input streams numerical attribute.  Syntax  \npartition with (  condition  as  partition key  or  condition  as  partition key  or ... of  stream name , ... )\nbegin\n     query \n     query \n    ...\nend;  Example  This query calculates the average temperature for the last 10 minutes per office area.  \npartition with ( roomNo  = 1030 as 'serverRoom' or \n                 roomNo   1030 and roomNo  = 330 as 'officeRoom' or \n                 roomNo   330 as 'lobby' of TempStream)\nbegin\n    from TempStream#window.time(10 min)\n    select roomNo, deviceID, avg(temp) as avgTemp\n    insert into AreaTempStream\nend;", 
            "title": "Partition"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#inner-stream", 
            "text": "Queries inside a partition block can use inner streams to communicate with each other while preserving partition isolation.\nInner streams are denoted by a \"#\" placed before the stream name, and these streams cannot be accessed outside a partition block.   Purpose  Inner streams allow you to connect queries within the partition block so that the output of a query can be used as an input only by another query \nwithin the same partition. Therefore, you do not need to repartition the streams if they are communicating within the partition.  Example  This partition calculates the average temperature of every 10 events for each sensor, and sends an output to the  DeviceTempIncreasingStream  stream if the consecutive average temperature values increase by more than \n5 degrees.  \npartition with ( deviceID of TempStream )\nbegin\n    from TempStream#window.lengthBatch(10)\n    select roomNo, deviceID, avg(temp) as avgTemp\n    insert into #AvgTempStream\n\n    from every (e1=#AvgTempStream),e2=#AvgTempStream[e1.avgTemp + 5  <  avgTemp]\n    select e1.deviceID, e1.avgTemp as initialAvgTemp, e2.avgTemp as finalAvgTemp\n    insert into DeviceTempIncreasingStream\nend;", 
            "title": "Inner Stream"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#table", 
            "text": "A table is a stored version of an stream or a table of events. Its schema is defined via the  table definition  that is\nsimilar to a stream definition. These events are by default stored  in-memory , but Siddhi also provides store extensions to work with data/events stored in various data stores through the \ntable abstraction.  Purpose  Tables allow Siddhi to work with stored events. By defining a schema for tables Siddhi enables them to be processed by queries using their defined attributes with the streaming data. You can also interactively query the state of the stored events in the table.  Syntax  The syntax for a new table definition is as follows:  define   table   table   name   ( attribute   name   attribute   type ,   attribute   name   attribute   type ,   ...   );   The following parameters are configured in a table definition:     Parameter  Description      table name  The name of the table defined. ( PascalCase  is used for table name as a convention.)    attribute name  The schema of the table is defined by its attributes with uniquely identifiable attribute names ( camelCase  is used for attribute names as a convention.)    attribute type  The type of each attribute defined in the schema.   This can be  STRING ,  INT ,  LONG ,  DOUBLE ,  FLOAT ,  BOOL  or  OBJECT .     Example  The following defines a table named  RoomTypeTable  with  roomNo  and  type  attributes of data types  int  and  string  respectively.  define   table   RoomTypeTable   (   roomNo   int ,   type   string   );   Primary Keys  Tables can be configured with primary keys to avoid the duplication of data.   Primary keys are configured by including the  @PrimaryKey( 'key1', 'key2' )  annotation to the table definition. \nEach event table configuration can have only one  @PrimaryKey  annotation. \nThe number of attributes supported differ based on the table implementations. When more than one attribute \n is used for the primary key, the uniqueness of the events stored in the table is determined based on the combination of values for those attributes.  Examples  This query creates an event table with the  symbol  attribute as the primary key. \nTherefore each entry in this table must have a unique value for  symbol  attribute.  @ PrimaryKey ( symbol )  define   table   StockTable   ( symbol   string ,   price   float ,   volume   long );   Indexes  Indexes allow tables to be searched/modified much faster.   Indexes are configured by including the  @Index( 'key1', 'key2' )  annotation to the table definition.\n Each event table configuration can have 0-1  @Index  annotations. \n Support for the  @Index  annotation and the number of attributes supported differ based on the table implementations. \n When more then one attribute is used for index, each one of them is used to index the table for fast access of the data. \n Indexes can be configured together with primary keys.   Examples  This query creates an indexed event table named  RoomTypeTable  with the  roomNo  attribute as the index key.  @ Index ( roomNo )  define   table   RoomTypeTable   ( roomNo   int ,   type   string );", 
            "title": "Table"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#store", 
            "text": "Store is a table that refers to data/events stored in data stores outside of Siddhi such as RDBMS, Cassandra, etc. \nStore is defined via the  @store  annotation, and the store schema is defined via a  table definition  associated with it.  Purpose  Store allows Siddhi to search, retrieve and manipulate data stored in external data stores through Siddhi queries.   Syntax  The syntax for a defining store and it's associated table definition is as follows:  @ store ( type = store_type ,   static . option . key1 = static_option_value1 ,   static . option . keyN = static_option_valueN )  define   table   TableName   ( attribute1   Type1 ,   attributeN   TypeN );   Example  The following defines a RDBMS data store pointing to a MySQL database with name  hotel  hosted in  loacalhost:3306  \nhaving a table  RoomTypeTable  with columns  roomNo  of  INTEGER  and  type  of  VARCHAR(255)  mapped to Siddhi data types  int  and  string  respectively.  @ Store ( type = rdbms ,   jdbc . url = jdbc:mysql://localhost:3306/hotel ,   username = siddhi ,   password = 123 ,  \n        jdbc . driver . name = com.mysql.jdbc.Driver )  define   table   RoomTypeTable   (   roomNo   int ,   type   string   );   Supported Store Types  The following is a list of currently supported store types:   RDBMS (MySQL, Oracle, SQL Server, PostgreSQL, DB2, H2)  Solr  MongoDB  HBase  Redis  Cassandra   Operators on Table (and Store)  The following operators can be performed on tables (and stores).", 
            "title": "Store"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#insert", 
            "text": "This allows events to be inserted into tables. This is similar to inserting events into streams.    Warning  If the table is defined with primary keys, and if you insert duplicate data, primary key constrain violations can occur. \nIn such cases use the  update or insert into  operation.    Syntax  from   input   stream   select   attribute   name ,   attribute   name ,   ...  insert   into   table   Similar to streams, you need to use the  current events ,  expired events  or the  all events  keyword between  insert  and  into  keywords in order to insert only the specific output event types. \nFor more information, see  output event type  Example  This query inserts all the events from the  TempStream  stream to the  TempTable  table.  from   TempStream  select   *  insert   into   TempTable ;", 
            "title": "Insert"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#join-table", 
            "text": "This allows a stream to retrieve information from a table in a streaming manner.   Note  Joins can also be performed with  two streams ,  aggregation  or against externally  defined windows .   Syntax  from   input   stream   join   table \n     on   condition  select   ( input   stream | table ). attribute   name ,   ( input   stream | table ). attribute   name ,   ...  insert   into   output   stream    Note  A table can only be joint with a stream. Two tables cannot be joint because there must be at least one active \nentity to trigger the join operation.   Example  This Siddhi App performs a join to retrieve the room type from  RoomTypeTable  table based on the room number, so that it can filter the events related to  server-room s.  define   table   RoomTypeTable   ( roomNo   int ,   type   string );  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  from   TempStream   join   RoomTypeTable \n     on   RoomTypeTable . roomNo   ==   TempStream . roomNo  select   deviceID ,   RoomTypeTable . type   as   roomType ,   type ,   temp \n     having   roomType   ==   server-room  insert   into   ServerRoomTempStream ;   Supported join types    Table join supports following join operations.    Inner join (join)    This is the default behaviour of a join operation.  join  is used as the keyword to join the stream with the table. The output is generated only if there is a matching event in both the stream and the table.    Left outer join    The  left outer join  operation allows you to join a stream on left side with a table on the right side based on a condition.\nHere, it returns all the events of left stream even if there are no matching events in the right table by \nhaving null values for the attributes of the right table.    Right outer join    This is similar to a  left outer join .  right outer join  is used as the keyword to join a stream on right side with a table on the left side based on a condition.\nIt returns all the events of the right stream even if there are no matching events in the left table.", 
            "title": "Join (Table)"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#delete", 
            "text": "To delete selected events that are stored in a table.  Syntax  from   input   stream   select   attribute   name ,   attribute   name ,   ...  delete   table   ( for   output   event   type ) ? \n     on   condition   The  condition  element specifies the basis on which events are selected to be deleted. \nWhen specifying the condition, table attributes should be referred to with the table name.  To execute delete for specific output event types, use the  current events ,  expired events  or the  all events  keyword with  for  as shown\nin the syntax. For more information, see  output event type   Note  Table attributes must be always referred to with the table name as follows:  table name . attibute name   Example  In this example, the script deletes a record in the  RoomTypeTable  table if it has a value for the  roomNo  attribute that matches the value for the  roomNumber  attribute of an event in the  DeleteStream  stream.  define   table   RoomTypeTable   ( roomNo   int ,   type   string );  define   stream   DeleteStream   ( roomNumber   int );  from   DeleteStream  delete   RoomTypeTable \n     on   RoomTypeTable . roomNo   ==   roomNumber ;", 
            "title": "Delete"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#update", 
            "text": "This operator updates selected event attributes stored in a table based on a condition.   Syntax  from   input   stream   select   attribute   name ,   attribute   name ,   ...  update   table   ( for   output   event   type ) ?  \n     set   table . attribute   name   =   ( attribute   name | expression ) ? ,   table . attribute   name   =   ( attribute   name | expression ) ? ,   ... \n     on   condition   The  condition  element specifies the basis on which events are selected to be updated.\nWhen specifying the  condition , table attributes must be referred to with the table name.  You can use the  set  keyword to update selected attributes from the table. Here, for each assignment, the attribute specified in the left must be the table attribute, and the one specified in the right can be a stream/table attribute a mathematical operation, or other. When the  set  clause is not provided, all the attributes in the table are updated.  To execute an update for specific output event types use the  current events ,  expired events  or the  all events  keyword with  for  as shown\nin the syntax. For more information, see  output event type .   Note  Table attributes must be always referred to with the table name as shown below:\n  table name . attibute name .   Example  This Siddhi application updates the room occupancy in the  RoomOccupancyTable  table for each room number based on new arrivals and exits from the  UpdateStream  stream.  define   table   RoomOccupancyTable   ( roomNo   int ,   people   int );  define   stream   UpdateStream   ( roomNumber   int ,   arrival   int ,   exit   int );  from   UpdateStream  select   *  update   RoomOccupancyTable \n     set   RoomOccupancyTable . people   =   RoomOccupancyTable . people   +   arrival   -   exit \n     on   RoomOccupancyTable . roomNo   ==   roomNumber ;", 
            "title": "Update"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#update-or-insert", 
            "text": "This allows you update if the event attributes already exist in the table based on a condition, or \nelse insert the entry as a new attribute.  Syntax  from   input   stream   select   attribute   name ,   attribute   name ,   ...  update   or   insert   into   table   ( for   output   event   type ) ?  \n     set   table . attribute   name   =   expression ,   table . attribute   name   =   expression ,   ... \n     on   condition   The  condition  element specifies the basis on which events are selected for update.\nWhen specifying the  condition , table attributes should be referred to with the table name. \nIf a record that matches the condition does not already exist in the table, the arriving event is inserted into the table.  The  set  clause is only used when an update is performed during the insert/update operation. \nWhen  set  clause is used, the attribute to the left is always a table attribute, and the attribute to the right can be a stream/table attribute, mathematical \noperation or other. The attribute to the left (i.e., the attribute in the event table) is updated with the value of the attribute to the right if the given condition is met. When the  set  clause is not provided, all the attributes in the table are updated.    Note  When the attribute to the right is a table attribute, the operations supported differ based on the database type.   To execute update upon specific output event types use the  current events ,  expired events  or the  all events  keyword with  for  as shown\nin the syntax. To understand more see  output event type .   Note  Table attributes should be always referred to with the table name as  table name . attibute name .   Example  The following query update for events in the  UpdateTable  event table that have room numbers that match the same in the  UpdateStream  stream. When such events are found in the event table, they are updated. When a room number available in the stream is not found in the event table, it is inserted from the stream.  define   table   RoomAssigneeTable   ( roomNo   int ,   type   string ,   assignee   string );  define   stream   RoomAssigneeStream   ( roomNumber   int ,   type   string ,   assignee   string );  from   RoomAssigneeStream  select   roomNumber   as   roomNo ,   type ,   assignee  update   or   insert   into   RoomAssigneeTable \n     set   RoomAssigneeTable . assignee   =   assignee \n     on   RoomAssigneeTable . roomNo   ==   roomNo ;", 
            "title": "Update or Insert"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#in", 
            "text": "This allows the stream to check whether the expected value exists in the table as a part of a conditional operation.  Syntax  from   input   stream [ condition   in   table ]  select   attribute   name ,   attribute   name ,   ...  insert   into   output   stream   The  condition  element specifies the basis on which events are selected to be compared. \nWhen constructing the  condition , the table attribute must be always referred to with the table name as shown below: table . attibute name .  Example  This Siddhi application filters only room numbers that are listed in the  ServerRoomTable  table.  define   table   ServerRoomTable   ( roomNo   int );  define   stream   TempStream   ( deviceID   long ,   roomNo   int ,   temp   double );  from   TempStream [ ServerRoomTable . roomNo   ==   roomNo   in   ServerRoomTable ]  insert   into   ServerRoomTempStream ;", 
            "title": "In"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#incremental-aggregation", 
            "text": "Incremental aggregation allows you to obtain aggregates in an incremental manner for a specified set of time periods.  This not only allows you to calculate aggregations with varied time granularity, but also allows you to access them in an interactive\n manner for reports, dashboards, and for further processing. Its schema is defined via the  aggregation definition .  Incremental aggregation granularity data holders are automatically purged every 15 minutes. When carrying out data purging, the retention period you have specified for each granularity in the incremental aggregation query is taken into account. The retention period defined for a granularity needs to be greater than or equal to its minimum retention period as specified in the table below. If no valid retention period is defined for a granularity, the default retention period (as specified in the table below) is applied.      Granularity  Default retention  Minimum retention      second  120  seconds  120  seconds    minute  24   hours  120  minutes    hour  30   days  25   hours    day  1    year  32   days    month  All  13   month    year  All  none     Purpose  Incremental aggregation allows you to retrieve the aggregate values for different time durations. \nThat is, it allows you to obtain aggregates such as  sum ,  count ,  avg ,  min ,  max ,  count  and  distinctCount \nof stream attributes for durations such as  sec ,  min ,  hour , etc.  This is of considerable importance in many Analytics scenarios because aggregate values are often needed for several time periods. \nFurthermore, this ensures that the aggregations are not lost due to unexpected system failures because aggregates can be stored in different persistence  stores .  Syntax  @ store ( type = store type ,   ...)  @ purge ( enable = true or false , interval = purging   interval , @ retentionPeriod ( granularity   =   retention   period ,   ...)   )  define   aggregation   aggregator   name  from   input   stream  select   attribute   name ,   aggregate   function ( attribute   name )   as   attribute   name ,   ... \n     group   by   attribute   name \n     aggregate   by   timestamp   attribute   every   time   periods   ;   The above syntax includes the following:     Item  Description      @BufferSize  DEPRECIATED FROM V4.2.0 . This identifies the number of expired events to retain in a buffer in order to handle out of order event processing. This is an optional parameter that is applicable only if aggregation is based on external timestamps (because events aggregated based on event arrival time cannot be out of order). Siddhi determines whether an event is expired or not based on the timestamp of the latest event and the most granular duration for which aggregation is calculated.  e.g., If the aggregation is calculated for  sec\u2026year , the most granular duration is seconds. Therefore, if the buffer size is  3  and events arrive during 51st, 52nd, 53rd and 54th seconds, all of the older aggregations (i.e., for 51st, 52nd and 53rd seconds) are kept in the buffer because the latest event arrived during the 54th second.  The default value is  0 .    @IgnoreEventsOlderThanBuffer  DEPRECIATED FROM V4.2.0 .This annotation specifies whether or not to aggregate events older than the  buffer. If this parameter is set to  false  (which is default), any event  older than the buffer is aggregated with the oldest event in buffer. If  this parameter is set to  true , any event older than the buffer is dropped. This is an optional annotation.    @store  This annotation is used to refer to the data store where the calculated  aggregate results are stored. This annotation is optional. When  no annotation is provided, the data is stored in the  in-memory  store.    @purge  This annotation is used to configure purging in aggregation granularities.  If this annotation is not provided, the default purging mentioned above is applied.  If you want to disable automatic data purging, you can use this annotation as follows: '@purge(enable=false) /You should disable data purging if the aggregation query in included in the Siddhi application for read-only purposes.    @retentionPeriod  This annotation is used to specify the length of time the data needs to be retained when carrying out data purging.  If this annotation is not provided, the default retention period is applied.    aggregator name  This specifies a unique name for the aggregation so that it can be referred  when accessing aggregate results.    input stream  The stream that feeds the aggregation.  Note! this stream should be  already defined.    group by  attribute name  The  group by  clause is optional. If it is included in a Siddhi application, aggregate values   are calculated per each  group by  attribute. If it is not used, all the  events are aggregated together.    by  timestamp attribute  This clause is optional. This defines the attribute that should be used as  the timestamp. If this clause is not used, the event time is used by default.  The timestamp could be given as either a  string  or a  long  value. If it is a  long  value,  the unix timestamp in milliseconds is expected (e.g.  1496289950000 ). If it is  a  string  value, the supported formats are  yyyy - MM - dd   HH : mm : ss   (if time is in GMT) and   yyyy - MM - dd   HH : mm : ss   Z  (if time is  not in GMT), here the ISO 8601 UTC offset must be provided for  Z  . (e.g.,  +05:30 ,  -11:00 ).    time periods  Time periods can be specified as a range where the minimum and the maximum value are separated by three dots, or as comma-separated values.   e.g., A range can be specified as sec...year where aggregation is done per second, minute, hour, day, month and year. Comma-separated values can be specified as min, hour.   Skipping time durations (e.g., min, day where the hour duration is skipped) when specifying comma-separated values is supported only from v4.1.1 onwards      Note  From V4.2.0 onwards, aggregation is carried out at calendar start times for each granularity with the GMT timezone    Note  From V4.2.6 onwards, the same aggregation can be defined in multiple Siddhi apps for joining, however,  only one siddhi app should carry out the processing  (i.e. the aggregation input stream should only feed events to one aggregation definition).    Example  This Siddhi Application defines an aggregation named  TradeAggregation  to calculate the average and sum for the  price  attribute of events arriving at the  TradeStream  stream. These aggregates are calculated per every time granularity in the second-year range.  define   stream   TradeStream   ( symbol   string ,   price   double ,   volume   long ,   timestamp   long );  @ purge ( enable = true ,   interval = 10 sec , @ retentionPeriod ( sec = 120 sec , min = 24 hours , hours = 30 days , days = 1 year , months = all , years = all ))  define   aggregation   TradeAggregation \n   from   TradeStream \n   select   symbol ,   avg ( price )   as   avgPrice ,   sum ( price )   as   total \n     group   by   symbol \n     aggregate   by   timestamp   every   sec   ...   year ;", 
            "title": "Incremental Aggregation"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#distributed-aggregation", 
            "text": "Note  Distributed Aggregation is only supported after v4.3.0   Distributed Aggregation allows you to partially process aggregations in different shards. This allows Siddhi\napp in one shard to be responsible only for processing a part of the aggregation.\nHowever for this, all aggregations must be based on a common physical database(@store).  Syntax  @ store ( type = store type ,   ...)  @ PartitionById  define   aggregation   aggregator   name  from   input   stream  select   attribute   name ,   aggregate   function ( attribute   name )   as   attribute   name ,   ... \n     group   by   attribute   name \n     aggregate   by   timestamp   attribute   every   time   periods   ;   Following table includes the  annotation  to be used to enable distributed aggregation,      Item  Description      @PartitionById  If the annotation is given, then the distributed aggregation is enabled. Further this can be disabled by using  enable  element,  @PartitionById(enable='false') .     Further, following system properties are also available,     System Property  Description  Possible Values  Optional  Default Value      shardId  The id of the shard one of the distributed aggregation is running in. This should be unique to a single shard  Any string  No     partitionById  This allows user to enable/disable distributed aggregation for all aggregations running in one siddhi manager .(Available from v4.3.3)  true/false  Yesio  false      Note  ShardIds should not be changed after the first configuration in order to keep data consistency.", 
            "title": "Distributed Aggregation"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#join-aggregation", 
            "text": "This allows a stream to retrieve calculated aggregate values from the aggregation.    Note  A join can also be performed with  two streams , with a  table  and a stream, or with a stream against externally  defined windows .   Syntax  A join with aggregation is similer to the join with  table , but with additional  within  and  per  clauses.   from   input   stream   join   aggrigation  \n   on   join   condition  \n   within   time   range  \n   per   time   granularity  select   attribute   name ,   attribute   name ,   ...  insert   into   output   stream ;   Apart from constructs of  table join  this includes the following. Please note that the 'on' condition is optional :     Item  Description      within   time range  This allows you to specify the time interval for which the aggregate values need to be retrieved. This can be specified by providing the start and end time separated by a comma as  string  or  long  values, or by using the wildcard  string  specifying the data range. For details refer examples.    per  time granularity  This specifies the time granularity by which the aggregate values must be grouped and returned. e.g., If you specify  days , the retrieved aggregate values are grouped for each day within the selected time interval.    AGG_TIMESTAMP  This specifies the start time of the aggregations and can be used in the select clause.     within  and  per  clauses also accept attribute values from the stream.   Note  The timestamp of the aggregations can be accessed through the  AGG_TIMESTAMP  attribute.   Example  Following aggregation definition will be used for the examples.   define   stream   TradeStream   ( symbol   string ,   price   double ,   volume   long ,   timestamp   long );  define   aggregation   TradeAggregation \n   from   TradeStream \n   select   AGG_TIMESTAMP ,   symbol ,   avg ( price )   as   avgPrice ,   sum ( price )   as   total \n     group   by   symbol \n     aggregate   by   timestamp   every   sec   ...   year ;   This query retrieves daily aggregations within the time range  \"2014-02-15 00:00:00 +05:30\", \"2014-03-16 00:00:00 +05:30\"  (Please note that +05:30 can be omitted if timezone is GMT)  define   stream   StockStream   ( symbol   string ,   value   int );  from   StockStream   as   S   join   TradeAggregation   as   T \n   on   S . symbol   ==   T . symbol  \n   within   2014-02-15 00:00:00 +05:30 ,   2014-03-16 00:00:00 +05:30  \n   per   days   select   S . symbol ,   T . total ,   T . avgPrice   insert   into   AggregateStockStream ;   This query retrieves hourly aggregations within the day  2014-02-15 .  define   stream   StockStream   ( symbol   string ,   value   int );  from   StockStream   as   S   join   TradeAggregation   as   T \n   on   S . symbol   ==   T . symbol  \n   within   2014-02-15 **:**:** +05:30 \n   per   hours   select   S . symbol ,   T . total ,   T . avgPrice   insert   into   AggregateStockStream ;   This query retrieves all aggregations per  perValue  stream attribute within the time period \nbetween timestamps  1496200000000  and  1596434876000 .  define   stream   StockStream   ( symbol   string ,   value   int ,   perValue   string );  from   StockStream   as   S   join   TradeAggregation   as   T \n   on   S . symbol   ==   T . symbol  \n   within   1496200000000 L ,   1596434876000 L \n   per   S . perValue  select   S . symbol ,   T . total ,   T . avgPrice   insert   into   AggregateStockStream ;   Supported join types    Aggregation join supports following join operations.    Inner join (join)    This is the default behaviour of a join operation.  join  is used as the keyword to join the stream with the aggregation. The output is generated only if there is a matching event in the stream and the aggregation.    Left outer join    The  left outer join  operation allows you to join a stream on left side with a aggregation on the right side based on a condition.\nHere, it returns all the events of left stream even if there are no matching events in the right aggregation by \nhaving null values for the attributes of the right aggregation.    Right outer join    This is similar to a  left outer join .  right outer join  is used as the keyword to join a stream on right side with a aggregation on the left side based on a condition.\nIt returns all the events of the right stream even if there are no matching events in the left aggregation.", 
            "title": "Join (Aggregation)"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#defined-window", 
            "text": "A defined window is a window that can be shared across multiple queries. \nEvents can be inserted to a defined window from one or more queries and it can produce output events based on the defined window type.  Syntax  The syntax for a defined window is as follows:  define   window   window   name   ( attribute   name   attribute   type ,   attribute   name   attribute   type ,   ...   )   window   type ( parameter ,   parameter ,   \u2026 )   output   event   type ;   The following parameters are configured in a table definition:     Parameter  Description      window name  The name of the window defined. ( PascalCase  is used for window names as a convention.)    attribute name  The schema of the window is defined by its attributes with uniquely identifiable attribute names ( camelCase  is used for attribute names as a convention.)    attribute type  The type of each attribute defined in the schema.   This can be  STRING ,  INT ,  LONG ,  DOUBLE ,  FLOAT ,  BOOL  or  OBJECT .    window type ( parameter , ...)  The window type associated with the window and its parameters.    output  output event type  This is optional. Keywords such as  current events ,  expired events  and  all events  (the default) can be used to specify when the window output should be exposed. For more information, see  output event type .     Examples    Returning all output when events arrive and when events expire from the window.  In this query, the output event type is not specified. Therefore, it returns both current and expired events as the output.       define   window   SensorWindow   ( name   string ,   value   float ,   roomNo   int ,   deviceID   string )   timeBatch ( 1   second );     Returning an output only when events expire from the window.  In this query, the output event type of the window is  expired events . Therefore, it only returns the events that have expired from the window as the output.       define   window   SensorWindow   ( name   string ,   value   float ,   roomNo   int ,   deviceID   string )   timeBatch ( 1   second )   output   expired   events ;   Operators on Defined Windows  The following operators can be performed on defined windows.", 
            "title": "(Defined) Window"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#insert_1", 
            "text": "This allows events to be inserted into windows. This is similar to inserting events into streams.   Syntax  from   input   stream   select   attribute   name ,   attribute   name ,   ...  insert   into   window   To insert only events of a specific output event type, add the  current events ,  expired events  or the  all events  keyword between  insert  and  into  keywords (similar to how it is done for streams).  For more information, see  output event type .  Example  This query inserts all events from the  TempStream  stream to the  OneMinTempWindow  window.  define   stream   TempStream ( tempId   string ,   temp   double );  define   window   OneMinTempWindow ( tempId   string ,   temp   double )   time ( 1   min );  from   TempStream  select   *  insert   into   OneMinTempWindow ;", 
            "title": "Insert"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#join-window", 
            "text": "To allow a stream to retrieve information from a window based on a condition.   Note  A join can also be performed with  two streams ,  aggregation  or with tables  tables .   Syntax  from   input   stream   join   window \n     on   condition  select   ( input   stream | window ). attribute   name ,   ( input   stream | window ). attribute   name ,   ...  insert   into   output   stream   Example  This Siddhi Application performs a join count the number of temperature events having more then 40 degrees \n within the last 2 minutes.   define   window   TwoMinTempWindow   ( roomNo   int ,   temp   double )   time ( 2   min );  define   stream   CheckStream   ( requestId   string );  from   CheckStream   as   C   join   TwoMinTempWindow   as   T \n     on   T . temp     40  select   requestId ,   count ( T . temp )   as   count  insert   into   HighTempCountStream ;   Supported join types    Window join supports following operations of a join clause.    Inner join (join)    This is the default behaviour of a join operation.  join  is used as the keyword to join two windows or a stream with a window. The output is generated only if there is a matching event in both stream/window.    Left outer join    The  left outer join  operation allows you to join two windows or a stream with a window to be merged based on a condition. \nHere, it returns all the events of left stream/window even if there are no matching events in the right stream/window by \nhaving null values for the attributes of the right stream/window.    Right outer join    This is similar to a left outer join.  Right outer join  is used as the keyword to join two windows or a stream with a window.\nIt returns all the events of the right stream/window even if there are no matching events in the left stream/window.     Full outer join    The full outer join combines the results of  left outer join  and  right outer join .  full outer join  is used as the keyword to join two windows or a stream with a window.\nHere, output event are generated for each incoming event even if there are no matching events in the other stream/window.", 
            "title": "Join (Window)"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#from", 
            "text": "A window can be an input to a query, similar to streams.   Note !!!\n     When window is used as an input to a query, another window cannot be applied on top of this.  Syntax  from   window   select   attribute   name ,   attribute   name ,   ...  insert   into   output   stream   Example \nThis Siddhi Application calculates the maximum temperature within the last 5 minutes.  define   window   FiveMinTempWindow   ( roomNo   int ,   temp   double )   time ( 5   min );  from   FiveMinTempWindow  select   max ( temp )   as   maxValue ,   roomNo  insert   into   MaxSensorReadingStream ;", 
            "title": "From"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#trigger", 
            "text": "Triggers allow events to be periodically generated.  Trigger definition  can be used to define a trigger. \nA trigger also works like a stream with a predefined schema.  Purpose  For some use cases the system should be able to periodically generate events based on a specified time interval to perform \nsome periodic executions.   A trigger can be performed for a  'start'  operation, for a given  time interval , or for a given  ' cron expression ' .  Syntax  The syntax for a trigger definition is as follows.  define   trigger   trigger   name   at   ( start |   every   time   interval |   cron expression );   Similar to streams, triggers can be used as inputs. They adhere to the following stream definition and produce the  triggered_time  attribute of the  long  type.  define   stream   trigger   name   ( triggered_time   long );   The following types of triggeres are currently supported:     Trigger type  Description      'start'  An event is triggered when Siddhi is started.    every  time interval  An event is triggered periodically at the given time interval.    ' cron expression '  An event is triggered periodically based on the given cron expression. For configuration details, see  quartz-scheduler .     Examples    Triggering events regularly at specific time intervals  The following query triggers events every 5 minutes.          define   trigger   FiveMinTriggerStream   at   every   5   min ;     Triggering events at a specific time on specified days  The following query triggers an event at 10.15 AM on every weekdays.          define   trigger   FiveMinTriggerStream   at   0 15 10 ? * MON-FRI ;", 
            "title": "Trigger"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#script", 
            "text": "Scripts allow you to write functions in other programming languages and execute them within Siddhi queries. \nFunctions defined via scripts can be accessed in queries similar to any other inbuilt function.  Function definitions  can be used to define these scripts.  Function parameters are passed into the function logic as  Object[]  and with the name  data  .   Purpose  Scripts allow you to define a function operation that is not provided in Siddhi core or its extension. It is not required to write an extension to define the function logic.  Syntax  The syntax for a Script definition is as follows.  define   function   function   name [ language   name ]   return   return   type   { \n     operation   of   the   function  } ;   The following parameters are configured when defining a script.     Parameter  Description      function name  The name of the function ( camelCase  is used for the function name) as a convention.    language name  The name of the programming language used to define the script, such as  javascript ,  r  and  scala .    return type  The attribute type of the function\u2019s return. This can be  int ,  long ,  float ,  double ,  string ,  bool  or  object . Here the function implementer should be responsible for returning the output attribute on the defined return type for proper functionality.    operation of the function  Here, the execution logic of the function is added. This logic should be written in the language specified under the  language name , and it should return the output in the data type specified via the  return type  parameter.     Examples  This query performs concatenation using JavaScript, and returns the output as a string.  define   function   concatFn [ javascript ]   return   string   { \n     var   str1   =   data [ 0 ]; \n     var   str2   =   data [ 1 ]; \n     var   str3   =   data [ 2 ]; \n     var   responce   =   str1   +   str2   +   str3 ; \n     return   responce ;  } ;  define   stream   TempStream ( deviceID   long ,   roomNo   int ,   temp   double );  from   TempStream  select   concatFn ( roomNo , - , deviceID )   as   id ,   temp   insert   into   DeviceTempStream ;", 
            "title": "Script"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#store-query", 
            "text": "Siddhi store queries are a set of on-demand queries that can be used to perform operations on Siddhi tables, windows, and aggregators.  Purpose  Store queries allow you to execute the following operations on Siddhi tables, windows, and aggregators without the intervention of streams.  Queries supported for tables:   SELECT  INSERT  DELETE  UPDATE  UPDATE OR INSERT   Queries supported for windows and aggregators:   SELECT   This is be done by submitting the store query to the Siddhi application runtime using its  query()  method.  In order to execute store queries, the Siddhi application of the Siddhi application runtime you are using, should have\n a store defined, which contains the table that needs to be queried.  Example  If you need to query the table named  RoomTypeTable  the it should have been defined in the Siddhi application.  In order to execute a store query on  RoomTypeTable , you need to submit the store query using  query()  \nmethod of  SiddhiAppRuntime  instance as below.  siddhiAppRuntime . query ( store   query );", 
            "title": "Store Query"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#tablewindow-select", 
            "text": "The  SELECT  store query retrieves records from the specified table or window, based on the given condition.  Syntax  from   table / window  on   condition ?  select   attribute   name ,   attribute   name ,   ...  group   by ?   having ?   order   by ?   limit ?   Example  This query retrieves room numbers and types of the rooms starting from room no 10.  from   roomTypeTable  on   roomNo   =   10 ;  select   roomNo ,   type", 
            "title": "(Table/Window) Select"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#aggregation-select", 
            "text": "The  SELECT  store query retrieves records from the specified aggregation, based on the given condition, time range, \nand granularity.  Syntax  from   aggregation  on   condition ?  within   time   range  per   time   granularity  select   attribute   name ,   attribute   name ,   ...  group   by ?   having ?   order   by ?   limit ?   Example  Following aggregation definition will be used for the examples.   define   stream   TradeStream   ( symbol   string ,   price   double ,   volume   long ,   timestamp   long );  define   aggregation   TradeAggregation \n   from   TradeStream \n   select   symbol ,   avg ( price )   as   avgPrice ,   sum ( price )   as   total \n     group   by   symbol \n     aggregate   by   timestamp   every   sec   ...   year ;   This query retrieves daily aggregations within the time range  \"2014-02-15 00:00:00 +05:30\", \"2014-03-16 00:00:00 +05:30\"  (Please note that +05:30 can be omitted if timezone is GMT)  from   TradeAggregation \n   within   2014-02-15 00:00:00 +05:30 ,   2014-03-16 00:00:00 +05:30  \n   per   days   select   symbol ,   total ,   avgPrice   ;   This query retrieves hourly aggregations of \"FB\" symbol within the day  2014-02-15 .  from   TradeAggregation \n   on   symbol   ==   FB  \n   within   2014-02-15 **:**:** +05:30 \n   per   hours   select   symbol ,   total ,   avgPrice ;", 
            "title": "(Aggregation) Select"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#insert_2", 
            "text": "This allows you to insert a new record to the table with the attribute values you define in the  select  section.  Syntax  select   attribute   name ,   attribute   name ,   ...  insert   into   table ;   Example  This store query inserts a new record to the table  RoomOccupancyTable , with the specified attribute values.  select   10   as   roomNo ,   2   as   people  insert   into   RoomOccupancyTable", 
            "title": "Insert"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#delete_1", 
            "text": "The  DELETE  store query deletes selected records from a specified table.  Syntax  select ?    delete   table    on   conditional   expresssion   The  condition  element specifies the basis on which records are selected to be deleted.   Note  Table attributes must always be referred to with the table name as shown below:  \n  table name . attibute name .   Example  In this example, query deletes a record in the table named  RoomTypeTable  if it has value for the  roomNo  \nattribute that matches the value for the  roomNumber  attribute of the selection which has 10 as the actual value.  select   10   as   roomNumber  delete   RoomTypeTable  on   RoomTypeTable . roomNo   ==   roomNumber ;   delete   RoomTypeTable  on   RoomTypeTable . roomNo   ==   10 ;", 
            "title": "Delete"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#update_1", 
            "text": "The  UPDATE  store query updates selected attributes stored in a specific table, based on a given condition.  Syntax  select   attribute   name ,   attribute   name ,   ... ?  update   table \n     set   table . attribute   name   =   ( attribute   name | expression ) ? ,   table . attribute   name   =   ( attribute   name | expression ) ? ,   ... \n     on   condition   The  condition  element specifies the basis on which records are selected to be updated.\nWhen specifying the  condition , table attributes must be referred to with the table name.  You can use the  set  keyword to update selected attributes from the table. Here, for each assignment, the attribute specified in the left must be the table attribute, and the one specified in the right can be a stream/table attribute a mathematical operation, or other. When the  set  clause is not provided, all the attributes in the table are updated.   Note  Table attributes must always be referred to with the table name as shown below:  \n  table name . attibute name .   Example  The following query updates the room occupancy by increasing the value of  people  by 1, in the  RoomOccupancyTable  \ntable for each room number greater than 10.  select   10   as   roomNumber ,   1   as   arrival  update   RoomTypeTable \n     set   RoomTypeTable . people   =   RoomTypeTable . people   +   arrival \n     on   RoomTypeTable . roomNo   ==   roomNumber ;   update   RoomTypeTable \n     set   RoomTypeTable . people   =   RoomTypeTable . people   +   1 \n     on   RoomTypeTable . roomNo   ==   10 ;", 
            "title": "Update"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#update-or-insert_1", 
            "text": "This allows you to update selected attributes if a record that meets the given conditions already exists in the specified  table. \nIf a matching record does not exist, the entry is inserted as a new record.  Syntax  select   attribute   name ,   attribute   name ,   ...  update   or   insert   into   table \n     set   table . attribute   name   =   expression ,   table . attribute   name   =   expression ,   ... \n     on   condition   The  condition  element specifies the basis on which records are selected for update.\nWhen specifying the  condition , table attributes should be referred to with the table name.\nIf a record that matches the condition does not already exist in the table, the arriving event is inserted into the table.  The  set  clause is only used when an update is performed during the insert/update operation.\nWhen  set  clause is used, the attribute to the left is always a table attribute, and the attribute to the right can be a stream/table attribute, mathematical\noperation or other. The attribute to the left (i.e., the attribute in the event table) is updated with the value of the attribute to the right if the given condition is met. When the  set  clause is not provided, all the attributes in the table are updated.   Note  Table attributes must always be referred to with the table name as shown below:  \n  table name . attibute name .   Example  The following query tries to update the records in the  RoomAssigneeTable  table that have room numbers that match the\n same in the selection. If such records are not found, it inserts a new record based on the values provided in the selection.   select   10   as   roomNo ,   single   as   type ,   abc   as   assignee  update   or   insert   into   RoomAssigneeTable \n     set   RoomAssigneeTable . assignee   =   assignee \n     on   RoomAssigneeTable . roomNo   ==   roomNo ;", 
            "title": "Update or Insert"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#extensions", 
            "text": "Siddhi supports an extension architecture to enhance its functionality by incorporating other libraries in a seamless manner.   Purpose  Extensions are supported because, Siddhi core cannot have all the functionality that's needed for all the use cases, mostly use cases require \ndifferent type of functionality, and for some cases there can be gaps and you need to write the functionality by yourself.  All extensions have a namespace. This is used to identify the relevant extensions together, and to let you specifically call the extension.  Syntax  Extensions follow the following syntax;  namespace : function   name ( parameter ,   parameter ,   ...   )   The following parameters are configured when referring a script function.     Parameter  Description      namespace  Allows Siddhi to identify the extension without conflict    function name  The name of the function referred.    parameter  The function input parameter for function execution.      Extension Types  Siddhi supports following extension types:    Function  For each event, it consumes zero or more parameters as input parameters and returns a single attribute. This can be used to manipulate existing event attributes to generate new attributes like any Function operation.  This is implemented by extending  io.siddhi.core.executor.function.FunctionExecutor .  Example :   math:sin(x)    Here, the  sin  function of  math  extension returns the sin value for the  x  parameter.    Aggregate Function  For each event, it consumes zero or more parameters as input parameters and returns a single attribute with aggregated results. This can be used in conjunction with a window in order to find the aggregated results based on the given window like any Aggregate Function operation.   This is implemented by extending  io.siddhi.core.query.selector.attribute.aggregator.AttributeAggregatorExecutor .  Example :   custom:std(x)    Here, the  std  aggregate function of  custom  extension returns the standard deviation of the  x  value based on its assigned window query.     Window    This allows events to be  collected, generated, dropped and expired anytime   without altering  the event format based on the given input parameters, similar to any other Window operator.   This is implemented by extending  io.siddhi.core.query.processor.stream.window.WindowProcessor .  Example :   custom:unique(key)    Here, the  unique  window of the  custom  extension retains one event for each unique  key  parameter.    Stream Function  This allows events to be   generated or dropped only during event arrival  and  altered  by adding one or more attributes to it.   This is implemented by extending   io.siddhi.core.query.processor.stream.function.StreamFunctionProcessor .  Example :    custom:pol2cart(theta,rho)    Here, the  pol2cart  function of the  custom  extension returns all the events by calculating the cartesian coordinates  x     y  and adding them as new attributes to the events.    Stream Processor  This allows events to be  collected, generated, dropped and expired anytime  by  altering  the event format by adding one or more attributes to it based on the given input parameters.   Implemented by extending  io.siddhi.core.query.processor.stream.StreamProcessor .  Example :    custom:perMinResults( parameter ,  parameter , ...)    Here, the  perMinResults  function of the  custom  extension returns all events by adding one or more attributes to the events based on the conversion logic. Altered events are output every minute regardless of event arrivals.    Sink  Sinks provide a way to  publish Siddhi events to external systems  in the preferred data format. Sinks publish events from the streams via multiple transports to external endpoints in various data formats.  Implemented by extending  io.siddhi.core.stream.output.sink.Sink .  Example :   @sink(type='sink_type', static_option_key1='static_option_value1')  To configure a stream to publish events via a sink, add the sink configuration to a stream definition by adding the @sink annotation with the required parameter values. The sink syntax is as above    Source  Source allows Siddhi to  consume events from external systems , and map the events to adhere to the associated stream. Sources receive events via multiple transports and in various data formats, and direct them into streams for processing.  Implemented by extending  io.siddhi.core.stream.input.source.Source .  Example :   @source(type='source_type', static.option.key1='static_option_value1')  To configure a stream that consumes events via a source, add the source configuration to a stream definition by adding the @source annotation with the required parameter values. The source syntax is as above    Store  You can use Store extension type to work with data/events  stored in various data stores through the table abstraction . You can find more information about these extension types under the heading 'Extension types' in this document.   Implemented by extending  io.siddhi.core.table.record.AbstractRecordTable .    Script  Scripts allow you to  define a function  operation that is not provided in Siddhi core or its extension. It is not required to write an extension to define the function logic. Scripts allow you to write functions in other programming languages and execute them within Siddhi queries. Functions defined via scripts can be accessed in queries similar to any other inbuilt function.  Implemented by extending  io.siddhi.core.function.Script .    Source Mapper  Each  @source  configuration has a mapping denoted by the  @map  annotation that  converts the incoming messages format to Siddhi events .The type parameter of the @map defines the map type to be used to map the data. The other parameters to be configured depends on the mapper selected. Some of these parameters are optional.   Implemented by extending  io.siddhi.core.stream.output.sink.SourceMapper .  Example :  @map(type='map_type', static_option_key1='static_option_value1')    Sink Mapper  Each  @sink  configuration has a mapping denoted by the  @map  annotation that  converts the outgoing Siddhi events to configured messages format .The type parameter of the @map defines the map type to be used to map the data. The other parameters to be configured depends on the mapper selected. Some of these parameters are optional.   Implemented by extending  io.siddhi.core.stream.output.sink.SinkMapper .  Example :  @map(type='map_type', static_option_key1='static_option_value1')    Example  A window extension created with namespace  foo  and function name  unique  can be referred as follows:  from   StockExchangeStream [ price   =   20 ] # window . foo : unique ( symbol )  select   symbol ,   price  insert   into   StockQuote   Available Extensions  Siddhi currently has several pre written extensions that are available  here  We value your contribution on improving Siddhi and its extensions further.", 
            "title": "Extensions"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#writing-custom-extensions", 
            "text": "Custom extensions can be written in order to cater use case specific logic that are not available in Siddhi out of the box or as an existing extension.  There are five types of Siddhi extensions that you can write to cater your specific use cases. These \nextension types and the related maven archetypes are given below. You can use these archetypes to generate Maven projects for each \nextension type.   Follow the procedure for the required archetype, based on your project:    Note  When using the generated archetype please make sure you uncomment @Extension annotation and complete the\nannotation with proper values. This annotation will be used to identify and document the extension, hence your\nextension will not work without @Extension annotation.   siddhi-execution  Siddhi-execution provides following extension types:   Function  Aggregate Function  Stream Function  Stream Processor  Window   You can use one or more from above mentioned extension types and implement according to your requirement.   For more information about these extension types, see  Extension Types .  To install and implement the siddhi-io extension archetype, follow the procedure below:    Issue the following command from your CLI.          mvn archetype:generate\n            -DarchetypeGroupId=io.siddhi.extension.archetype\n            -DarchetypeArtifactId=siddhi-archetype-execution\n            -DgroupId=io.extension.siddhi.execution\n            -Dversion=1.0.0-SNAPSHOT    Enter the required execution name in the message that pops up as shown in the example below.      Define value for property  executionType : ML    To confirm that all property values are correct, type  Y  in the console. If not, press  N .    siddhi-io  Siddhi-io provides following extension types:   Sink  Source   You can use one or more from above mentioned extension types and implement according to your requirement. siddhi-io is generally used to work with IO operations as follows:\n * The Source extension type gets inputs to your Siddhi application.\n * The Sink extension publishes outputs from your Siddhi application.   For more information about these extension types, see  Extension Types .  To implement the siddhi-io extension archetype, follow the procedure below:    Issue the following command from your CLI.         mvn archetype:generate\n           -DarchetypeGroupId=io.siddhi.extension.archetype\n           -DarchetypeArtifactId=siddhi-archetype-io\n           -DgroupId=io.extension.siddhi.io\n           -Dversion=1.0.0-SNAPSHOT    Enter the required execution name (the transport type in this scenario) in the message that pops up as shown in the example below.   Define value for property  typeOf_IO : http    To confirm that all property values are correct, type  Y  in the console. If not, press  N .    siddhi-map  Siddhi-map provides following extension types,   Sink Mapper  Source Mapper   You can use one or more from above mentioned extension types and implement according to your requirement as follows.   The Source Mapper maps events to a predefined data format (such as XML, JSON, binary, etc), and publishes them to external endpoints (such as E-mail, TCP, Kafka, HTTP, etc).  The Sink Mapper also maps events to a predefined data format, but it does it at the time of publishing events from a Siddhi application.   For more information about these extension types, see  Extension Types .  To implement the siddhi-map extension archetype, follow the procedure below:    Issue the following command from your CLI.                          mvn archetype:generate\n            -DarchetypeGroupId=io.siddhi.extension.archetype\n            -DarchetypeArtifactId=siddhi-archetype-map\n            -DgroupId=io.extension.siddhi.map\n            -Dversion=1.0.0-SNAPSHOT    Enter the required execution name (the map type in this scenario) in the message that pops up as shown in the example below.      Define value for property  mapType :CSV    To confirm that all property values are correct, type  Y  in the console. If not, press  N .    siddhi-script  Siddhi-script provides the  Script  extension type.  The script extension type allows you to write functions in other programming languages and execute them within Siddhi queries. Functions defined via scripts can be accessed in queries similar to any other inbuilt function.   For more information about these extension types, see  Extension Types .  To implement the siddhi-script extension archetype, follow the procedure below:    Issue the following command from your CLI.                            mvn archetype:generate\n           -DarchetypeGroupId=io.siddhi.extension.archetype\n           -DarchetypeArtifactId=siddhi-archetype-script\n           -DgroupId=io.extension.siddhi.script\n           -Dversion=1.0.0-SNAPSHOT    Enter the required execution name in the message that pops up as shown in the example below.   Define value for property  typeOfScript :    To confirm that all property values are correct, type  Y  in the console. If not, press  N .    siddhi-store  Siddhi-store provides the  Store  extension type.  The Store extension type allows you to work with data/events stored in various data stores through the table abstraction.   For more information about these extension types, see  Extension Types .  To implement the siddhi-store extension archetype, follow the procedure below:    Issue the following command from your CLI.                               mvn archetype:generate\n          -DarchetypeGroupId=io.siddhi.extension.archetype\n          -DarchetypeArtifactId=siddhi-archetype-store\n          -DgroupId=io.extension.siddhi.store\n          -Dversion=1.0.0-SNAPSHOT    Enter the required execution name in the message that pops up as shown in the example below.    Define value for property  storeType : RDBMS    To confirm that all property values are correct, type  Y  in the console. If not, press  N .", 
            "title": "Writing Custom Extensions"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#configuring-and-monitoring-siddhi-applications", 
            "text": "", 
            "title": "Configuring and Monitoring Siddhi Applications"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#threading-and-asynchronous", 
            "text": "When  @Async  annotation is added to the Streams it enable the Streams to introduce asynchronous and multi-threading \nbehaviour.   @ Async ( buffer . size = 256 ,   workers = 2 ,   batch . size . max = 5 )  define   stream   stream   name   ( attribute   name   attribute   type ,   attribute   name   attribute   type ,   ...   );   The following elements are configured with this annotation.     Annotation  Description  Default Value      buffer.size  The size of the event buffer that will be used to handover the execution to other threads.  -    workers  Number of worker threads that will be be used to process the buffered events.  1    batch.size.max  The maximum number of events that will be processed together by a worker thread at a given time.  buffer.size", 
            "title": "Threading and Asynchronous"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#fault-streams", 
            "text": "When the  @OnError  annotation is added to a stream definition, it handles failover scenarios that occur during runtime gracefully.  @ OnError ( action = on_error_action )  define   stream   stream   name   ( attribute   name   attribute   type ,   attribute   name   attribute   type ,   ...   );   The action parameter of the  @OnError  annotation defines the action to be executed during failure scenarios.   The following action types can be specified via the  @OnError  annotation when defining a stream. If this annotation is not added,  LOG  is the action type by default.   LOG  : Logs the event with an error, and then drops the event.  STREAM : A fault stream is automatically created for the base stream. The definition of the fault stream includes all the attributes of the base stream as well as an additional attribute named  _error .\nThe events are inserted into the fault stream during a failure. The error identified is captured as the value for the  _error  attribute.   e.g., the following is a Siddhi application that includes the  @OnError  annotation to handle failures during runtime.  @ OnError ( name = STREAM )  define   stream   StreamA   ( symbol   string ,   volume   long );  from   StreamA [ custom : fault ()     volume ]   insert   into   StreamB ;  from   ! StreamA # log ( Error Occured )  select   symbol ,   volume   long ,   _error  insert   into   tempStream ;   !StreamA , fault stream is automatically created when you add the  @OnError  annotation with the following attributes.  symbol   string ,   volume   long ,   _error   object   If you include the  on.error  parameter in the sink configuration, failures are handled by Siddhi at the time the events are published from the  Sink .  @ sink ( type = sink_type ,   on . error = on.error.action )  define   stream   stream   name   ( attribute   name   attribute   type ,   attribute   name   attribute   type ,   ...   );   The action types that can be specified via the  on.error  parameter when configuring a sink are as follows. If this parameter is not included in the sink configuration,  LOG  is the action type by default.   LOG  : Logs the event with the error, and then drops the event.  WAIT  : The thread waits in the  back-off and re-trying  state, and reconnects once the connection is re-established.  STREAM : Corresponding fault stream is populated with the failed event and the error while publishing.", 
            "title": "Fault Streams"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#statistics", 
            "text": "Use  @app:statistics  app level annotation to evaluate the performance of an application, you can enable the statistics of a Siddhi application to be published. This is done via the  @app:statistics  annotation that can be added to a Siddhi application as shown in the following example.  @ app : statistics ( reporter   =   console )   The following elements are configured with this annotation.     Annotation  Description  Default Value      reporter  The interface in which statistics for the Siddhi application are published. Possible values are as follows:   console   jmx  console    interval  The time interval (in seconds) at  which the statistics for the Siddhi application are reported.  60    include  If this parameter is added, only the types of metrics you specify are included in the reporting. The required metric types can be specified as a comma-separated list. It is also possible to use wild cards  All ( . )     The metrics are reported in the following format. io.siddhi.SiddhiApps. SiddhiAppName .Siddhi. Component Type . Component Name .  Metrics name  The following table lists the types of metrics supported for different Siddhi application component types.     Component Type  Metrics Type      Stream  Throughput The size of the buffer if parallel processing is enabled via the @async annotation.    Trigger  Throughput (Trigger and Stream)    Source  Throughput    Sink  Throughput    Mapper  Latency Input/output throughput    Table  Memory Throughput (For all operations) Throughput (For all operations)    Query  Memory Latency    Window  Throughput (For all operations) Latency (For all operation)    Partition  Throughput (For all operations) Latency (For all operation)     e.g., the following is a Siddhi application that includes the  @app  annotation to report performance statistics.  @ App : name ( TestMetrics )  @ App : Statistics ( reporter   =   console )  define   stream   TestStream   ( message   string );  @ info ( name = logQuery )  from   TestSream # log ( Message: )  insert   into   TempSream ;   Statistics are reported for this Siddhi application as shown in the extract below.  \n   Click to view the extract \n11/26/17 8:01:20 PM ============================================================  -- Gauges ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Queries.logQuery.memory\n              value = 5760\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TestStream.size\n              value = 0  -- Meters ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Sources.TestStream.http.throughput\n              count = 0\n          mean rate = 0.00 events/second\n      1-minute rate = 0.00 events/second\n      5-minute rate = 0.00 events/second\n     15-minute rate = 0.00 events/second\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TempSream.throughput\n              count = 2\n          mean rate = 0.04 events/second\n      1-minute rate = 0.03 events/second\n      5-minute rate = 0.01 events/second\n     15-minute rate = 0.00 events/second\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Streams.TestStream.throughput\n              count = 2\n          mean rate = 0.04 events/second\n      1-minute rate = 0.03 events/second\n      5-minute rate = 0.01 events/second\n     15-minute rate = 0.00 events/second  -- Timers ----------------------------------------------------------------------\n io.siddhi.SiddhiApps.TestMetrics.Siddhi.Queries.logQuery.latency\n              count = 2\n          mean rate = 0.11 calls/second\n      1-minute rate = 0.34 calls/second\n      5-minute rate = 0.39 calls/second\n     15-minute rate = 0.40 calls/second\n                min = 0.61 milliseconds\n                max = 1.08 milliseconds\n               mean = 0.84 milliseconds\n             stddev = 0.23 milliseconds\n             median = 0.61 milliseconds\n               75%  = 1.08 milliseconds\n               95%  = 1.08 milliseconds\n               98%  = 1.08 milliseconds\n               99%  = 1.08 milliseconds\n             99.9%  = 1.08 milliseconds", 
            "title": "Statistics"
        }, 
        {
            "location": "/documentation/siddhi-4.x/query-guide-4.x/#event-playback", 
            "text": "When  @app:playback  annotation is added to the app, the timestamp of the event (specified via an attribute) is treated as the current time. This results in events being processed faster.\nThe following elements are configured with this annotation.     Annotation  Description      idle.time  If no events are received during a time interval specified (in milliseconds) via this element, the Siddhi system time is incremented by a number of seconds specified via the  increment  element.    increment  The number of seconds by which the Siddhi system time must be incremented if no events are received during the time interval specified via the  idle.time  element.     e.g., In the following example, the Siddhi system time is incremented by two seconds if no events arrive for a time interval of 100 milliseconds.  @app:playback(idle.time = '100 millisecond', increment = '2 sec')", 
            "title": "Event Playback"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/", 
            "text": "Siddhi 4.x Architecture\n\n\n\n\nInfo\n\n\nPlease find the latest Siddhi Architecture \nhere\n\n\n\n\nSiddhi is a software library that can be utilized in any of the following ways:\n\n\n\n\nRun as a server on its own\n\n\nRun within WSO2 SP as a service\n\n\nEmbedded into any Java or Python based application\n\n\nRun on an Android application\n\n\n\n\nIt provides analytical operators, orchestrates data flows, calculates analytics, and detects\npatterns on event data from multiple disparate live data sources. This allows developers to build applications that collect data, \nanalyze it, and communicate the results in real time.\n\n\nThis section illustrates the architecture of Siddhi and guides you through its key functionality. We hope this article \nhelps developers to understand Siddhi and its codebase better, and also contribute to improve Siddhi by reporting and fixing bugs.\n\n\nMain Design Decisions\n\n\n\n\nEvent by event processing of real-time streaming data to achieve low latency. \n\n\nEase of use with Streaming SQL providing an intuitive way to express stream processing logic and complex \nevent processing constructs such as Patterns.  \n\n\nAchieve high performance by processing all events in-memory and by storing their states in-memory. \n\n\nOptimizing performance by enforcing a strict schema for event streams and by pre-compiling the queries.\n\n\nOptimizing memory consumption by having only the absolutely necessary information in-memory and \ndropping the rest as soon as possible. \n\n\nSupporting multiple extension points to accommodate a diverse set of functionality such as supporting multiple sources, sinks, functions, \naggregation operations, windows, etc.\n\n\n\n\nHigh Level Architecture\n\n\n\n\nAt a high level, Siddhi consumes events from various events sources, processes them according to the defined Siddhi application, \nand produces results to the subscribed event sinks. \nSiddhi can store and consume events from in-memory tables or from external data stores such as \nRDBMS\n, \nMongoDB\n, \n\nHazelcast\n in-memory grid, etc. (i.e., when configured to do so). Siddhi also allows applications and users to query Siddhi via its Store Query API to interactively \nretrieve data from its in-memory and other stores.\n\n\nMain Modules in Siddhi\n\n\nSiddhi comprises four main modules, they are: \n\n\n\n\n\n\nSiddhi Query API\n : This allows you to define the execution logic of the Siddhi application as queries and definitions using POJO classes. \nInternally, Siddhi uses these objects to identify the tasks that it is expected to perform. \n\n\n\n\n\n\nSiddhi Query Compiler\n : This allows you to define the Siddhi application using the Siddhi Streaming SQL, \n and then it converts the Streaming SQL script to Siddhi Query POJO Objects so that Siddhi can execute them. \n\n\n\n\n\n\nSiddhi Core\n : This builds the execution runtime based on the defined Siddhi Application and processes the events as and when they arrive. \n\n\n\n\n\n\nSiddhi Annotation\n : This is a helper module that allows all extensions to be annotated, so that they can be \npicked by Siddhi Core for processing. This also helps Siddhi to generate the extension documentation. \n\n\n\n\n\n\nSiddhi Component Architecture\n\n\nThe following diagram illustrates the main components of Siddhi and how they work together. \n\n\n\n\nHere the \nSiddhi Core\n module maintains\nthe execution logic. It also interacts with the external environment and systems \nfor consuming and publishing events. To achieve these tasks, it uses the following components:  \n\n\n\n\n\n\nSiddhiManager\n : \n  This is a key component of Siddhi Core that manages Siddhi Application Runtimes \n  and facilitates their functionality via Siddhi Context with periodic state persistence, statistics reporting and extension loading. \n\n\n\n\n\n\nSiddhiAppRuntime\n : \n A Siddhi Application Runtime is generated for each Siddhi Application deployed. Siddhi Application Runtimes\n provide an isolated execution environment for each Siddhi Application defined.\n These Siddhi Application Runtimes are based on the logic of their Siddhi Application, and they consume and publish events from various external systems and Java or Python programmes. \n\n\n\n\n\n\nSiddhiContext\n : \nThis is a shared object for all the Siddhi Application Runtimes within the Siddhi manager, and it contains references \nto the persistence store for periodic persistence, statistics manager to report performance statistics of Siddhi Application Runtimes, \nand extension holders for loading Siddhi extensions. \n\n\n\n\n\n\nSiddhi Application Creation\n\n\nExecution logic in Siddhi is composed as a Siddhi Application, and this is passed as a string to \n\nSiddhiManager\n to create the \nSiddhiAppRuntime\n for execution. \n\n\nWhen a Siddhi Application is passed to the \nSiddhiManager.createSiddhiAppRuntime()\n, it is processed internally with the \n\nSiddhiCompiler\n. \nHere, the \nSiddhiApp\n String is converted to \nSiddhiApp\n\n object model by the \nSiddhiQLBaseVisitorImpl\n class. \nThe model is then passed to the \nSiddhiAppParser\n \nfor the \nSiddhiAppRuntime\n creation.\n\n\nSiddhi App Execution Flow\n\n\nFollowing diagram depicts the execution flow within a Siddhi App Runtime. \n\n\n\n\nThe path taken by events within Siddhi is indicated in blue. \n\n\nThe components that are involved in handling the events are as follows: \n\n\n\n\n\n\nStreamJunction\n\n\nThis routes events to various components within the Siddhi App Runtime. A stream junction is\ngenerated for each stream defined or inferred in the Siddhi Application. A stream junction by default uses the incoming event's thread\nfor processing subscribed components, but it can also be configured via the \n@Async\n annotation to buffer the events and \nuse a different thread for subsequent execution.\n\n\n\n\n\n\nInputHandler\n \n\n\nAn instance of input handler is created for each stream junction, and this is used for pushing \nEvent\n and\n \nEvent[]\n objects into stream junctions from sources, and Java/Python programmes. \n\n\n\n\n\n\nStreamCallback\n \n\n\nThis receives \nEvent[]\ns from stream junction and passes them to sinks to publish to external endpoints, \nor passes them to subscribed Java/Python programmes for further processing. \n\n\n\n\n\n\nQueries\n \n \nPartitions\n \n\n\nThese components process the events by filtering, transforming, joining, patten matching, \netc. They consume events from one or more stream junctions, process them and publish the processed events \ninto stream junctions based on the defined query or partition. \n\n\n\n\n\n\nSource\n \n\n\nSources consume events from external sources in various data formats, convert them into Siddhi events\nand pass them to corresponding Stream Junctions via their Input Handlers. A source is generated \nfor each \n@Source\n annotation defined above a stream definition. Each source consumes events from an external source in the data format configured for it. \n\n\n\n\n\n\nSourceMapper\n \n\n\nA source mapper needs to be configured for each source in order to convert the format of each incoming event to that of a Siddhi event. \nThe source mapper type can be configured using the \n@Map\n annotation within the \n@Source\n annotation. When the \n@Map\n annotation is\nnot defined, Siddhi uses the \nPassThroughSourceMapper\n,\nwhere it assumes that the incoming message is already in the Siddhi Event format, and therefore makes no changes to the event format.\n\n\n\n\n\n\nSink\n \n\n\nSinks convert the Siddhi Events to various data formats and publish them to external endpoints. \nA Sink generated for each \n@Sink\n annotation defined above a stream definition to publish the events arriving \nto that stream. \n\n\n\n\n\n\nSinkMapper\n\n\nA sink mapper is configured for each Sink in order to map the Siddhi events to the specified data format so that they \ncan be published via the sink. The sink mapper type can be configured using the \n@Map\n annotation within the \n@Sink\n\nannotation. When the \n@Map\n annotation is not defined, Siddhi uses \nPassThroughSinkMapper\n, \nwhere it  passes the Siddhi events in the existing format (i.e., the Siddhi event format) to the Sink.\n\n\n\n\n\n\nTable\n\n\nTables store events. By default, Siddhi uses the \nInMemoryTable\n \nimplementation to store events in-memory. When \n@Store\n annotation\nis used, it loads the associated Table implementation based on the defined \nstore\n type. Most table implementations are \nextended from the \nAbstractRecordTable\n \nabstract class for ease of development.\n\n\n\n\n\n\nWindow\n\n\nWindows store events and determine when events can be considered expired based on the given window constrain. Multiple types of windows are\ncan be implemented by extending the \nWindowProcessor\n \nabstract class. \n\n\n\n\n\n\nIncrementalAggregation\n \n\n\nThis allows you to obtain aggregates in an incremental manner for a specified set of time periods.\nIncremental aggregation functions can be implemented by extending \nIncrementalAttributeAggregator\n. \n\n\n\n\n\n\nTrigger\n\n\nA trigger triggers events at a given interval to the stream junction that has the same name as the trigger.\n\n\n\n\n\n\nQueryCallback\n\n\nA query callback receives notifications when events are emitted from queries. Then it notifies the event occurrence \ntimestamp\n, and classifies \nthe events into \ncurrentEvents\n, and \nexpiredEvents\n. \n\n\n\n\n\n\nSiddhi Query Execution\n\n\nSiddhi \nQueryRuntimes\n\n can be categorized in to three main types: \n\n\n\n\n\n\nSingleInputStream\n: \n Queries that consist of query types such as filters and windows.\n\n\n\n\n\n\nJoinInputStream\n:\n  Queries that consist of joins.\n\n\n\n\n\n\nStateInputStream\n: \n   Queries that consist of patterns and sequences. \n\n\n\n\n\n\nFollowing section explains the internals of each query type. \n\n\nSingleInputStream\n Query Runtime (Filter \n Windows)\n\n\n\n\nA single input stream query runtime is generated for filter and window queries. They consume events from a stream junction or a window\nand convert the incoming events according to the expected output stream format at the \nProcessStreamReceiver\n\nby dropping all the unrelated incoming stream attributes.\n\n\nThen the converted events are passed through a few Processors such as \nFilterProcessor\n,\n\nStreamProcessor\n, \n\nStreamFunctionProcessor\n, \n\nWindowProcessor\n\n and \nQuerySelector\n. \nHere, the \nStreamProcessor\n, \nStreamFunctionProcessor\n, and \nWindowProcessor\n can be extended with \nvarious stream processing capabilities. The last processor of the chain of processors must always be a \nQuerySelector\n, and each chain can \nhave only one \nWindowProcessor\n. When the query runtime consumes events from a window, its chain of processors cannot \ncontain a \nWindowProcessor\n.\n\n\nThe \nFilterProcessor\n is implemented with an \nExpressionExecutor\n \nthat returns a boolean value. Expressions have a tree structure, and \nthey are processed based on the Depth First Search algorithm. To achieve high performance,  Siddhi currently depends on the user\nto formulate the least successful case in the leftmost side of the condition, thereby increasing the chance of an early \nfalse\n detection.\n\n\nThe condition expression \nprice \n= 100 and ( Symbol == 'IBM' or Symbol == 'MSFT' )\n is represented as shown below.\n\n\n\n\nThese expressions also support the execution of user defined functions (UDFs), and they can be implemented by extending the \nFunctionExecutor\n class. \n\n\nAfter getting processed by each processor, each event reaches the \nQuerySelector\n for transformation. At the \nQuerySelector\n,\nevents are transformed based on the \nselect\n clause of the query. If there is a \nGroup By\n defined, then the \nGroupByKeyGenerator\n\nidentifies the group by key, and then each \nAttributeProcessor\n\nis executed based on that group-by key. \nAttributeProcessors\n can contain any expression including \nconstant values, variables and user defined functions. They can also contain \nAttributeAggregator\ns\nfor processing aggregation operations such as \nsum\n, \ncount\n, etc. Here, an \nAttributeAggregator\n is generated to \nkeep track of the aggregation state. When it becomes obsolete, it is destroyed. The events are transformed to the expected output format through this operation.  \n\n\nAfter an event is transformed to the output format, it is evaluated against the \nHavingConditionExecutor\n if a \nhaving\n clause is \nprovided. Only the succeeding events are pushed to the \nOutputRateLimiter\n.   \n\n\nAt \nOutputRateLimiter\n, the event output is controlled before sending the events to the stream junction or to the query callback. \nWhen the \noutput\n clause is not defined, the \nPassThroughOutputRateLimiter\n is used by passing all the events without any rate limiting. \n\n\nTemporal Processing with Windows\n\n\nThe temporal event processing aspect is achieved via \nWindow\n\nand \nAttributeAggregators\n\n\nTo achieve temporal processing,Siddhi uses the following four type of events: \n\n\n\n\n\n\nCurrent Events\n: Events that are newly arriving to a query from streams.\n\n\n\n\n\n\nExpired Events\n: Events that have expired from a window. \n\n\n\n\n\n\nTimer Events\n: Events that inform the query about an update of execution time. These events are usually generated by schedulers. \n\n\n\n\n\n\nReset Events\n: Events that resets the Siddhi query states.\n\n\n\n\n\n\nIn Siddhi, when an event comes into a \nWindowProcessor\n, \nit creates an appropriate expired event corresponding to the incoming current event with the expiring timestamp, and stores that \nevent in the window. The \nWindowProcessor\n  also forwards the current event to the next processor for further processing. \nIt uses a scheduler or such to determine when to emit the events it has in memory. During that time, it emits these events as expired events. If it needs to emit all the events in the memory at once, it emits a single reset event instead of sending one expired event for each event it has stored, so that it can reset the states in one go. For each current event emitted from a window, a corresponding expired event must be emitted. If not, a common reset event must be emitted.\n\nThis is vital in Siddhi because Siddhi relies on these events to calculate the Aggregations at the \nQuerySelector\n. \nIn the \nQuerySelector\n, the arrived current events increase the aggregation values, expired events decrease the values, and \nreset events reset the aggregation calculation.\n\n\nFor example, the sliding \nTimeWindow\n\ncreates a corresponding expired event for each current event that arrives,  adds that to \nthe window, adds an entry to the scheduler to notify when that event need to be expired by sending it a timer event, and \nfinally sends the current event to the next processor for subsequent processing.\n\nWhen the window receives an indication that the expected expiry time has come for the oldest event in the window via a \na timer event or other means, it removes the expired event from the window and passes that to the next processor. \n\n\n\n\nJoinInputStream\n Query Runtime (Join)\n\n\n\n\nJoin input stream query runtime is generated for join queries. This can consume events from two stream junctions and perform a join operation as depicted above. \nIt can also perform a join by consuming events from one stream junction and join against itself, or it can join against a \ntable, window or an incremental aggregation. When a join is performed with a table, window or incremental aggregation,\nthe \nWindowProcessor\n in the image is replaced with the table, window or incremental aggregation. No basic processors are used on their side. \n\n\nThe joining operation is triggered by the events that arrive from the stream junction.\nHere, when an event from one stream reaches the pre \nJoinProcessor\n, it matches against all the available events of the other stream's \nWindowProcessor\n. \nWhen a match is found, those matched events are sent to the \nQuerySelector\n as current events, and at the same time, \nthe original event is added to the \nWindowProcessor\n where it remains until it expires. Similarly, when an \nevent expires from the \nWindowProcessor\n, it matches against all the available events of the other stream's \nWindowProcessor\n, and \nwhen a match is found, those matched events are sent to the \nQuerySelector\n as expired events.\n\n\nNote: Despite the optimizations, a join query is quite expensive when it comes to performance. This is because\n the \nWindowProcessor\n is locked during the matching process to avoid race conditions and to achieve accuracy while \n joining. Therefore, avoid matching large windows in high volume streams. Based on the scenario, \n using appropriate window sizes (by time or length) helps to achieve maximum performance.\n\n\nStateInputStream\n Query Runtime (Pattern \n Sequence)\n\n\n\n\nThe state input stream query runtime is generated for pattern and sequence queries. This consumes events from one or more stream junctions \nvia \nProcessStreamReceivers\n. A \nProcessStreamReceiver\n and a set of basic processors is defined in the query for each condition.\nWhen a \nProcessStreamReceiver\n consumes the events, it updates the states with the incoming events that are generated by previous conditions. If the condition applied\nis the first condition in the query, then it creates a new state and updates that with the incoming event. This is then passed \nto basic processors to perform filtering and transformation operations. The states \nthat pass the basic processors are consumed by the \nPostStateProcessor\n and stored at the \nPreStateProcessor\n of the following pattern or \nsequence condition. When the state reaches the final condition's \nPostStateProcessor\n, \nthe output event is generated and emitted by \nQuerySelector\n. \n\n\nSiddhi Partition Execution\n\n\n\n\nA partition is a wrapper around one or more Siddhi queries and inner streams that connect them. \nA partition is implemented in Siddhi as a \nPartitionRuntime\n,\nand each unique partition instance is implemented as a \nPartitionInstanceRuntime\n\nEach partitioned stream entering the partition\ngoes through the appropriate \nPartitionStreamReceiver\n.\nThe \nPartitionExecutor\n\n of stream receiver evaluates \n\nthe incoming events to identify the partition key using the \nRangePartitionExecutor\n\n or the \nValuePartitionExecutor\n,\n  and passes \nthe events to the \nQueryRuntimes\n of the appropriate \nPartitionInstanceRuntime\n based on the partition key. \nIf a \nPartitionInstanceRuntime\n is not available for the given partition key, it is dynamically generated via the relevant \nQueryRuntimes\n and \nInnerStreamJunctions\n. \n\n\nBased on the partition definition, the \nQueryRuntimes\n in the \nPartitionInstanceRuntime\n wire themselves via inner \nStreamJunctions\n or using \n\nStreamJunctions\n outside the partitions. \nWhen a partition query consumes a non partitioned global stream, all instances of its \nQueryRuntime\n that are part of multiple \nPartitionInstanceRuntimes\n\nreceive the same event as depicted in the above diagram. \n\n\nSiddhi Event Formats\n\n\nSiddhi has three event formats. \n\n\n\n\n\n\nEvent\n \n\n\nThis is the format exposed to end users when they send events via Input Handler, and consume events via Stream Callback or Query Callback.\nThis consists of an \nObject[]\n that contains all the values in accordance to the corresponding stream. \n\n\n\n\n\n\nStreamEvent\n (Subtype of \nComplexEvent\n)\n\n\nThis is used within queries. This contains the following three \nObject[]\ns: \n- \nbeforeWindowData\n: This contains values that are only used in processors that are executed before the \nWindowProcessor\n.\n- \nonAfterWindowData\n: This contains values that are only used by the \nWindowProcessor\n and the other processors that follow it, but not sent as output.\n- \noutputData\n: This contains the values that comply with the output stream of the query.\n\n\n\n\n\n\nIn order to optimize the amount of data that is stored in the in-memory at windows, the content in \nbeforeWindowData\n is cleared before the \n    event enters the \nWindowProcessor\n. StreamEvents can also be chained by linking each other via the \nnext\n property in them.  \n\n\n\n\n\n\nStateEvent\n (Subtype of \nComplexEvent\n)\n\n\nThis is used in Joins, Patterns and Sequences when we need to associate events of multiple streams, tables, windows and aggregations of different types together.\nThis has a collection of \nStreamEvents\n representing different streams, tables, etc, that are used in the query, and \noutputData\n to contain the values that are needed for the query output. \n\nStreamEvents\n can also be chained by linking each other with the \nnext\n property in them. \n\n\n\n\n\n\nEvent Chunks\n\n\nEvent Chunks provide an easier way of manipulating the chain of \nStreamEvents\n and \nStateEvents\n so that they are be easily iterated, inserted and removed. \n\n\nSummary\n\n\nThis article focuses on describing the architecture of Siddhi and rationalizing the architectural decisions made. It\nalso explains the key features of Siddhi.\n\nThis is possibly a great starting point for new developers to understand Siddhi and to start contributing to it.", 
            "title": "Siddhi Architecture"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#siddhi-4x-architecture", 
            "text": "Info  Please find the latest Siddhi Architecture  here   Siddhi is a software library that can be utilized in any of the following ways:   Run as a server on its own  Run within WSO2 SP as a service  Embedded into any Java or Python based application  Run on an Android application   It provides analytical operators, orchestrates data flows, calculates analytics, and detects\npatterns on event data from multiple disparate live data sources. This allows developers to build applications that collect data, \nanalyze it, and communicate the results in real time.  This section illustrates the architecture of Siddhi and guides you through its key functionality. We hope this article \nhelps developers to understand Siddhi and its codebase better, and also contribute to improve Siddhi by reporting and fixing bugs.", 
            "title": "Siddhi 4.x Architecture"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#main-design-decisions", 
            "text": "Event by event processing of real-time streaming data to achieve low latency.   Ease of use with Streaming SQL providing an intuitive way to express stream processing logic and complex \nevent processing constructs such as Patterns.    Achieve high performance by processing all events in-memory and by storing their states in-memory.   Optimizing performance by enforcing a strict schema for event streams and by pre-compiling the queries.  Optimizing memory consumption by having only the absolutely necessary information in-memory and \ndropping the rest as soon as possible.   Supporting multiple extension points to accommodate a diverse set of functionality such as supporting multiple sources, sinks, functions, \naggregation operations, windows, etc.", 
            "title": "Main Design Decisions"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#high-level-architecture", 
            "text": "At a high level, Siddhi consumes events from various events sources, processes them according to the defined Siddhi application, \nand produces results to the subscribed event sinks. \nSiddhi can store and consume events from in-memory tables or from external data stores such as  RDBMS ,  MongoDB ,  Hazelcast  in-memory grid, etc. (i.e., when configured to do so). Siddhi also allows applications and users to query Siddhi via its Store Query API to interactively \nretrieve data from its in-memory and other stores.", 
            "title": "High Level Architecture"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#main-modules-in-siddhi", 
            "text": "Siddhi comprises four main modules, they are:     Siddhi Query API  : This allows you to define the execution logic of the Siddhi application as queries and definitions using POJO classes. \nInternally, Siddhi uses these objects to identify the tasks that it is expected to perform.     Siddhi Query Compiler  : This allows you to define the Siddhi application using the Siddhi Streaming SQL, \n and then it converts the Streaming SQL script to Siddhi Query POJO Objects so that Siddhi can execute them.     Siddhi Core  : This builds the execution runtime based on the defined Siddhi Application and processes the events as and when they arrive.     Siddhi Annotation  : This is a helper module that allows all extensions to be annotated, so that they can be \npicked by Siddhi Core for processing. This also helps Siddhi to generate the extension documentation.", 
            "title": "Main Modules in Siddhi"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#siddhi-component-architecture", 
            "text": "The following diagram illustrates the main components of Siddhi and how they work together.    Here the  Siddhi Core  module maintains\nthe execution logic. It also interacts with the external environment and systems \nfor consuming and publishing events. To achieve these tasks, it uses the following components:      SiddhiManager  : \n  This is a key component of Siddhi Core that manages Siddhi Application Runtimes \n  and facilitates their functionality via Siddhi Context with periodic state persistence, statistics reporting and extension loading.     SiddhiAppRuntime  : \n A Siddhi Application Runtime is generated for each Siddhi Application deployed. Siddhi Application Runtimes\n provide an isolated execution environment for each Siddhi Application defined.\n These Siddhi Application Runtimes are based on the logic of their Siddhi Application, and they consume and publish events from various external systems and Java or Python programmes.     SiddhiContext  : \nThis is a shared object for all the Siddhi Application Runtimes within the Siddhi manager, and it contains references \nto the persistence store for periodic persistence, statistics manager to report performance statistics of Siddhi Application Runtimes, \nand extension holders for loading Siddhi extensions.", 
            "title": "Siddhi Component Architecture"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#siddhi-application-creation", 
            "text": "Execution logic in Siddhi is composed as a Siddhi Application, and this is passed as a string to  SiddhiManager  to create the  SiddhiAppRuntime  for execution.   When a Siddhi Application is passed to the  SiddhiManager.createSiddhiAppRuntime() , it is processed internally with the  SiddhiCompiler . \nHere, the  SiddhiApp  String is converted to  SiddhiApp \n object model by the  SiddhiQLBaseVisitorImpl  class. \nThe model is then passed to the  SiddhiAppParser  \nfor the  SiddhiAppRuntime  creation.", 
            "title": "Siddhi Application Creation"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#siddhi-app-execution-flow", 
            "text": "Following diagram depicts the execution flow within a Siddhi App Runtime.    The path taken by events within Siddhi is indicated in blue.   The components that are involved in handling the events are as follows:     StreamJunction  This routes events to various components within the Siddhi App Runtime. A stream junction is\ngenerated for each stream defined or inferred in the Siddhi Application. A stream junction by default uses the incoming event's thread\nfor processing subscribed components, but it can also be configured via the  @Async  annotation to buffer the events and \nuse a different thread for subsequent execution.    InputHandler    An instance of input handler is created for each stream junction, and this is used for pushing  Event  and\n  Event[]  objects into stream junctions from sources, and Java/Python programmes.     StreamCallback    This receives  Event[] s from stream junction and passes them to sinks to publish to external endpoints, \nor passes them to subscribed Java/Python programmes for further processing.     Queries     Partitions    These components process the events by filtering, transforming, joining, patten matching, \netc. They consume events from one or more stream junctions, process them and publish the processed events \ninto stream junctions based on the defined query or partition.     Source    Sources consume events from external sources in various data formats, convert them into Siddhi events\nand pass them to corresponding Stream Junctions via their Input Handlers. A source is generated \nfor each  @Source  annotation defined above a stream definition. Each source consumes events from an external source in the data format configured for it.     SourceMapper    A source mapper needs to be configured for each source in order to convert the format of each incoming event to that of a Siddhi event. \nThe source mapper type can be configured using the  @Map  annotation within the  @Source  annotation. When the  @Map  annotation is\nnot defined, Siddhi uses the  PassThroughSourceMapper ,\nwhere it assumes that the incoming message is already in the Siddhi Event format, and therefore makes no changes to the event format.    Sink    Sinks convert the Siddhi Events to various data formats and publish them to external endpoints. \nA Sink generated for each  @Sink  annotation defined above a stream definition to publish the events arriving \nto that stream.     SinkMapper  A sink mapper is configured for each Sink in order to map the Siddhi events to the specified data format so that they \ncan be published via the sink. The sink mapper type can be configured using the  @Map  annotation within the  @Sink \nannotation. When the  @Map  annotation is not defined, Siddhi uses  PassThroughSinkMapper , \nwhere it  passes the Siddhi events in the existing format (i.e., the Siddhi event format) to the Sink.    Table  Tables store events. By default, Siddhi uses the  InMemoryTable  \nimplementation to store events in-memory. When  @Store  annotation\nis used, it loads the associated Table implementation based on the defined  store  type. Most table implementations are \nextended from the  AbstractRecordTable  \nabstract class for ease of development.    Window  Windows store events and determine when events can be considered expired based on the given window constrain. Multiple types of windows are\ncan be implemented by extending the  WindowProcessor  \nabstract class.     IncrementalAggregation    This allows you to obtain aggregates in an incremental manner for a specified set of time periods.\nIncremental aggregation functions can be implemented by extending  IncrementalAttributeAggregator .     Trigger  A trigger triggers events at a given interval to the stream junction that has the same name as the trigger.    QueryCallback  A query callback receives notifications when events are emitted from queries. Then it notifies the event occurrence  timestamp , and classifies \nthe events into  currentEvents , and  expiredEvents .", 
            "title": "Siddhi App Execution Flow"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#siddhi-query-execution", 
            "text": "Siddhi  QueryRuntimes \n can be categorized in to three main types:     SingleInputStream : \n Queries that consist of query types such as filters and windows.    JoinInputStream :\n  Queries that consist of joins.    StateInputStream : \n   Queries that consist of patterns and sequences.     Following section explains the internals of each query type.", 
            "title": "Siddhi Query Execution"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#singleinputstream-query-runtime-filter-windows", 
            "text": "A single input stream query runtime is generated for filter and window queries. They consume events from a stream junction or a window\nand convert the incoming events according to the expected output stream format at the  ProcessStreamReceiver \nby dropping all the unrelated incoming stream attributes.  Then the converted events are passed through a few Processors such as  FilterProcessor , StreamProcessor ,  StreamFunctionProcessor ,  WindowProcessor \n and  QuerySelector . \nHere, the  StreamProcessor ,  StreamFunctionProcessor , and  WindowProcessor  can be extended with \nvarious stream processing capabilities. The last processor of the chain of processors must always be a  QuerySelector , and each chain can \nhave only one  WindowProcessor . When the query runtime consumes events from a window, its chain of processors cannot \ncontain a  WindowProcessor .  The  FilterProcessor  is implemented with an  ExpressionExecutor  \nthat returns a boolean value. Expressions have a tree structure, and \nthey are processed based on the Depth First Search algorithm. To achieve high performance,  Siddhi currently depends on the user\nto formulate the least successful case in the leftmost side of the condition, thereby increasing the chance of an early  false  detection.  The condition expression  price  = 100 and ( Symbol == 'IBM' or Symbol == 'MSFT' )  is represented as shown below.   These expressions also support the execution of user defined functions (UDFs), and they can be implemented by extending the  FunctionExecutor  class.   After getting processed by each processor, each event reaches the  QuerySelector  for transformation. At the  QuerySelector ,\nevents are transformed based on the  select  clause of the query. If there is a  Group By  defined, then the  GroupByKeyGenerator \nidentifies the group by key, and then each  AttributeProcessor \nis executed based on that group-by key.  AttributeProcessors  can contain any expression including \nconstant values, variables and user defined functions. They can also contain  AttributeAggregator s\nfor processing aggregation operations such as  sum ,  count , etc. Here, an  AttributeAggregator  is generated to \nkeep track of the aggregation state. When it becomes obsolete, it is destroyed. The events are transformed to the expected output format through this operation.    After an event is transformed to the output format, it is evaluated against the  HavingConditionExecutor  if a  having  clause is \nprovided. Only the succeeding events are pushed to the  OutputRateLimiter .     At  OutputRateLimiter , the event output is controlled before sending the events to the stream junction or to the query callback. \nWhen the  output  clause is not defined, the  PassThroughOutputRateLimiter  is used by passing all the events without any rate limiting.", 
            "title": "SingleInputStream Query Runtime (Filter &amp; Windows)"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#temporal-processing-with-windows", 
            "text": "The temporal event processing aspect is achieved via  Window \nand  AttributeAggregators  To achieve temporal processing,Siddhi uses the following four type of events:     Current Events : Events that are newly arriving to a query from streams.    Expired Events : Events that have expired from a window.     Timer Events : Events that inform the query about an update of execution time. These events are usually generated by schedulers.     Reset Events : Events that resets the Siddhi query states.    In Siddhi, when an event comes into a  WindowProcessor , \nit creates an appropriate expired event corresponding to the incoming current event with the expiring timestamp, and stores that \nevent in the window. The  WindowProcessor   also forwards the current event to the next processor for further processing. \nIt uses a scheduler or such to determine when to emit the events it has in memory. During that time, it emits these events as expired events. If it needs to emit all the events in the memory at once, it emits a single reset event instead of sending one expired event for each event it has stored, so that it can reset the states in one go. For each current event emitted from a window, a corresponding expired event must be emitted. If not, a common reset event must be emitted. \nThis is vital in Siddhi because Siddhi relies on these events to calculate the Aggregations at the  QuerySelector . \nIn the  QuerySelector , the arrived current events increase the aggregation values, expired events decrease the values, and \nreset events reset the aggregation calculation.  For example, the sliding  TimeWindow \ncreates a corresponding expired event for each current event that arrives,  adds that to \nthe window, adds an entry to the scheduler to notify when that event need to be expired by sending it a timer event, and \nfinally sends the current event to the next processor for subsequent processing. \nWhen the window receives an indication that the expected expiry time has come for the oldest event in the window via a \na timer event or other means, it removes the expired event from the window and passes that to the next processor.", 
            "title": "Temporal Processing with Windows"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#joininputstream-query-runtime-join", 
            "text": "Join input stream query runtime is generated for join queries. This can consume events from two stream junctions and perform a join operation as depicted above. \nIt can also perform a join by consuming events from one stream junction and join against itself, or it can join against a \ntable, window or an incremental aggregation. When a join is performed with a table, window or incremental aggregation,\nthe  WindowProcessor  in the image is replaced with the table, window or incremental aggregation. No basic processors are used on their side.   The joining operation is triggered by the events that arrive from the stream junction.\nHere, when an event from one stream reaches the pre  JoinProcessor , it matches against all the available events of the other stream's  WindowProcessor . \nWhen a match is found, those matched events are sent to the  QuerySelector  as current events, and at the same time, \nthe original event is added to the  WindowProcessor  where it remains until it expires. Similarly, when an \nevent expires from the  WindowProcessor , it matches against all the available events of the other stream's  WindowProcessor , and \nwhen a match is found, those matched events are sent to the  QuerySelector  as expired events.  Note: Despite the optimizations, a join query is quite expensive when it comes to performance. This is because\n the  WindowProcessor  is locked during the matching process to avoid race conditions and to achieve accuracy while \n joining. Therefore, avoid matching large windows in high volume streams. Based on the scenario, \n using appropriate window sizes (by time or length) helps to achieve maximum performance.", 
            "title": "JoinInputStream Query Runtime (Join)"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#stateinputstream-query-runtime-pattern-sequence", 
            "text": "The state input stream query runtime is generated for pattern and sequence queries. This consumes events from one or more stream junctions \nvia  ProcessStreamReceivers . A  ProcessStreamReceiver  and a set of basic processors is defined in the query for each condition.\nWhen a  ProcessStreamReceiver  consumes the events, it updates the states with the incoming events that are generated by previous conditions. If the condition applied\nis the first condition in the query, then it creates a new state and updates that with the incoming event. This is then passed \nto basic processors to perform filtering and transformation operations. The states \nthat pass the basic processors are consumed by the  PostStateProcessor  and stored at the  PreStateProcessor  of the following pattern or \nsequence condition. When the state reaches the final condition's  PostStateProcessor , \nthe output event is generated and emitted by  QuerySelector .", 
            "title": "StateInputStream Query Runtime (Pattern &amp; Sequence)"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#siddhi-partition-execution", 
            "text": "A partition is a wrapper around one or more Siddhi queries and inner streams that connect them. \nA partition is implemented in Siddhi as a  PartitionRuntime ,\nand each unique partition instance is implemented as a  PartitionInstanceRuntime \nEach partitioned stream entering the partition\ngoes through the appropriate  PartitionStreamReceiver .\nThe  PartitionExecutor \n of stream receiver evaluates  \nthe incoming events to identify the partition key using the  RangePartitionExecutor \n or the  ValuePartitionExecutor ,\n  and passes \nthe events to the  QueryRuntimes  of the appropriate  PartitionInstanceRuntime  based on the partition key. \nIf a  PartitionInstanceRuntime  is not available for the given partition key, it is dynamically generated via the relevant  QueryRuntimes  and  InnerStreamJunctions .   Based on the partition definition, the  QueryRuntimes  in the  PartitionInstanceRuntime  wire themselves via inner  StreamJunctions  or using  StreamJunctions  outside the partitions. \nWhen a partition query consumes a non partitioned global stream, all instances of its  QueryRuntime  that are part of multiple  PartitionInstanceRuntimes \nreceive the same event as depicted in the above diagram.", 
            "title": "Siddhi Partition Execution"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#siddhi-event-formats", 
            "text": "Siddhi has three event formats.     Event    This is the format exposed to end users when they send events via Input Handler, and consume events via Stream Callback or Query Callback.\nThis consists of an  Object[]  that contains all the values in accordance to the corresponding stream.     StreamEvent  (Subtype of  ComplexEvent )  This is used within queries. This contains the following three  Object[] s: \n-  beforeWindowData : This contains values that are only used in processors that are executed before the  WindowProcessor .\n-  onAfterWindowData : This contains values that are only used by the  WindowProcessor  and the other processors that follow it, but not sent as output.\n-  outputData : This contains the values that comply with the output stream of the query.    In order to optimize the amount of data that is stored in the in-memory at windows, the content in  beforeWindowData  is cleared before the \n    event enters the  WindowProcessor . StreamEvents can also be chained by linking each other via the  next  property in them.      StateEvent  (Subtype of  ComplexEvent )  This is used in Joins, Patterns and Sequences when we need to associate events of multiple streams, tables, windows and aggregations of different types together.\nThis has a collection of  StreamEvents  representing different streams, tables, etc, that are used in the query, and  outputData  to contain the values that are needed for the query output.  StreamEvents  can also be chained by linking each other with the  next  property in them.     Event Chunks  Event Chunks provide an easier way of manipulating the chain of  StreamEvents  and  StateEvents  so that they are be easily iterated, inserted and removed.", 
            "title": "Siddhi Event Formats"
        }, 
        {
            "location": "/documentation/siddhi-4.x/architecture-4.x/#summary", 
            "text": "This article focuses on describing the architecture of Siddhi and rationalizing the architectural decisions made. It\nalso explains the key features of Siddhi. \nThis is possibly a great starting point for new developers to understand Siddhi and to start contributing to it.", 
            "title": "Summary"
        }, 
        {
            "location": "/contribution/", 
            "text": "How to Contribute\n\n\nSiddhi is a java library that listens to events from data streams, detects complex conditions described via a \nStreaming\n SQL language\n, and triggers actions. It performs both \nStream Processing\n and \nComplex Event Processing\n.\n\n\nWe are an open-source project under Apache license and the work of hundreds of contributors.\n\n\nWe always appreciate and welcome your help. You can contribute to siddhi in various ways; please find them below.\n\n\nCommunicating with the team\n\n\nSiddhi-Dev Google Group\n Group is the main Siddhi project discussion forum for developers.\n\n\nUsers can you \nSiddhi-User Google Group\n to raise any queries and get some help to achieve their usecases.\n\n\nStackOverflow\n is also can be used to get some support, and GitHub for issues and code repositories.\n\n\nReporting Issues\n\n\nIf you are unsure whether you have found a bug, please consider searching existing issues in github and asking in Siddhi-Dev Google Group.\n\n\nTo file non-security issues:\n\n\n\n\n\n\nClick the \nIssues\n tab in the github repository,\n\n\n\n\n\n\nClick the \nNew Issue\n button,\n\n\n\n\n\n\nFill out all sections in the issue template and submit.\n\n\n\n\n\n\nContributing Code\n\n\nAccepting Contributor License Agreement (CLA)\n\n\nBefore you submit your first contribution please accept our Contributor License Agreement (CLA) here. When you send your first Pull Request (PR), GitHub will ask you to accept the CLA.\n\n\nThere is no need to do this before you send your first PR.\n\n\nSubsequent PRs will not require CLA acceptance.\n\n\nIf for some (unlikely) reason at any time CLA changes, you will get presented with the new CLA text on your first PR after the change.\n\n\nObtaining the Source Code and Building the Project\n\n\n\n\nGet a clone or download source from \nGithub\n\n\nPrerequisites: JDK 1.8.x or JDK 11.x.x and Maven 3.5.x version (Install \nMaven\n)\n\n\nRun the Maven command \nmvn clean install\n from the Siddhi root directory:\n\n\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmvn clean install\n\n\nBuild and install the artifacts into the local repository.\n\n\n\n\n\n\nmvn clean install -Dmaven.test.skip=true\n\n\nBuild and install the artifacts into the local repository, without running any of the unit tests.\n\n\n\n\n\n\n\n\nSetting up the Developer Environment\n\n\nYou can use any of your preferred IDEs (eg: IntelliJ IDEA, Eclipse.. ). Make sure, that your IDE is configured with proper JDK and Maven settings. Import the source code in your IDE and do necessary code changes.\nThen add necessary unit tests with respect to your changes. Finally, build the complete Siddhi project with tests and commit the changes to your Github folk once build is successful.\n\n\nCommit the Changes\n\n\nWe follow these commit message requirements:\n\n\n\n\nSeparate subject from body with a blank line\n\n\nLimit the subject line to 50 characters\n\n\nCapitalize the subject line\n\n\nDo not end the subject line with a period\n\n\nUse the imperative mood in the subject line\n\n\nWrap the body at 72 characters\n\n\nUse the body to explain what and why vs. how\n\n\n\n\nPlease find details at: \nhttps://chris.beams.io/posts/git-commit/\n\n\nProposing changes/improvements to Siddhi\n\n\nStart with the discussion in the \nSiddhi-Dev Google Group\n.\n\n\nOnce there is enough consensus around the proposal, you will likely be asked to file an Issue in GitHub and label it as Proposal, to continue the discussion on details there.", 
            "title": "Contribute"
        }, 
        {
            "location": "/contribution/#how-to-contribute", 
            "text": "Siddhi is a java library that listens to events from data streams, detects complex conditions described via a  Streaming\n SQL language , and triggers actions. It performs both  Stream Processing  and  Complex Event Processing .  We are an open-source project under Apache license and the work of hundreds of contributors.  We always appreciate and welcome your help. You can contribute to siddhi in various ways; please find them below.", 
            "title": "How to Contribute"
        }, 
        {
            "location": "/contribution/#communicating-with-the-team", 
            "text": "Siddhi-Dev Google Group  Group is the main Siddhi project discussion forum for developers.  Users can you  Siddhi-User Google Group  to raise any queries and get some help to achieve their usecases.  StackOverflow  is also can be used to get some support, and GitHub for issues and code repositories.", 
            "title": "Communicating with the team"
        }, 
        {
            "location": "/contribution/#reporting-issues", 
            "text": "If you are unsure whether you have found a bug, please consider searching existing issues in github and asking in Siddhi-Dev Google Group.  To file non-security issues:    Click the  Issues  tab in the github repository,    Click the  New Issue  button,    Fill out all sections in the issue template and submit.", 
            "title": "Reporting Issues"
        }, 
        {
            "location": "/contribution/#contributing-code", 
            "text": "", 
            "title": "Contributing Code"
        }, 
        {
            "location": "/contribution/#accepting-contributor-license-agreement-cla", 
            "text": "Before you submit your first contribution please accept our Contributor License Agreement (CLA) here. When you send your first Pull Request (PR), GitHub will ask you to accept the CLA.  There is no need to do this before you send your first PR.  Subsequent PRs will not require CLA acceptance.  If for some (unlikely) reason at any time CLA changes, you will get presented with the new CLA text on your first PR after the change.", 
            "title": "Accepting Contributor License Agreement (CLA)"
        }, 
        {
            "location": "/contribution/#obtaining-the-source-code-and-building-the-project", 
            "text": "Get a clone or download source from  Github  Prerequisites: JDK 1.8.x or JDK 11.x.x and Maven 3.5.x version (Install  Maven )  Run the Maven command  mvn clean install  from the Siddhi root directory:      Command  Description      mvn clean install  Build and install the artifacts into the local repository.    mvn clean install -Dmaven.test.skip=true  Build and install the artifacts into the local repository, without running any of the unit tests.", 
            "title": "Obtaining the Source Code and Building the Project"
        }, 
        {
            "location": "/contribution/#setting-up-the-developer-environment", 
            "text": "You can use any of your preferred IDEs (eg: IntelliJ IDEA, Eclipse.. ). Make sure, that your IDE is configured with proper JDK and Maven settings. Import the source code in your IDE and do necessary code changes.\nThen add necessary unit tests with respect to your changes. Finally, build the complete Siddhi project with tests and commit the changes to your Github folk once build is successful.", 
            "title": "Setting up the Developer Environment"
        }, 
        {
            "location": "/contribution/#commit-the-changes", 
            "text": "We follow these commit message requirements:   Separate subject from body with a blank line  Limit the subject line to 50 characters  Capitalize the subject line  Do not end the subject line with a period  Use the imperative mood in the subject line  Wrap the body at 72 characters  Use the body to explain what and why vs. how   Please find details at:  https://chris.beams.io/posts/git-commit/", 
            "title": "Commit the Changes"
        }, 
        {
            "location": "/contribution/#proposing-changesimprovements-to-siddhi", 
            "text": "Start with the discussion in the  Siddhi-Dev Google Group .  Once there is enough consensus around the proposal, you will likely be asked to file an Issue in GitHub and label it as Proposal, to continue the discussion on details there.", 
            "title": "Proposing changes/improvements to Siddhi"
        }, 
        {
            "location": "/extensions/", 
            "text": "Siddhi Extensions\n\n\nAvailable Extensions\n\n\nFollowing are some pre-written extensions that are supported with Siddhi;\n\n\nExtensions released under Apache 2.0 License\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexecution-approximate\n\n\nThe siddhi-execution-approximate is an extension to Siddhi that performs approximate computing on event streams.\n\n\n\n\n\n\nexecution-env\n\n\nThe siddhi-execution-env extension is an extension to Siddhi that provides the capability to read environment properties inside Siddhi stream definitions and use it inside queries. Functions of the env extension are as follows..\n\n\n\n\n\n\nexecution-extrema\n\n\nThe siddhi-execution-extrema extension is an extension to Siddhi that processes event streams based on different arithmetic properties. Different types of processors are available to extract the extremas from the event streams according to the specified attribute in the stream.\n\n\n\n\n\n\nexecution-geo\n\n\nThe siddhi-execution-geo extension is an extension to Siddhi that provides geo data related functionality such as checking whether a given geo coordinate is within a predefined geo-fence, etc. Following are the functions of the Geo extension.\n\n\n\n\n\n\nexecution-graph\n\n\nThe siddhi-execution-graph extension is an extension to Siddhi that provides graph related functionality to Siddhi such as getting size of largest connected component of a graph, maximum clique size of a graph, etc.\n\n\n\n\n\n\nexecution-kalmanfilter\n\n\nThe siddhi-execution-kalman-filter extension is an extension to Siddhi provides that Kalman filtering capabilities to Siddhi. This allows you to detect outliers of input data.\n\n\n\n\n\n\nexecution-map\n\n\nThe siddhi-execution-map extension is an extension to Siddhi that provides the capability to send a map object inside Siddhi stream definitions and use it inside queries. The following are the functions of the map extension..\n\n\n\n\n\n\nexecution-markov\n\n\nThe siddhi-execution-markov extension is an extension to Siddhi that allows abnormal patterns relating to user activity to be detected when carrying out real time analysis.\n\n\n\n\n\n\nexecution-math\n\n\nThe siddhi-execution-math is an extension to Siddhi, which provides useful mathematical functions that can make your siddhi queries more flexible.\n\n\n\n\n\n\nexecution-priority\n\n\nThe siddhi-execution-priority extension is an extension to Siddhi that keeps track of the priority of events in a stream.\n\n\n\n\n\n\nexecution-regex\n\n\nThe siddhi-execution-regex extension is an extension to Siddhi that provides basic RegEx execution capabilities.\n\n\n\n\n\n\nexecution-reorder\n\n\nThe siddhi-execution-reorder extension is an extension to Siddhi that is used for reordering events from an unordered event stream. Reorder extension is implemented using the K-Slack and alpha K-Stack algorithms.\n\n\n\n\n\n\nexecution-sentiment\n\n\nThe siddhi-execution-sentiment extension is an extension to Siddhi that performs sentiment analysis using Afinn Wordlist-based approach.\n\n\n\n\n\n\nexecution-stats\n\n\nThe siddhi-execution-stats extension is an extension to Siddhi that provides statistical functions for aggregated events. Currently this contains median function which calculate the median of aggregated events. Calculation of median is done for each event arrival and expiry, it is not recommended to use this extension for large window sizes.\n\n\n\n\n\n\nexecution-streamingml\n\n\nThe siddhi-execution-streamingml is an extension to Siddhi that performs streaming machine learning on event streams.\n\n\n\n\n\n\nexecution-string\n\n\nThe siddhi-execution-string is an extension to Siddhi that provides basic string handling capabilities such as con-cat, length, convert to lowercase, and replace all.\n\n\n\n\n\n\nexecution-tensorflow\n\n\nThe siddhi-execution-tensorflow is an extension to Siddhi that adds support for inferences from pre-built TensorFlow SavedModels using Siddhi.\n\n\n\n\n\n\nexecution-time\n\n\nThe siddhi-execution-time extension is an extension to Siddhi that provides time related functionality to Siddhi such as getting current time, current date, manipulating/formatting dates and etc.\n\n\n\n\n\n\nexecution-timeseries\n\n\nThe siddhi-execution-timeseries extension is an extension to Siddhi which enables users to forecast and detect outliers in time series data, using Linear Regression Models.\n\n\n\n\n\n\nexecution-unique\n\n\nThe siddhi-execution-unique extension is an extension to Siddhi that processes event streams based on unique events. Different types of unique windows are available to hold unique events based on the given unique key parameter.\n\n\n\n\n\n\nexecution-unitconversion\n\n\nThe siddhi-execution-unitconversion extension is an extension to Siddhi that enables conversions of length, mass, time and volume units.\n\n\n\n\n\n\nio-cdc\n\n\nThe siddhi-io-cdc extension is an extension to Siddhi. It receives change data from MySQL, MS SQL Server, Postgresql, H2 and Oracle in the key-value format.\n\n\n\n\n\n\nio-email\n\n\nThe siddhi-io-email extension is an extension to Siddhi that receives and publishes events via email. Using the extension, events can be published through smtp mail server and received through 'pop3' or 'imap' mail serves.\n\n\n\n\n\n\nio-file\n\n\nThe siddhi-io-file extension is an extension to Siddhi which is used to receive/publish event data from/to file. It supports both binary and text formats.\n\n\n\n\n\n\nio-http\n\n\nThe siddhi-io-http extension is an extension to Siddhi that allows you to receive and publish events via http and https transports and also allow you perform synchronous request and response. This extension works with WSO2 Stream Processor and with standalone Siddhi.\n\n\n\n\n\n\nio-jms\n\n\nThe siddhi-io-jms extension is an extension to Siddhi that used to receive and publishe events via JMS Message. This extension allows users to subscribe to a JMS broker and receive/publish JMS messages.\n\n\n\n\n\n\nio-kafka\n\n\nThe siddhi-io-kafka extension is an extension to Siddhi. This implements siddhi kafka source and sink that can be used to receive events from a kafka cluster and to publish events to a kafka cluster.\n\n\n\n\n\n\nio-mqtt\n\n\nThe siddhi-io-mqtt is an extension to Siddhi mqtt source and sink implementation,that publish and receive events from mqtt broker.\n\n\n\n\n\n\nio-prometheus\n\n\nThe siddhi-io-prometheus extension is an extension to Siddhi. The Prometheus-sink publishes Siddhi events as Prometheus metrics and expose them to Prometheus server. The Prometheus-source retrieves Prometheus metrics from an endpoint and send them as Siddhi events.\n\n\n\n\n\n\nio-rabbitmq\n\n\nThe siddhi-io-rabbitmq is an extension to Siddhi that publish and receive events from rabbitmq broker.\n\n\n\n\n\n\nio-sqs\n\n\nThe siddhi-io-sqs extension is an extension to Siddhi that used to receive and publish events via AWS SQS Service. This extension allows users to subscribe to a SQS queue and receive/publish SQS messages.\n\n\n\n\n\n\nio-tcp\n\n\nThe siddhi-io-tcp extension is an extension to Siddhi that allows to receive and publish events through TCP.\n\n\n\n\n\n\nio-twitter\n\n\nThe siddhi-io-twitter extension is an extension to Siddhi. It publishes event data from Twitter Applications in the key-value map format.\n\n\n\n\n\n\nio-websocket\n\n\nThe siddhi-io-websocket extension is an extension to Siddhi that allows to receive and publish events through WebSocket.\n\n\n\n\n\n\nio-wso2event\n\n\nThe siddhi-io-wso2event extension is an extension to Siddhi that receives and publishes events in the WSO2Event format via Thrift or Binary protocols.\n\n\n\n\n\n\nmap-binary\n\n\nThe siddhi-map-binary extension is an extension to Siddhi that can be used to convert binary events to/from Siddhi events.\n\n\n\n\n\n\nmap-csv\n\n\nThe siddhi-map-csv extension is an extension to Siddhi that supports mapping incoming events with csv format to a stream at the source, and mapping a stream to csv format events at the sink.\n\n\n\n\n\n\nmap-json\n\n\nThe siddhi-map-json extension is an extension to Siddhi which is used to convert JSON message to/from Siddhi events.\n\n\n\n\n\n\nmap-keyvalue\n\n\nThe siddhi-map-keyvalue extension is an extension to Siddhi that supports mapping incoming events with Key-Value map format to a stream at the source, and mapping a stream to Key-Value map events at the sink.\n\n\n\n\n\n\nmap-text\n\n\nThe siddhi-map-text extension is an extension to Siddhi that supports mapping incoming text messages to a stream at the source, and mapping a stream to text messages at the sink.\n\n\n\n\n\n\nmap-wso2event\n\n\nThe siddhi-map-wso2event extension is an extension to Siddhi that can be used to convert WSO2 events to/from Siddhi events.\n\n\n\n\n\n\nmap-xml\n\n\nThe siddhi-map-xml extension is an extension to Siddhi that supports mapping incoming XML events to a stream at the source, and mapping a stream to XML events at the sink.\n\n\n\n\n\n\nscript-js\n\n\nThe siddhi-script-js is an extension to Siddhi that allows to include JavaScript functions within the Siddhi Query Language.\n\n\n\n\n\n\nstore-cassandra\n\n\nThe siddhi-store-cassandra extension is an extension to Siddhi that can be used to persist events to a Cassandra instance of the users choice. Find some useful links below:\n\n\n\n\n\n\nstore-hbase\n\n\nThe siddhi-store-hbase extension is an extension to Siddhi that can be used to persist events to a HBase instance of the users choice. Find some useful links below:\n\n\n\n\n\n\nstore-mongodb\n\n\nThe siddhi-store-mongodb extension is an extension to Siddhi that can be used to persist events to a MongoDB instance of the users choice. Find some useful links below:\n\n\n\n\n\n\nstore-rdbms\n\n\nThe siddhi-store-rdbms extension is an extension to Siddhi that can be used to persist events to an RDBMS instance of the user's choice.\n\n\n\n\n\n\nstore-redis\n\n\nThe siddhi-store-redis extension is an extension for siddhi redis event table implementation. This extension can be used to persist events to a redis cloud instance of version 4.x.x.\n\n\n\n\n\n\nstore-solr\n\n\nThe siddhi-store-solr extension is an extension for siddhi Solr event table implementation. This extension can be used to persist events to a Solr cloud instance of version 6.x.x.\n\n\n\n\n\n\n\n\nExtensions released under GPL License\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexecution-geo\n\n\nThe siddhi-gpl-execution-geo extension is an extension to Siddhi that provides geo data related functionality such as checking whether a given geo coordinate is within a predefined geo-fence, etc. Following are the functions of the Geo extension.\n\n\n\n\n\n\nexecution-nlp\n\n\nThe siddhi-gpl-execution-nlp extension is an extension to Siddhi that can be used to process natural language.\n\n\n\n\n\n\nexecution-pmml\n\n\nThe siddhi-gpl-execution-pmml extension is an extension to Siddhi that can be used to process texts based on a PMML processing model.\n\n\n\n\n\n\nexecution-r\n\n\nThe siddhi-gpl-execution-r extension is an extension to Siddhi that can be used to process events with R scripts.\n\n\n\n\n\n\nexecution-streamingml\n\n\nThe siddhi-execution-streamingml is an extension to Siddhi that performs streaming machine learning on event streams.\n\n\n\n\n\n\n\n\nExtension Repositories\n\n\nAll the extension repositories maintained by WSO2 can be found \nhere", 
            "title": "Extensions"
        }, 
        {
            "location": "/extensions/#siddhi-extensions", 
            "text": "", 
            "title": "Siddhi Extensions"
        }, 
        {
            "location": "/extensions/#available-extensions", 
            "text": "Following are some pre-written extensions that are supported with Siddhi;", 
            "title": "Available Extensions"
        }, 
        {
            "location": "/extensions/#extensions-released-under-apache-20-license", 
            "text": "Name  Description      execution-approximate  The siddhi-execution-approximate is an extension to Siddhi that performs approximate computing on event streams.    execution-env  The siddhi-execution-env extension is an extension to Siddhi that provides the capability to read environment properties inside Siddhi stream definitions and use it inside queries. Functions of the env extension are as follows..    execution-extrema  The siddhi-execution-extrema extension is an extension to Siddhi that processes event streams based on different arithmetic properties. Different types of processors are available to extract the extremas from the event streams according to the specified attribute in the stream.    execution-geo  The siddhi-execution-geo extension is an extension to Siddhi that provides geo data related functionality such as checking whether a given geo coordinate is within a predefined geo-fence, etc. Following are the functions of the Geo extension.    execution-graph  The siddhi-execution-graph extension is an extension to Siddhi that provides graph related functionality to Siddhi such as getting size of largest connected component of a graph, maximum clique size of a graph, etc.    execution-kalmanfilter  The siddhi-execution-kalman-filter extension is an extension to Siddhi provides that Kalman filtering capabilities to Siddhi. This allows you to detect outliers of input data.    execution-map  The siddhi-execution-map extension is an extension to Siddhi that provides the capability to send a map object inside Siddhi stream definitions and use it inside queries. The following are the functions of the map extension..    execution-markov  The siddhi-execution-markov extension is an extension to Siddhi that allows abnormal patterns relating to user activity to be detected when carrying out real time analysis.    execution-math  The siddhi-execution-math is an extension to Siddhi, which provides useful mathematical functions that can make your siddhi queries more flexible.    execution-priority  The siddhi-execution-priority extension is an extension to Siddhi that keeps track of the priority of events in a stream.    execution-regex  The siddhi-execution-regex extension is an extension to Siddhi that provides basic RegEx execution capabilities.    execution-reorder  The siddhi-execution-reorder extension is an extension to Siddhi that is used for reordering events from an unordered event stream. Reorder extension is implemented using the K-Slack and alpha K-Stack algorithms.    execution-sentiment  The siddhi-execution-sentiment extension is an extension to Siddhi that performs sentiment analysis using Afinn Wordlist-based approach.    execution-stats  The siddhi-execution-stats extension is an extension to Siddhi that provides statistical functions for aggregated events. Currently this contains median function which calculate the median of aggregated events. Calculation of median is done for each event arrival and expiry, it is not recommended to use this extension for large window sizes.    execution-streamingml  The siddhi-execution-streamingml is an extension to Siddhi that performs streaming machine learning on event streams.    execution-string  The siddhi-execution-string is an extension to Siddhi that provides basic string handling capabilities such as con-cat, length, convert to lowercase, and replace all.    execution-tensorflow  The siddhi-execution-tensorflow is an extension to Siddhi that adds support for inferences from pre-built TensorFlow SavedModels using Siddhi.    execution-time  The siddhi-execution-time extension is an extension to Siddhi that provides time related functionality to Siddhi such as getting current time, current date, manipulating/formatting dates and etc.    execution-timeseries  The siddhi-execution-timeseries extension is an extension to Siddhi which enables users to forecast and detect outliers in time series data, using Linear Regression Models.    execution-unique  The siddhi-execution-unique extension is an extension to Siddhi that processes event streams based on unique events. Different types of unique windows are available to hold unique events based on the given unique key parameter.    execution-unitconversion  The siddhi-execution-unitconversion extension is an extension to Siddhi that enables conversions of length, mass, time and volume units.    io-cdc  The siddhi-io-cdc extension is an extension to Siddhi. It receives change data from MySQL, MS SQL Server, Postgresql, H2 and Oracle in the key-value format.    io-email  The siddhi-io-email extension is an extension to Siddhi that receives and publishes events via email. Using the extension, events can be published through smtp mail server and received through 'pop3' or 'imap' mail serves.    io-file  The siddhi-io-file extension is an extension to Siddhi which is used to receive/publish event data from/to file. It supports both binary and text formats.    io-http  The siddhi-io-http extension is an extension to Siddhi that allows you to receive and publish events via http and https transports and also allow you perform synchronous request and response. This extension works with WSO2 Stream Processor and with standalone Siddhi.    io-jms  The siddhi-io-jms extension is an extension to Siddhi that used to receive and publishe events via JMS Message. This extension allows users to subscribe to a JMS broker and receive/publish JMS messages.    io-kafka  The siddhi-io-kafka extension is an extension to Siddhi. This implements siddhi kafka source and sink that can be used to receive events from a kafka cluster and to publish events to a kafka cluster.    io-mqtt  The siddhi-io-mqtt is an extension to Siddhi mqtt source and sink implementation,that publish and receive events from mqtt broker.    io-prometheus  The siddhi-io-prometheus extension is an extension to Siddhi. The Prometheus-sink publishes Siddhi events as Prometheus metrics and expose them to Prometheus server. The Prometheus-source retrieves Prometheus metrics from an endpoint and send them as Siddhi events.    io-rabbitmq  The siddhi-io-rabbitmq is an extension to Siddhi that publish and receive events from rabbitmq broker.    io-sqs  The siddhi-io-sqs extension is an extension to Siddhi that used to receive and publish events via AWS SQS Service. This extension allows users to subscribe to a SQS queue and receive/publish SQS messages.    io-tcp  The siddhi-io-tcp extension is an extension to Siddhi that allows to receive and publish events through TCP.    io-twitter  The siddhi-io-twitter extension is an extension to Siddhi. It publishes event data from Twitter Applications in the key-value map format.    io-websocket  The siddhi-io-websocket extension is an extension to Siddhi that allows to receive and publish events through WebSocket.    io-wso2event  The siddhi-io-wso2event extension is an extension to Siddhi that receives and publishes events in the WSO2Event format via Thrift or Binary protocols.    map-binary  The siddhi-map-binary extension is an extension to Siddhi that can be used to convert binary events to/from Siddhi events.    map-csv  The siddhi-map-csv extension is an extension to Siddhi that supports mapping incoming events with csv format to a stream at the source, and mapping a stream to csv format events at the sink.    map-json  The siddhi-map-json extension is an extension to Siddhi which is used to convert JSON message to/from Siddhi events.    map-keyvalue  The siddhi-map-keyvalue extension is an extension to Siddhi that supports mapping incoming events with Key-Value map format to a stream at the source, and mapping a stream to Key-Value map events at the sink.    map-text  The siddhi-map-text extension is an extension to Siddhi that supports mapping incoming text messages to a stream at the source, and mapping a stream to text messages at the sink.    map-wso2event  The siddhi-map-wso2event extension is an extension to Siddhi that can be used to convert WSO2 events to/from Siddhi events.    map-xml  The siddhi-map-xml extension is an extension to Siddhi that supports mapping incoming XML events to a stream at the source, and mapping a stream to XML events at the sink.    script-js  The siddhi-script-js is an extension to Siddhi that allows to include JavaScript functions within the Siddhi Query Language.    store-cassandra  The siddhi-store-cassandra extension is an extension to Siddhi that can be used to persist events to a Cassandra instance of the users choice. Find some useful links below:    store-hbase  The siddhi-store-hbase extension is an extension to Siddhi that can be used to persist events to a HBase instance of the users choice. Find some useful links below:    store-mongodb  The siddhi-store-mongodb extension is an extension to Siddhi that can be used to persist events to a MongoDB instance of the users choice. Find some useful links below:    store-rdbms  The siddhi-store-rdbms extension is an extension to Siddhi that can be used to persist events to an RDBMS instance of the user's choice.    store-redis  The siddhi-store-redis extension is an extension for siddhi redis event table implementation. This extension can be used to persist events to a redis cloud instance of version 4.x.x.    store-solr  The siddhi-store-solr extension is an extension for siddhi Solr event table implementation. This extension can be used to persist events to a Solr cloud instance of version 6.x.x.", 
            "title": "Extensions released under Apache 2.0 License"
        }, 
        {
            "location": "/extensions/#extensions-released-under-gpl-license", 
            "text": "Name  Description      execution-geo  The siddhi-gpl-execution-geo extension is an extension to Siddhi that provides geo data related functionality such as checking whether a given geo coordinate is within a predefined geo-fence, etc. Following are the functions of the Geo extension.    execution-nlp  The siddhi-gpl-execution-nlp extension is an extension to Siddhi that can be used to process natural language.    execution-pmml  The siddhi-gpl-execution-pmml extension is an extension to Siddhi that can be used to process texts based on a PMML processing model.    execution-r  The siddhi-gpl-execution-r extension is an extension to Siddhi that can be used to process events with R scripts.    execution-streamingml  The siddhi-execution-streamingml is an extension to Siddhi that performs streaming machine learning on event streams.", 
            "title": "Extensions released under GPL License"
        }, 
        {
            "location": "/extensions/#extension-repositories", 
            "text": "All the extension repositories maintained by WSO2 can be found  here", 
            "title": "Extension Repositories"
        }, 
        {
            "location": "/api/5.0.0/", 
            "text": "API Docs - v5.0.0\n\n\nCore\n\n\nand \n(Aggregate Function)\n\n\nReturns the results of AND operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n and(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be AND operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nThis returns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe object for which the number of distinct occurences needs to be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns '3' when the available values are as follows.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\nThe three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nor \n(Aggregate Function)\n\n\nReturns the results of OR operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n or(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be OR operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nunionSet \n(Aggregate Function)\n\n\nUnion multiple sets. \nThis attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.\n\n\n\nSyntax\n\n\nOBJECT\n unionSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe java.util.Set object that needs to be added into the union set.\n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;\n\n\n\n\n\ndistinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncreateSet \n(Function)\n\n\nIncludes the given input parameter in a java.util.HashSet and returns the set. \n\n\n\nSyntax\n\n\nOBJECT\n createSet(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n input)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ninput\n\n        \nThe input that needs to be added into the set.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;\n\n\n\n\n\nFor every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\nsizeOfSet \n(Function)\n\n\nReturns the size of an object of type java.util.Set.\n\n\n\nSyntax\n\n\nINT\n sizeOfSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi. \n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;\n\n\n\n\n\nThe sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger logs the message on the given priority with or without processed event.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE).\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis message will be logged.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nTo log the processed event.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\nbatch \n(Window)\n\n\nA window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches. If it has the parameter length specified, then batch window process the batch as several chunks.\n\n\n\nSyntax\n\n\nbatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe length of a chunk\n\n        \nIf length value was not given it assign 0 as length and process the whole batch as once\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;\n\n\n\n\n\nThis will output comma separated items IDs that have the same price for each incoming batch of events.\n\n\n\ncron \n(Window)\n\n\nThis window outputs the arriving events as and when they arrive, and resets (expires) the window periodically based on the given cron expression.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that resets the window.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\n\n@info(name = \nquery1\n)\nfrom InputEventStream#cron(\n*/5 * * * * ?\n)\nselect symbol, sum(price) as totalPrice \ninsert into OutputStream;\n\n\n\n\n\nThis let the totalPrice to gradually increase and resets to zero as a batch every 5 seconds.\n\n\n\nEXAMPLE 2\n\n\ndefine stream StockEventStream (symbol string, price float, volume int)\ndefine window StockEventWindow (symbol string, price float, volume int) cron(\n*/5 * * * * ?\n);\n\n@info(name = \nquery0\n)\nfrom StockEventStream\ninsert into StockEventWindow;\n\n@info(name = \nquery1\n)\nfrom StockEventWindow \nselect symbol, sum(price) as totalPrice\ninsert into OutputStream ;\n\n\n\n\n\nThe defined window will let the totalPrice to gradually increase and resets to zero as a batch every 5 seconds.\n\n\n\ndelay \n(Window)\n\n\nA delay window holds events for a specific time period that is regarded as a delay period before processing them.\n\n\n\nSyntax\n\n\ndelay(\nINT|LONG|TIME\n window.delay)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.delay\n\n        \nThe time period (specified in sec, min, ms) for which  the window should delay the events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name=\nquery1\n) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name=\nquery2\n) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;\n\n\n\n\n\nIn this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last 'window.length' events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window StockEventWindow (symbol string, price float, volume int) length(10) output all events;\n\n@info(name = \nquery0\n)\nfrom StockEventStream\ninsert into StockEventWindow;\n@info(name = \nquery1\n)\n\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will process last 10 events in a sliding manner.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds and process a number of events as specified in the window.length.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length, \nBOOL\n stream.current.event)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstream.current.event\n\n        \nLet the window stream the current events out as and when they arrive to the window while expiring them in batches.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\n\n@info(name = \nquery1\n)\nfrom InputEventStream#lengthBatch(10)\nselect symbol, sum(price) as price \ninsert into OutputStream;\n\n\n\n\n\nThis collect and process 10 events as a batch and output them.\n\n\n\nEXAMPLE 2\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\n\n@info(name = \nquery1\n)\nfrom InputEventStream#lengthBatch(10, true)\nselect symbol, sum(price) as sumPrice \ninsert into OutputStream;\n\n\n\n\n\nThis window sends the arriving events directly to the output letting the \nsumPrice\n to increase gradually, after every 10 events it clears the window as a batch and resets the \nsumPrice\n to zero.\n\n\n\nEXAMPLE 3\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\ndefine window StockEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom InputEventStream\ninsert into StockEventWindow;\n\n@info(name = \nquery1\n)\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into OutputStream ;\n\n\n\n\n\nThis uses an defined window to process 10 events  as a batch and output all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsession \n(Window)\n\n\nThis is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key.\nThere can be out of order and late arrival of events, these events can arrive after the session is expired, to include those events to the matching session key specify a latency time period that is less than the session gap period.To have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.\n\n\n\nSyntax\n\n\nsession(\nINT|LONG|TIME\n window.session, \nSTRING\n window.key, \nINT|LONG|TIME\n window.allowedlatency)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.session\n\n        \nThe time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.key\n\n        \nThe grouping attribute for events.\n\n        \ndefault-key\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.allowedlatency\n\n        \nThis specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter).\n\n        \n0\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name=\nquery0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;\n\n\n\n\n\nThis query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds and process events that arrive during 'window.time' period as a batch.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time, \nBOOL\n stream.current.event)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period in which the window process the events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nstream.current.event\n\n        \nLet the window stream the current events out as and when they arrive to the window while expiring them in batches.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\n\n@info(name = \nquery1\n)\nfrom InputEventStream#timeBatch(20 sec)\nselect symbol, sum(price) as price \ninsert into OutputStream;\n\n\n\n\n\nThis collect and process incoming events as a batch every 20 seconds and output them.\n\n\n\nEXAMPLE 2\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\n\n@info(name = \nquery1\n)\nfrom InputEventStream#timeBatch(20 sec, true)\nselect symbol, sum(price) as sumPrice \ninsert into OutputStream;\n\n\n\n\n\nThis window sends the arriving events directly to the output letting the \nsumPrice\n to increase gradually and on every 20 second interval it clears the window as a batch resetting the \nsumPrice\n to zero.\n\n\n\nEXAMPLE 3\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\ndefine window StockEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom InputEventStream\ninsert into StockEventWindow;\n\n@info(name = \nquery1\n)\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into OutputStream ;\n\n\n\n\n\nThis uses an defined window to process events arrived every 20 seconds as a batch and output all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "5.0.0"
        }, 
        {
            "location": "/api/5.0.0/#api-docs-v500", 
            "text": "", 
            "title": "API Docs - v5.0.0"
        }, 
        {
            "location": "/api/5.0.0/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/5.0.0/#and-aggregate-function", 
            "text": "Returns the results of AND operation for all the events.  Syntax  BOOL  and( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be AND operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "and (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#distinctcount-aggregate-function", 
            "text": "This returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The object for which the number of distinct occurences needs to be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns '3' when the available values are as follows. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" The three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#or-aggregate-function", 
            "text": "Returns the results of OR operation for all the events.  Syntax  BOOL  or( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be OR operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "or (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#unionset-aggregate-function", 
            "text": "Union multiple sets.  This attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.  Syntax  OBJECT  unionSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The java.util.Set object that needs to be added into the union set. \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;  distinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.", 
            "title": "unionSet (Aggregate Function)"
        }, 
        {
            "location": "/api/5.0.0/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/5.0.0/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/5.0.0/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/5.0.0/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/5.0.0/#createset-function", 
            "text": "Includes the given input parameter in a java.util.HashSet and returns the set.   Syntax  OBJECT  createSet( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  input)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         input \n         The input that needs to be added into the set. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;  For every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.", 
            "title": "createSet (Function)"
        }, 
        {
            "location": "/api/5.0.0/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/5.0.0/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/5.0.0/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/5.0.0/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/5.0.0/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/5.0.0/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/5.0.0/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/5.0.0/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/5.0.0/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/5.0.0/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/5.0.0/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/5.0.0/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/5.0.0/#sizeofset-function", 
            "text": "Returns the size of an object of type java.util.Set.  Syntax  INT  sizeOfSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi.  \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;  The sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.", 
            "title": "sizeOfSet (Function)"
        }, 
        {
            "location": "/api/5.0.0/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/5.0.0/#log-stream-processor", 
            "text": "The logger logs the message on the given priority with or without processed event.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE). \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         log.message \n         This message will be logged. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         To log the processed event. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/5.0.0/#batch-window", 
            "text": "A window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches. If it has the parameter length specified, then batch window process the batch as several chunks.  Syntax  batch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The length of a chunk \n         If length value was not given it assign 0 as length and process the whole batch as once \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;  This will output comma separated items IDs that have the same price for each incoming batch of events.", 
            "title": "batch (Window)"
        }, 
        {
            "location": "/api/5.0.0/#cron-window", 
            "text": "This window outputs the arriving events as and when they arrive, and resets (expires) the window periodically based on the given cron expression.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that resets the window. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define stream InputEventStream (symbol string, price float, volume int);\n\n@info(name =  query1 )\nfrom InputEventStream#cron( */5 * * * * ? )\nselect symbol, sum(price) as totalPrice \ninsert into OutputStream;  This let the totalPrice to gradually increase and resets to zero as a batch every 5 seconds.  EXAMPLE 2  define stream StockEventStream (symbol string, price float, volume int)\ndefine window StockEventWindow (symbol string, price float, volume int) cron( */5 * * * * ? );\n\n@info(name =  query0 )\nfrom StockEventStream\ninsert into StockEventWindow;\n\n@info(name =  query1 )\nfrom StockEventWindow \nselect symbol, sum(price) as totalPrice\ninsert into OutputStream ;  The defined window will let the totalPrice to gradually increase and resets to zero as a batch every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/5.0.0/#delay-window", 
            "text": "A delay window holds events for a specific time period that is regarded as a delay period before processing them.  Syntax  delay( INT|LONG|TIME  window.delay)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.delay \n         The time period (specified in sec, min, ms) for which  the window should delay the events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name= query1 ) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name= query2 ) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;  In this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.", 
            "title": "delay (Window)"
        }, 
        {
            "location": "/api/5.0.0/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/5.0.0/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/5.0.0/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/5.0.0/#length-window", 
            "text": "A sliding length window that holds the last 'window.length' events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window StockEventWindow (symbol string, price float, volume int) length(10) output all events;\n\n@info(name =  query0 )\nfrom StockEventStream\ninsert into StockEventWindow;\n@info(name =  query1 )\n\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will process last 10 events in a sliding manner.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/5.0.0/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds and process a number of events as specified in the window.length.  Syntax  lengthBatch( INT  window.length,  BOOL  stream.current.event)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n     \n     \n         stream.current.event \n         Let the window stream the current events out as and when they arrive to the window while expiring them in batches. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream InputEventStream (symbol string, price float, volume int);\n\n@info(name =  query1 )\nfrom InputEventStream#lengthBatch(10)\nselect symbol, sum(price) as price \ninsert into OutputStream;  This collect and process 10 events as a batch and output them.  EXAMPLE 2  define stream InputEventStream (symbol string, price float, volume int);\n\n@info(name =  query1 )\nfrom InputEventStream#lengthBatch(10, true)\nselect symbol, sum(price) as sumPrice \ninsert into OutputStream;  This window sends the arriving events directly to the output letting the  sumPrice  to increase gradually, after every 10 events it clears the window as a batch and resets the  sumPrice  to zero.  EXAMPLE 3  define stream InputEventStream (symbol string, price float, volume int);\ndefine window StockEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom InputEventStream\ninsert into StockEventWindow;\n\n@info(name =  query1 )\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into OutputStream ;  This uses an defined window to process 10 events  as a batch and output all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/5.0.0/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/5.0.0/#session-window", 
            "text": "This is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key. There can be out of order and late arrival of events, these events can arrive after the session is expired, to include those events to the matching session key specify a latency time period that is less than the session gap period.To have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.  Syntax  session( INT|LONG|TIME  window.session,  STRING  window.key,  INT|LONG|TIME  window.allowedlatency)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.session \n         The time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.key \n         The grouping attribute for events. \n         default-key \n         STRING \n         Yes \n         No \n     \n     \n         window.allowedlatency \n         This specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter). \n         0 \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name= query0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;  This query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.", 
            "title": "session (Window)"
        }, 
        {
            "location": "/api/5.0.0/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/5.0.0/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/5.0.0/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds and process events that arrive during 'window.time' period as a batch.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time,  BOOL  stream.current.event)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period in which the window process the events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n     \n     \n         stream.current.event \n         Let the window stream the current events out as and when they arrive to the window while expiring them in batches. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream InputEventStream (symbol string, price float, volume int);\n\n@info(name =  query1 )\nfrom InputEventStream#timeBatch(20 sec)\nselect symbol, sum(price) as price \ninsert into OutputStream;  This collect and process incoming events as a batch every 20 seconds and output them.  EXAMPLE 2  define stream InputEventStream (symbol string, price float, volume int);\n\n@info(name =  query1 )\nfrom InputEventStream#timeBatch(20 sec, true)\nselect symbol, sum(price) as sumPrice \ninsert into OutputStream;  This window sends the arriving events directly to the output letting the  sumPrice  to increase gradually and on every 20 second interval it clears the window as a batch resetting the  sumPrice  to zero.  EXAMPLE 3  define stream InputEventStream (symbol string, price float, volume int);\ndefine window StockEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom InputEventStream\ninsert into StockEventWindow;\n\n@info(name =  query1 )\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into OutputStream ;  This uses an defined window to process events arrived every 20 seconds as a batch and output all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/5.0.0/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/5.0.0/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/5.0.0/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/5.0.0/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/5.0.0/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/5.0.0/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/5.0.0/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/5.0.0/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/5.0.0/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/5.0.0/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.4.8/", 
            "text": "API Docs - v4.4.8\n\n\nCore\n\n\nand \n(Aggregate Function)\n\n\nReturns the results of AND operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n and(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be AND operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nThis returns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe object for which the number of distinct occurences needs to be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns '3' when the available values are as follows.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\nThe three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nor \n(Aggregate Function)\n\n\nReturns the results of OR operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n or(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be OR operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nunionSet \n(Aggregate Function)\n\n\nUnion multiple sets. \nThis attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.\n\n\n\nSyntax\n\n\nOBJECT\n unionSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe java.util.Set object that needs to be added into the union set.\n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;\n\n\n\n\n\ndistinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncreateSet \n(Function)\n\n\nIncludes the given input parameter in a java.util.HashSet and returns the set. \n\n\n\nSyntax\n\n\nOBJECT\n createSet(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n input)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ninput\n\n        \nThe input that needs to be added into the set.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;\n\n\n\n\n\nFor every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\nsizeOfSet \n(Function)\n\n\nReturns the size of an object of type java.util.Set.\n\n\n\nSyntax\n\n\nINT\n sizeOfSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi. \n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;\n\n\n\n\n\nThe sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger logs the message on the given priority with or without processed event.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE).\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis message will be logged.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nTo log the processed event.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\nbatch \n(Window)\n\n\nA window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.\n\n\n\nSyntax\n\n\nbatch()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;\n\n\n\n\n\nThis will output comma separated items IDs that have the same price for each incoming batch of events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\ndelay \n(Window)\n\n\nA delay window holds events for a specific time period that is regarded as a delay period before processing them.\n\n\n\nSyntax\n\n\ndelay(\nINT|LONG|TIME\n window.delay)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.delay\n\n        \nThe time period (specified in sec, min, ms) for which  the window should delay the events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name=\nquery1\n) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name=\nquery2\n) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;\n\n\n\n\n\nIn this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsession \n(Window)\n\n\nThis is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key.\nWhen performing aggregations for a specific session, you can include events with the matching session key that arrive after the session is expired if required. This is done by specifying a latency time period that is less than the session gap period.\nTo have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.\n\n\n\nSyntax\n\n\nsession(\nINT|LONG|TIME\n window.session, \nSTRING\n window.key, \nINT|LONG|TIME\n window.allowedlatency)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.session\n\n        \nThe time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.key\n\n        \nThe grouping attribute for events.\n\n        \ndefault-key\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.allowedlatency\n\n        \nThis specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter).\n\n        \n0\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name=\nquery0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;\n\n\n\n\n\nThis query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.4.8"
        }, 
        {
            "location": "/api/4.4.8/#api-docs-v448", 
            "text": "", 
            "title": "API Docs - v4.4.8"
        }, 
        {
            "location": "/api/4.4.8/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.4.8/#and-aggregate-function", 
            "text": "Returns the results of AND operation for all the events.  Syntax  BOOL  and( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be AND operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "and (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#distinctcount-aggregate-function", 
            "text": "This returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The object for which the number of distinct occurences needs to be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns '3' when the available values are as follows. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" The three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#or-aggregate-function", 
            "text": "Returns the results of OR operation for all the events.  Syntax  BOOL  or( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be OR operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "or (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#unionset-aggregate-function", 
            "text": "Union multiple sets.  This attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.  Syntax  OBJECT  unionSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The java.util.Set object that needs to be added into the union set. \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;  distinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.", 
            "title": "unionSet (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.8/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.4.8/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.4.8/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.4.8/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.4.8/#createset-function", 
            "text": "Includes the given input parameter in a java.util.HashSet and returns the set.   Syntax  OBJECT  createSet( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  input)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         input \n         The input that needs to be added into the set. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;  For every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.", 
            "title": "createSet (Function)"
        }, 
        {
            "location": "/api/4.4.8/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.4.8/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.4.8/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.4.8/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.4.8/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.4.8/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.4.8/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.4.8/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.4.8/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.4.8/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.4.8/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.4.8/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.4.8/#sizeofset-function", 
            "text": "Returns the size of an object of type java.util.Set.  Syntax  INT  sizeOfSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi.  \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;  The sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.", 
            "title": "sizeOfSet (Function)"
        }, 
        {
            "location": "/api/4.4.8/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.4.8/#log-stream-processor", 
            "text": "The logger logs the message on the given priority with or without processed event.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE). \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         log.message \n         This message will be logged. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         To log the processed event. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.4.8/#batch-window", 
            "text": "A window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.  Syntax  batch()  Examples  EXAMPLE 1  define stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;  This will output comma separated items IDs that have the same price for each incoming batch of events.", 
            "title": "batch (Window)"
        }, 
        {
            "location": "/api/4.4.8/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.4.8/#delay-window", 
            "text": "A delay window holds events for a specific time period that is regarded as a delay period before processing them.  Syntax  delay( INT|LONG|TIME  window.delay)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.delay \n         The time period (specified in sec, min, ms) for which  the window should delay the events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name= query1 ) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name= query2 ) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;  In this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.", 
            "title": "delay (Window)"
        }, 
        {
            "location": "/api/4.4.8/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.4.8/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.4.8/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.4.8/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.4.8/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.4.8/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.4.8/#session-window", 
            "text": "This is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key. When performing aggregations for a specific session, you can include events with the matching session key that arrive after the session is expired if required. This is done by specifying a latency time period that is less than the session gap period. To have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.  Syntax  session( INT|LONG|TIME  window.session,  STRING  window.key,  INT|LONG|TIME  window.allowedlatency)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.session \n         The time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.key \n         The grouping attribute for events. \n         default-key \n         STRING \n         Yes \n         No \n     \n     \n         window.allowedlatency \n         This specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter). \n         0 \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name= query0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;  This query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.", 
            "title": "session (Window)"
        }, 
        {
            "location": "/api/4.4.8/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.4.8/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.4.8/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.4.8/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.4.8/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.4.8/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.4.8/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.4.8/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.4.8/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.4.8/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.4.8/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.4.8/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.4.8/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.4.0/", 
            "text": "API Docs - v4.4.0\n\n\nCore\n\n\nand \n(Aggregate Function)\n\n\nReturns the results of AND operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n and(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be AND operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nThis returns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe object for which the number of distinct occurences needs to be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns '3' when the available values are as follows.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\nThe three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nor \n(Aggregate Function)\n\n\nReturns the results of OR operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n or(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be OR operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nunionSet \n(Aggregate Function)\n\n\nUnion multiple sets. \nThis attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.\n\n\n\nSyntax\n\n\nOBJECT\n unionSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe java.util.Set object that needs to be added into the union set.\n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;\n\n\n\n\n\ndistinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncreateSet \n(Function)\n\n\nIncludes the given input parameter in a java.util.HashSet and returns the set. \n\n\n\nSyntax\n\n\nOBJECT\n createSet(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n input)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ninput\n\n        \nThe input that needs to be added into the set.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;\n\n\n\n\n\nFor every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\nsizeOfSet \n(Function)\n\n\nReturns the size of an object of type java.util.Set.\n\n\n\nSyntax\n\n\nINT\n sizeOfSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi. \n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;\n\n\n\n\n\nThe sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger logs the message on the given priority with or without processed event.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE).\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis message will be logged.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nTo log the processed event.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\nbatch \n(Window)\n\n\nA window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.\n\n\n\nSyntax\n\n\nbatch()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;\n\n\n\n\n\nThis will output comma separated items IDs that have the same price for each incoming batch of events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\ndelay \n(Window)\n\n\nA delay window holds events for a specific time period that is regarded as a delay period before processing them.\n\n\n\nSyntax\n\n\ndelay(\nINT|LONG|TIME\n window.delay)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.delay\n\n        \nThe time period (specified in sec, min, ms) for which  the window should delay the events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name=\nquery1\n) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name=\nquery2\n) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;\n\n\n\n\n\nIn this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsession \n(Window)\n\n\nThis is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key.\nWhen performing aggregations for a specific session, you can include events with the matching session key that arrive after the session is expired if required. This is done by specifying a latency time period that is less than the session gap period.\nTo have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.\n\n\n\nSyntax\n\n\nsession(\nINT|LONG|TIME\n window.session, \nSTRING\n window.key, \nINT|LONG|TIME\n window.allowedlatency)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.session\n\n        \nThe time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.key\n\n        \nThe grouping attribute for events.\n\n        \ndefault-key\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.allowedlatency\n\n        \nThis specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter).\n\n        \n0\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name=\nquery0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;\n\n\n\n\n\nThis query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.4.0"
        }, 
        {
            "location": "/api/4.4.0/#api-docs-v440", 
            "text": "", 
            "title": "API Docs - v4.4.0"
        }, 
        {
            "location": "/api/4.4.0/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.4.0/#and-aggregate-function", 
            "text": "Returns the results of AND operation for all the events.  Syntax  BOOL  and( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be AND operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "and (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#distinctcount-aggregate-function", 
            "text": "This returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The object for which the number of distinct occurences needs to be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns '3' when the available values are as follows. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" The three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#or-aggregate-function", 
            "text": "Returns the results of OR operation for all the events.  Syntax  BOOL  or( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be OR operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "or (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#unionset-aggregate-function", 
            "text": "Union multiple sets.  This attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.  Syntax  OBJECT  unionSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The java.util.Set object that needs to be added into the union set. \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;  distinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.", 
            "title": "unionSet (Aggregate Function)"
        }, 
        {
            "location": "/api/4.4.0/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.4.0/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.4.0/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.4.0/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.4.0/#createset-function", 
            "text": "Includes the given input parameter in a java.util.HashSet and returns the set.   Syntax  OBJECT  createSet( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  input)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         input \n         The input that needs to be added into the set. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;  For every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.", 
            "title": "createSet (Function)"
        }, 
        {
            "location": "/api/4.4.0/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.4.0/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.4.0/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.4.0/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.4.0/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.4.0/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.4.0/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.4.0/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.4.0/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.4.0/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.4.0/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.4.0/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.4.0/#sizeofset-function", 
            "text": "Returns the size of an object of type java.util.Set.  Syntax  INT  sizeOfSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi.  \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;  The sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.", 
            "title": "sizeOfSet (Function)"
        }, 
        {
            "location": "/api/4.4.0/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.4.0/#log-stream-processor", 
            "text": "The logger logs the message on the given priority with or without processed event.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE). \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         log.message \n         This message will be logged. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         To log the processed event. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.4.0/#batch-window", 
            "text": "A window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.  Syntax  batch()  Examples  EXAMPLE 1  define stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;  This will output comma separated items IDs that have the same price for each incoming batch of events.", 
            "title": "batch (Window)"
        }, 
        {
            "location": "/api/4.4.0/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.4.0/#delay-window", 
            "text": "A delay window holds events for a specific time period that is regarded as a delay period before processing them.  Syntax  delay( INT|LONG|TIME  window.delay)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.delay \n         The time period (specified in sec, min, ms) for which  the window should delay the events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name= query1 ) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name= query2 ) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;  In this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.", 
            "title": "delay (Window)"
        }, 
        {
            "location": "/api/4.4.0/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.4.0/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.4.0/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.4.0/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.4.0/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.4.0/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.4.0/#session-window", 
            "text": "This is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key. When performing aggregations for a specific session, you can include events with the matching session key that arrive after the session is expired if required. This is done by specifying a latency time period that is less than the session gap period. To have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.  Syntax  session( INT|LONG|TIME  window.session,  STRING  window.key,  INT|LONG|TIME  window.allowedlatency)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.session \n         The time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.key \n         The grouping attribute for events. \n         default-key \n         STRING \n         Yes \n         No \n     \n     \n         window.allowedlatency \n         This specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter). \n         0 \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name= query0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;  This query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.", 
            "title": "session (Window)"
        }, 
        {
            "location": "/api/4.4.0/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.4.0/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.4.0/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.4.0/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.4.0/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.4.0/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.4.0/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.4.0/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.4.0/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.4.0/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.4.0/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.4.0/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.4.0/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.3.19/", 
            "text": "API Docs - v4.3.19\n\n\nCore\n\n\nand \n(Aggregate Function)\n\n\nReturns the results of AND operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n and(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be AND operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nThis returns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe object for which the number of distinct occurences needs to be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns '3' when the available values are as follows.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\nThe three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nor \n(Aggregate Function)\n\n\nReturns the results of OR operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n or(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be OR operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nunionSet \n(Aggregate Function)\n\n\nUnion multiple sets. \nThis attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.\n\n\n\nSyntax\n\n\nOBJECT\n unionSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe java.util.Set object that needs to be added into the union set.\n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;\n\n\n\n\n\ndistinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncreateSet \n(Function)\n\n\nIncludes the given input parameter in a java.util.HashSet and returns the set. \n\n\n\nSyntax\n\n\nOBJECT\n createSet(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n input)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ninput\n\n        \nThe input that needs to be added into the set.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;\n\n\n\n\n\nFor every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\nsizeOfSet \n(Function)\n\n\nReturns the size of an object of type java.util.Set.\n\n\n\nSyntax\n\n\nINT\n sizeOfSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi. \n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;\n\n\n\n\n\nThe sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger logs the message on the given priority with or without processed event.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE).\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis message will be logged.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nTo log the processed event.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\nbatch \n(Window)\n\n\nA window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.\n\n\n\nSyntax\n\n\nbatch()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;\n\n\n\n\n\nThis will output comma separated items IDs that have the same price for each incoming batch of events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\ndelay \n(Window)\n\n\nA delay window holds events for a specific time period that is regarded as a delay period before processing them.\n\n\n\nSyntax\n\n\ndelay(\nINT|LONG|TIME\n window.delay)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.delay\n\n        \nThe time period (specified in sec, min, ms) for which  the window should delay the events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name=\nquery1\n) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name=\nquery2\n) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;\n\n\n\n\n\nIn this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsession \n(Window)\n\n\nThis is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key.\nWhen performing aggregations for a specific session, you can include events with the matching session key that arrive after the session is expired if required. This is done by specifying a latency time period that is less than the session gap period.\nTo have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.\n\n\n\nSyntax\n\n\nsession(\nINT|LONG|TIME\n window.session, \nSTRING\n window.key, \nINT|LONG|TIME\n window.allowedlatency)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.session\n\n        \nThe time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.key\n\n        \nThe grouping attribute for events.\n\n        \ndefault-key\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.allowedlatency\n\n        \nThis specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter).\n\n        \n0\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name=\nquery0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;\n\n\n\n\n\nThis query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.3.19"
        }, 
        {
            "location": "/api/4.3.19/#api-docs-v4319", 
            "text": "", 
            "title": "API Docs - v4.3.19"
        }, 
        {
            "location": "/api/4.3.19/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.3.19/#and-aggregate-function", 
            "text": "Returns the results of AND operation for all the events.  Syntax  BOOL  and( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be AND operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "and (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#distinctcount-aggregate-function", 
            "text": "This returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The object for which the number of distinct occurences needs to be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns '3' when the available values are as follows. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" The three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#or-aggregate-function", 
            "text": "Returns the results of OR operation for all the events.  Syntax  BOOL  or( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be OR operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "or (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#unionset-aggregate-function", 
            "text": "Union multiple sets.  This attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.  Syntax  OBJECT  unionSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The java.util.Set object that needs to be added into the union set. \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;  distinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.", 
            "title": "unionSet (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.19/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.3.19/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.3.19/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.3.19/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.3.19/#createset-function", 
            "text": "Includes the given input parameter in a java.util.HashSet and returns the set.   Syntax  OBJECT  createSet( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  input)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         input \n         The input that needs to be added into the set. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;  For every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.", 
            "title": "createSet (Function)"
        }, 
        {
            "location": "/api/4.3.19/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.3.19/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.3.19/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.3.19/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.3.19/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.3.19/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.3.19/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.3.19/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.3.19/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.3.19/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.3.19/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.3.19/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.3.19/#sizeofset-function", 
            "text": "Returns the size of an object of type java.util.Set.  Syntax  INT  sizeOfSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi.  \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;  The sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.", 
            "title": "sizeOfSet (Function)"
        }, 
        {
            "location": "/api/4.3.19/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.3.19/#log-stream-processor", 
            "text": "The logger logs the message on the given priority with or without processed event.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE). \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         log.message \n         This message will be logged. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         To log the processed event. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.3.19/#batch-window", 
            "text": "A window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.  Syntax  batch()  Examples  EXAMPLE 1  define stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;  This will output comma separated items IDs that have the same price for each incoming batch of events.", 
            "title": "batch (Window)"
        }, 
        {
            "location": "/api/4.3.19/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.3.19/#delay-window", 
            "text": "A delay window holds events for a specific time period that is regarded as a delay period before processing them.  Syntax  delay( INT|LONG|TIME  window.delay)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.delay \n         The time period (specified in sec, min, ms) for which  the window should delay the events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name= query1 ) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name= query2 ) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;  In this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.", 
            "title": "delay (Window)"
        }, 
        {
            "location": "/api/4.3.19/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.3.19/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.3.19/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.3.19/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.3.19/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.3.19/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.3.19/#session-window", 
            "text": "This is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key. When performing aggregations for a specific session, you can include events with the matching session key that arrive after the session is expired if required. This is done by specifying a latency time period that is less than the session gap period. To have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.  Syntax  session( INT|LONG|TIME  window.session,  STRING  window.key,  INT|LONG|TIME  window.allowedlatency)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.session \n         The time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.key \n         The grouping attribute for events. \n         default-key \n         STRING \n         Yes \n         No \n     \n     \n         window.allowedlatency \n         This specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter). \n         0 \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name= query0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;  This query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.", 
            "title": "session (Window)"
        }, 
        {
            "location": "/api/4.3.19/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.3.19/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.3.19/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.3.19/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.3.19/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.3.19/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.3.19/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.3.19/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.3.19/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.3.19/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.3.19/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.3.19/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.3.19/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.3.0/", 
            "text": "API Docs - v4.3.0\n\n\nCore\n\n\nand \n(Aggregate Function)\n\n\nReturns the results of AND operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n and(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be AND operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nThis returns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe object for which the number of distinct occurences needs to be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns '3' when the available values are as follows.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\nThe three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nor \n(Aggregate Function)\n\n\nReturns the results of OR operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n or(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be OR operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nunionSet \n(Aggregate Function)\n\n\nUnion multiple sets. \nThis attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.\n\n\n\nSyntax\n\n\nOBJECT\n unionSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe java.util.Set object that needs to be added into the union set.\n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;\n\n\n\n\n\ndistinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncreateSet \n(Function)\n\n\nIncludes the given input parameter in a java.util.HashSet and returns the set. \n\n\n\nSyntax\n\n\nOBJECT\n createSet(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n input)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ninput\n\n        \nThe input that needs to be added into the set.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;\n\n\n\n\n\nFor every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\nsizeOfSet \n(Function)\n\n\nReturns the size of an object of type java.util.Set.\n\n\n\nSyntax\n\n\nINT\n sizeOfSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi. \n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;\n\n\n\n\n\nThe sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger logs the message on the given priority with or without processed event.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE).\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis message will be logged.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nTo log the processed event.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\nbatch \n(Window)\n\n\nA window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.\n\n\n\nSyntax\n\n\nbatch()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;\n\n\n\n\n\nThis will output comma separated items IDs that have the same price for each incoming batch of events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\ndelay \n(Window)\n\n\nA delay window holds events for a specific time period that is regarded as a delay period before processing them.\n\n\n\nSyntax\n\n\ndelay(\nINT|LONG|TIME\n window.delay)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.delay\n\n        \nThe time period (specified in sec, min, ms) for which  the window should delay the events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name=\nquery1\n) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name=\nquery2\n) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;\n\n\n\n\n\nIn this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsession \n(Window)\n\n\nThis is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key.\nWhen performing aggregations for a specific session, you can include events with the matching session key that arrive after the session is expired if required. This is done by specifying a latency time period that is less than the session gap period.\nTo have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.\n\n\n\nSyntax\n\n\nsession(\nINT|LONG|TIME\n window.session, \nSTRING\n window.key, \nINT|LONG|TIME\n window.allowedlatency)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.session\n\n        \nThe time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.key\n\n        \nThe grouping attribute for events.\n\n        \ndefault-key\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.allowedlatency\n\n        \nThis specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter).\n\n        \n0\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name=\nquery0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;\n\n\n\n\n\nThis query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.3.0"
        }, 
        {
            "location": "/api/4.3.0/#api-docs-v430", 
            "text": "", 
            "title": "API Docs - v4.3.0"
        }, 
        {
            "location": "/api/4.3.0/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.3.0/#and-aggregate-function", 
            "text": "Returns the results of AND operation for all the events.  Syntax  BOOL  and( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be AND operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "and (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#distinctcount-aggregate-function", 
            "text": "This returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The object for which the number of distinct occurences needs to be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns '3' when the available values are as follows. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" The three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#or-aggregate-function", 
            "text": "Returns the results of OR operation for all the events.  Syntax  BOOL  or( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be OR operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "or (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#unionset-aggregate-function", 
            "text": "Union multiple sets.  This attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.  Syntax  OBJECT  unionSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The java.util.Set object that needs to be added into the union set. \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;  distinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.", 
            "title": "unionSet (Aggregate Function)"
        }, 
        {
            "location": "/api/4.3.0/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.3.0/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.3.0/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.3.0/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.3.0/#createset-function", 
            "text": "Includes the given input parameter in a java.util.HashSet and returns the set.   Syntax  OBJECT  createSet( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  input)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         input \n         The input that needs to be added into the set. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;  For every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.", 
            "title": "createSet (Function)"
        }, 
        {
            "location": "/api/4.3.0/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.3.0/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.3.0/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.3.0/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.3.0/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.3.0/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.3.0/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.3.0/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.3.0/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.3.0/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.3.0/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.3.0/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.3.0/#sizeofset-function", 
            "text": "Returns the size of an object of type java.util.Set.  Syntax  INT  sizeOfSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi.  \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;  The sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.", 
            "title": "sizeOfSet (Function)"
        }, 
        {
            "location": "/api/4.3.0/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.3.0/#log-stream-processor", 
            "text": "The logger logs the message on the given priority with or without processed event.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE). \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         log.message \n         This message will be logged. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         To log the processed event. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.3.0/#batch-window", 
            "text": "A window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.  Syntax  batch()  Examples  EXAMPLE 1  define stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;  This will output comma separated items IDs that have the same price for each incoming batch of events.", 
            "title": "batch (Window)"
        }, 
        {
            "location": "/api/4.3.0/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.3.0/#delay-window", 
            "text": "A delay window holds events for a specific time period that is regarded as a delay period before processing them.  Syntax  delay( INT|LONG|TIME  window.delay)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.delay \n         The time period (specified in sec, min, ms) for which  the window should delay the events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name= query1 ) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name= query2 ) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;  In this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.", 
            "title": "delay (Window)"
        }, 
        {
            "location": "/api/4.3.0/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.3.0/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.3.0/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.3.0/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.3.0/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.3.0/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.3.0/#session-window", 
            "text": "This is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key. When performing aggregations for a specific session, you can include events with the matching session key that arrive after the session is expired if required. This is done by specifying a latency time period that is less than the session gap period. To have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.  Syntax  session( INT|LONG|TIME  window.session,  STRING  window.key,  INT|LONG|TIME  window.allowedlatency)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.session \n         The time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.key \n         The grouping attribute for events. \n         default-key \n         STRING \n         Yes \n         No \n     \n     \n         window.allowedlatency \n         This specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter). \n         0 \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name= query0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;  This query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.", 
            "title": "session (Window)"
        }, 
        {
            "location": "/api/4.3.0/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.3.0/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.3.0/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.3.0/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.3.0/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.3.0/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.3.0/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.3.0/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.3.0/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.3.0/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.3.0/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.3.0/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.3.0/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.2.40/", 
            "text": "API Docs - v4.2.40\n\n\nCore\n\n\nand \n(Aggregate Function)\n\n\nReturns the results of AND operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n and(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be AND operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nThis returns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe object for which the number of distinct occurences needs to be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns '3' when the available values are as follows.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\nThe three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nor \n(Aggregate Function)\n\n\nReturns the results of OR operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n or(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be OR operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nunionSet \n(Aggregate Function)\n\n\nUnion multiple sets. \nThis attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.\n\n\n\nSyntax\n\n\nOBJECT\n unionSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe java.util.Set object that needs to be added into the union set.\n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;\n\n\n\n\n\ndistinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncreateSet \n(Function)\n\n\nIncludes the given input parameter in a java.util.HashSet and returns the set. \n\n\n\nSyntax\n\n\nOBJECT\n createSet(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n input)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ninput\n\n        \nThe input that needs to be added into the set.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;\n\n\n\n\n\nFor every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\nsizeOfSet \n(Function)\n\n\nReturns the size of an object of type java.util.Set.\n\n\n\nSyntax\n\n\nINT\n sizeOfSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi. \n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;\n\n\n\n\n\nThe sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger logs the message on the given priority with or without processed event.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE).\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis message will be logged.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nTo log the processed event.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\nbatch \n(Window)\n\n\nA window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.\n\n\n\nSyntax\n\n\nbatch()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;\n\n\n\n\n\nThis will output comma separated items IDs that have the same price for each incoming batch of events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\ndelay \n(Window)\n\n\nA delay window holds events for a specific time period that is regarded as a delay period before processing them.\n\n\n\nSyntax\n\n\ndelay(\nINT|LONG|TIME\n window.delay)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.delay\n\n        \nThe time period (specified in sec, min, ms) for which  the window should delay the events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name=\nquery1\n) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name=\nquery2\n) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;\n\n\n\n\n\nIn this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsession \n(Window)\n\n\nThis is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key.\nWhen performing aggregations for a specific session, you can include events with the matching session key that arrive after the session is expired if required. This is done by specifying a latency time period that is less than the session gap period.\nTo have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.\n\n\n\nSyntax\n\n\nsession(\nINT|LONG|TIME\n window.session, \nSTRING\n window.key, \nINT|LONG|TIME\n window.allowedlatency)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.session\n\n        \nThe time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.key\n\n        \nThe grouping attribute for events.\n\n        \ndefault-key\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.allowedlatency\n\n        \nThis specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter).\n\n        \n0\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name=\nquery0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;\n\n\n\n\n\nThis query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.2.40"
        }, 
        {
            "location": "/api/4.2.40/#api-docs-v4240", 
            "text": "", 
            "title": "API Docs - v4.2.40"
        }, 
        {
            "location": "/api/4.2.40/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.2.40/#and-aggregate-function", 
            "text": "Returns the results of AND operation for all the events.  Syntax  BOOL  and( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be AND operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "and (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#distinctcount-aggregate-function", 
            "text": "This returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The object for which the number of distinct occurences needs to be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns '3' when the available values are as follows. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" The three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#or-aggregate-function", 
            "text": "Returns the results of OR operation for all the events.  Syntax  BOOL  or( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be OR operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "or (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#unionset-aggregate-function", 
            "text": "Union multiple sets.  This attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.  Syntax  OBJECT  unionSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The java.util.Set object that needs to be added into the union set. \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;  distinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.", 
            "title": "unionSet (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.40/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.2.40/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.2.40/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.2.40/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.2.40/#createset-function", 
            "text": "Includes the given input parameter in a java.util.HashSet and returns the set.   Syntax  OBJECT  createSet( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  input)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         input \n         The input that needs to be added into the set. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;  For every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.", 
            "title": "createSet (Function)"
        }, 
        {
            "location": "/api/4.2.40/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.2.40/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.2.40/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.2.40/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.2.40/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.2.40/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.2.40/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.2.40/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.2.40/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.2.40/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.2.40/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.2.40/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.2.40/#sizeofset-function", 
            "text": "Returns the size of an object of type java.util.Set.  Syntax  INT  sizeOfSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi.  \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;  The sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.", 
            "title": "sizeOfSet (Function)"
        }, 
        {
            "location": "/api/4.2.40/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.2.40/#log-stream-processor", 
            "text": "The logger logs the message on the given priority with or without processed event.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE). \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         log.message \n         This message will be logged. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         To log the processed event. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.2.40/#batch-window", 
            "text": "A window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.  Syntax  batch()  Examples  EXAMPLE 1  define stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;  This will output comma separated items IDs that have the same price for each incoming batch of events.", 
            "title": "batch (Window)"
        }, 
        {
            "location": "/api/4.2.40/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.2.40/#delay-window", 
            "text": "A delay window holds events for a specific time period that is regarded as a delay period before processing them.  Syntax  delay( INT|LONG|TIME  window.delay)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.delay \n         The time period (specified in sec, min, ms) for which  the window should delay the events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name= query1 ) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name= query2 ) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;  In this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.", 
            "title": "delay (Window)"
        }, 
        {
            "location": "/api/4.2.40/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.2.40/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.2.40/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.2.40/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.2.40/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.2.40/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.2.40/#session-window", 
            "text": "This is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key. When performing aggregations for a specific session, you can include events with the matching session key that arrive after the session is expired if required. This is done by specifying a latency time period that is less than the session gap period. To have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.  Syntax  session( INT|LONG|TIME  window.session,  STRING  window.key,  INT|LONG|TIME  window.allowedlatency)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.session \n         The time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.key \n         The grouping attribute for events. \n         default-key \n         STRING \n         Yes \n         No \n     \n     \n         window.allowedlatency \n         This specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter). \n         0 \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name= query0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;  This query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.", 
            "title": "session (Window)"
        }, 
        {
            "location": "/api/4.2.40/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.2.40/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.2.40/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.2.40/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.2.40/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.2.40/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.2.40/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.2.40/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.2.40/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.2.40/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.2.40/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.2.40/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.2.40/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.2.20/", 
            "text": "API Docs - v4.2.20\n\n\nCore\n\n\nand \n(Aggregate Function)\n\n\nReturns the results of AND operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n and(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be AND operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nThis returns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe object for which the number of distinct occurences needs to be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns '3' when the available values are as follows.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\nThe three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nor \n(Aggregate Function)\n\n\nReturns the results of OR operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n or(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be OR operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nunionSet \n(Aggregate Function)\n\n\nUnion multiple sets. \nThis attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.\n\n\n\nSyntax\n\n\nOBJECT\n unionSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe java.util.Set object that needs to be added into the union set.\n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;\n\n\n\n\n\ndistinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncreateSet \n(Function)\n\n\nIncludes the given input parameter in a java.util.HashSet and returns the set. \n\n\n\nSyntax\n\n\nOBJECT\n createSet(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n input)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ninput\n\n        \nThe input that needs to be added into the set.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;\n\n\n\n\n\nFor every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\nsizeOfSet \n(Function)\n\n\nReturns the size of an object of type java.util.Set.\n\n\n\nSyntax\n\n\nINT\n sizeOfSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi. \n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;\n\n\n\n\n\nThe sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger logs the message on the given priority with or without processed event.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE).\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis message will be logged.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nTo log the processed event.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\nbatch \n(Window)\n\n\nA window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.\n\n\n\nSyntax\n\n\nbatch()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;\n\n\n\n\n\nThis will output comma separated items IDs that have the same price for each incoming batch of events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.2.20"
        }, 
        {
            "location": "/api/4.2.20/#api-docs-v4220", 
            "text": "", 
            "title": "API Docs - v4.2.20"
        }, 
        {
            "location": "/api/4.2.20/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.2.20/#and-aggregate-function", 
            "text": "Returns the results of AND operation for all the events.  Syntax  BOOL  and( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be AND operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "and (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#distinctcount-aggregate-function", 
            "text": "This returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The object for which the number of distinct occurences needs to be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns '3' when the available values are as follows. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" The three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#or-aggregate-function", 
            "text": "Returns the results of OR operation for all the events.  Syntax  BOOL  or( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be OR operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "or (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#unionset-aggregate-function", 
            "text": "Union multiple sets.  This attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.  Syntax  OBJECT  unionSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The java.util.Set object that needs to be added into the union set. \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;  distinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.", 
            "title": "unionSet (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.20/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.2.20/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.2.20/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.2.20/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.2.20/#createset-function", 
            "text": "Includes the given input parameter in a java.util.HashSet and returns the set.   Syntax  OBJECT  createSet( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  input)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         input \n         The input that needs to be added into the set. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;  For every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.", 
            "title": "createSet (Function)"
        }, 
        {
            "location": "/api/4.2.20/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.2.20/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.2.20/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.2.20/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.2.20/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.2.20/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.2.20/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.2.20/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.2.20/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.2.20/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.2.20/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.2.20/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.2.20/#sizeofset-function", 
            "text": "Returns the size of an object of type java.util.Set.  Syntax  INT  sizeOfSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi.  \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;  The sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.", 
            "title": "sizeOfSet (Function)"
        }, 
        {
            "location": "/api/4.2.20/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.2.20/#log-stream-processor", 
            "text": "The logger logs the message on the given priority with or without processed event.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE). \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         log.message \n         This message will be logged. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         To log the processed event. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.2.20/#batch-window", 
            "text": "A window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.  Syntax  batch()  Examples  EXAMPLE 1  define stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;  This will output comma separated items IDs that have the same price for each incoming batch of events.", 
            "title": "batch (Window)"
        }, 
        {
            "location": "/api/4.2.20/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.2.20/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.2.20/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.2.20/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.2.20/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.2.20/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.2.20/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.2.20/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.2.20/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.2.20/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.2.20/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.2.20/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.2.20/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.2.20/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.2.20/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.2.20/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.2.20/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.2.20/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.2.20/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.2.20/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.2.0/", 
            "text": "API Docs - v4.2.0\n\n\nCore\n\n\nand \n(Aggregate Function)\n\n\nReturns the results of AND operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n and(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be AND operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nReturns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns 3.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nor \n(Aggregate Function)\n\n\nReturns the results of OR operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n or(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be OR operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nunionSet \n(Aggregate Function)\n\n\nUnion multiple sets. \nThis attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.\n\n\n\nSyntax\n\n\nOBJECT\n unionSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe java.util.Set object that needs to be added into the union set.\n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;\n\n\n\n\n\ndistinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncreateSet \n(Function)\n\n\nIncludes the given input parameter in a java.util.HashSet and returns the set. \n\n\n\nSyntax\n\n\nOBJECT\n createSet(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n input)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ninput\n\n        \nThe input that needs to be added into the set.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;\n\n\n\n\n\nFor every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\nsizeOfSet \n(Function)\n\n\nReturns the size of an object of type java.util.Set.\n\n\n\nSyntax\n\n\nINT\n sizeOfSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi. \n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;\n\n\n\n\n\nThe sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger logs the message on the given priority with or without processed event.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE).\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis message will be logged.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nTo log the processed event.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\nbatch \n(Window)\n\n\nA window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.\n\n\n\nSyntax\n\n\nbatch()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;\n\n\n\n\n\nThis will output comma separated items IDs that have the same price for each incoming batch of events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.2.0"
        }, 
        {
            "location": "/api/4.2.0/#api-docs-v420", 
            "text": "", 
            "title": "API Docs - v4.2.0"
        }, 
        {
            "location": "/api/4.2.0/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.2.0/#and-aggregate-function", 
            "text": "Returns the results of AND operation for all the events.  Syntax  BOOL  and( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be AND operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "and (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#distinctcount-aggregate-function", 
            "text": "Returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns 3. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\"", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#or-aggregate-function", 
            "text": "Returns the results of OR operation for all the events.  Syntax  BOOL  or( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be OR operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "or (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#unionset-aggregate-function", 
            "text": "Union multiple sets.  This attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.  Syntax  OBJECT  unionSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The java.util.Set object that needs to be added into the union set. \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;  distinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.", 
            "title": "unionSet (Aggregate Function)"
        }, 
        {
            "location": "/api/4.2.0/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.2.0/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.2.0/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.2.0/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.2.0/#createset-function", 
            "text": "Includes the given input parameter in a java.util.HashSet and returns the set.   Syntax  OBJECT  createSet( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  input)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         input \n         The input that needs to be added into the set. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;  For every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.", 
            "title": "createSet (Function)"
        }, 
        {
            "location": "/api/4.2.0/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.2.0/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.2.0/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.2.0/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.2.0/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.2.0/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.2.0/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.2.0/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.2.0/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.2.0/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.2.0/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.2.0/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.2.0/#sizeofset-function", 
            "text": "Returns the size of an object of type java.util.Set.  Syntax  INT  sizeOfSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi.  \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;  The sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.", 
            "title": "sizeOfSet (Function)"
        }, 
        {
            "location": "/api/4.2.0/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.2.0/#log-stream-processor", 
            "text": "The logger logs the message on the given priority with or without processed event.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE). \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         log.message \n         This message will be logged. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         To log the processed event. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.2.0/#batch-window", 
            "text": "A window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.  Syntax  batch()  Examples  EXAMPLE 1  define stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;  This will output comma separated items IDs that have the same price for each incoming batch of events.", 
            "title": "batch (Window)"
        }, 
        {
            "location": "/api/4.2.0/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.2.0/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.2.0/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.2.0/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.2.0/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.2.0/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.2.0/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.2.0/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.2.0/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.2.0/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.2.0/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.2.0/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.2.0/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.2.0/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.2.0/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.2.0/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.2.0/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.2.0/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.2.0/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.2.0/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.1.64/", 
            "text": "API Docs - v4.1.64\n\n\nCore\n\n\nand \n(Aggregate Function)\n\n\nReturns the results of AND operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n and(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be AND operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nReturns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns 3.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nor \n(Aggregate Function)\n\n\nReturns the results of OR operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n or(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be OR operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nunionSet \n(Aggregate Function)\n\n\nUnion multiple sets. \nThis attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.\n\n\n\nSyntax\n\n\nOBJECT\n unionSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe java.util.Set object that needs to be added into the union set.\n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;\n\n\n\n\n\ndistinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncreateSet \n(Function)\n\n\nIncludes the given input parameter in a java.util.HashSet and returns the set. \n\n\n\nSyntax\n\n\nOBJECT\n createSet(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n input)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ninput\n\n        \nThe input that needs to be added into the set.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;\n\n\n\n\n\nFor every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\nsizeOfSet \n(Function)\n\n\nReturns the size of an object of type java.util.Set.\n\n\n\nSyntax\n\n\nINT\n sizeOfSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi. \n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;\n\n\n\n\n\nThe sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger logs the message on the given priority with or without processed event.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE).\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis message will be logged.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nTo log the processed event.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\nbatch \n(Window)\n\n\nA window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.\n\n\n\nSyntax\n\n\nbatch()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;\n\n\n\n\n\nThis will output comma separated items IDs that have the same price for each incoming batch of events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.1.64"
        }, 
        {
            "location": "/api/4.1.64/#api-docs-v4164", 
            "text": "", 
            "title": "API Docs - v4.1.64"
        }, 
        {
            "location": "/api/4.1.64/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.1.64/#and-aggregate-function", 
            "text": "Returns the results of AND operation for all the events.  Syntax  BOOL  and( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be AND operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "and (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#distinctcount-aggregate-function", 
            "text": "Returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns 3. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\"", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#or-aggregate-function", 
            "text": "Returns the results of OR operation for all the events.  Syntax  BOOL  or( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be OR operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "or (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#unionset-aggregate-function", 
            "text": "Union multiple sets.  This attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.  Syntax  OBJECT  unionSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The java.util.Set object that needs to be added into the union set. \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;  distinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.", 
            "title": "unionSet (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.64/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.1.64/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.1.64/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.1.64/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.1.64/#createset-function", 
            "text": "Includes the given input parameter in a java.util.HashSet and returns the set.   Syntax  OBJECT  createSet( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  input)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         input \n         The input that needs to be added into the set. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;  For every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.", 
            "title": "createSet (Function)"
        }, 
        {
            "location": "/api/4.1.64/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.1.64/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.1.64/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.1.64/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.1.64/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.1.64/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.1.64/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.1.64/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.1.64/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.1.64/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.1.64/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.1.64/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.1.64/#sizeofset-function", 
            "text": "Returns the size of an object of type java.util.Set.  Syntax  INT  sizeOfSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi.  \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;  The sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.", 
            "title": "sizeOfSet (Function)"
        }, 
        {
            "location": "/api/4.1.64/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.1.64/#log-stream-processor", 
            "text": "The logger logs the message on the given priority with or without processed event.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE). \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         log.message \n         This message will be logged. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         To log the processed event. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.1.64/#batch-window", 
            "text": "A window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches.  Syntax  batch()  Examples  EXAMPLE 1  define stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;  This will output comma separated items IDs that have the same price for each incoming batch of events.", 
            "title": "batch (Window)"
        }, 
        {
            "location": "/api/4.1.64/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.1.64/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.1.64/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.1.64/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.1.64/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.1.64/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.1.64/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.1.64/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.1.64/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.1.64/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.1.64/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.1.64/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.1.64/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.1.64/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.1.64/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.1.64/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.1.64/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.1.64/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.1.64/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.1.64/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.1.46/", 
            "text": "API Docs - v4.1.46\n\n\nCore\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nReturns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns 3.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger logs the message on the given priority with or without processed event.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE).\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis message will be logged.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nTo log the processed event.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.1.46"
        }, 
        {
            "location": "/api/4.1.46/#api-docs-v4146", 
            "text": "", 
            "title": "API Docs - v4.1.46"
        }, 
        {
            "location": "/api/4.1.46/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.1.46/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.46/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.46/#distinctcount-aggregate-function", 
            "text": "Returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns 3. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\"", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.46/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.46/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.46/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.46/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.46/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.46/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.46/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.1.46/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.1.46/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.1.46/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.1.46/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.1.46/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.1.46/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.1.46/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.1.46/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.1.46/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.1.46/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.1.46/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.1.46/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.1.46/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.1.46/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.1.46/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.1.46/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.1.46/#log-stream-processor", 
            "text": "The logger logs the message on the given priority with or without processed event.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE). \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         log.message \n         This message will be logged. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         To log the processed event. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.1.46/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.1.46/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.1.46/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.1.46/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.1.46/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.1.46/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.1.46/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.1.46/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.1.46/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.1.46/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.1.46/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.1.46/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.1.46/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.1.46/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.1.46/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.1.46/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.1.46/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.1.46/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.1.46/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.1.46/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.1.7/", 
            "text": "API Docs - v4.1.7\n\n\nCore\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nReturns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns 3.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger stream processor logs the message with or without event for the given log priority.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis submit the log message.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nUse this command to enable the logging of one or more events.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.1.7"
        }, 
        {
            "location": "/api/4.1.7/#api-docs-v417", 
            "text": "", 
            "title": "API Docs - v4.1.7"
        }, 
        {
            "location": "/api/4.1.7/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.1.7/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.7/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.7/#distinctcount-aggregate-function", 
            "text": "Returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns 3. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\"", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.7/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.7/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.7/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.7/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.7/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.7/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.7/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.1.7/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.1.7/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.1.7/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.1.7/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.1.7/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.1.7/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.1.7/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.1.7/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.1.7/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.1.7/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.1.7/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.1.7/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.1.7/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.1.7/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.1.7/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.1.7/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.1.7/#log-stream-processor", 
            "text": "The logger stream processor logs the message with or without event for the given log priority.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message. \n         \n         STRING \n         No \n         No \n     \n     \n         log.message \n         This submit the log message. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         Use this command to enable the logging of one or more events. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.1.7/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.1.7/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.1.7/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.1.7/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.1.7/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.1.7/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.1.7/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.1.7/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.1.7/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.1.7/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.1.7/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.1.7/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.1.7/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.1.7/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.1.7/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.1.7/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.1.7/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.1.7/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.1.7/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.1.7/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.1.0/", 
            "text": "API Docs - v4.1.0\n\n\nCore\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nReturns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns 3.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger stream processor logs the message with or without event for the given log priority.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis submit the log message.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nUse this command to enable the logging of one or more events.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.1.0"
        }, 
        {
            "location": "/api/4.1.0/#api-docs-v410", 
            "text": "", 
            "title": "API Docs - v4.1.0"
        }, 
        {
            "location": "/api/4.1.0/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.1.0/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.0/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.0/#distinctcount-aggregate-function", 
            "text": "Returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns 3. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\"", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.0/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.0/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.0/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.0/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.0/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.0/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.1.0/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.1.0/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.1.0/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.1.0/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.1.0/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.1.0/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.1.0/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.1.0/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.1.0/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.1.0/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.1.0/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.1.0/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.1.0/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.1.0/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.1.0/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.1.0/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.1.0/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.1.0/#log-stream-processor", 
            "text": "The logger stream processor logs the message with or without event for the given log priority.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message. \n         \n         STRING \n         No \n         No \n     \n     \n         log.message \n         This submit the log message. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         Use this command to enable the logging of one or more events. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.1.0/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.1.0/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.1.0/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.1.0/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.1.0/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.1.0/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.1.0/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.1.0/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.1.0/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.1.0/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.1.0/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.1.0/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.1.0/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.1.0/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.1.0/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.1.0/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.1.0/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.1.0/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.1.0/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.1.0/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.0.9/", 
            "text": "API Docs - v4.0.9\n\n\nCore\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nReturns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns 3.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger stream processor logs the message with or without event for the given log priority.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis submit the log message.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nUse this command to enable the logging of one or more events.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 seconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.0.9"
        }, 
        {
            "location": "/api/4.0.9/#api-docs-v409", 
            "text": "", 
            "title": "API Docs - v4.0.9"
        }, 
        {
            "location": "/api/4.0.9/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.0.9/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.9/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.9/#distinctcount-aggregate-function", 
            "text": "Returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns 3. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\"", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.9/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.9/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.9/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.9/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.9/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.9/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.9/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.0.9/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.0.9/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.0.9/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.0.9/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.0.9/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.0.9/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.0.9/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.0.9/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.0.9/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.0.9/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.0.9/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.0.9/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.0.9/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.0.9/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.0.9/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.0.9/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.0.9/#log-stream-processor", 
            "text": "The logger stream processor logs the message with or without event for the given log priority.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message. \n         \n         STRING \n         No \n         No \n     \n     \n         log.message \n         This submit the log message. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         Use this command to enable the logging of one or more events. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.0.9/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.0.9/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.0.9/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.0.9/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.0.9/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.0.9/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.0.9/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.0.9/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.0.9/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.0.9/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 seconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.0.9/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.0.9/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.0.9/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.0.9/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.0.9/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.0.9/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.0.9/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.0.9/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.0.9/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.0.9/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/4.0.0/", 
            "text": "API Docs - v4.0.0\n\n\nCore\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nReturns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns 3.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger stream processor logs the message with or without event for the given log priority.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis submit the log message.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nUse this command to enable the logging of one or more events.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\ncron \n(Window)\n\n\nThis window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that represents a time schedule.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int)cron(\n*/5 * * * * ?\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;\n\n\n\n\n\nThis will processed events as the output every 5 seconds.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. When startTime is not given, initial value of timestamp is used as the default.\n\n        \n0\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. If timeout is not provided, system waits till an event from next batch arrives to flush current batch.\n\n        \n0\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events and out put all events.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing 10 events as a batch and out put all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) timeBatch(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events arrived every 20 milliseconds as a batch and out put all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n),\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "4.0.0"
        }, 
        {
            "location": "/api/4.0.0/#api-docs-v400", 
            "text": "", 
            "title": "API Docs - v4.0.0"
        }, 
        {
            "location": "/api/4.0.0/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/4.0.0/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.0/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.0/#distinctcount-aggregate-function", 
            "text": "Returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns 3. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\"", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.0/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.0/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.0/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.0/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.0/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.0/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/4.0.0/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/4.0.0/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/4.0.0/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/4.0.0/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/4.0.0/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/4.0.0/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/4.0.0/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/4.0.0/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/4.0.0/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/4.0.0/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/4.0.0/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/4.0.0/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/4.0.0/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/4.0.0/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/4.0.0/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/4.0.0/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/4.0.0/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/4.0.0/#log-stream-processor", 
            "text": "The logger stream processor logs the message with or without event for the given log priority.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message. \n         \n         STRING \n         No \n         No \n     \n     \n         log.message \n         This submit the log message. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         Use this command to enable the logging of one or more events. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/4.0.0/#cron-window", 
            "text": "This window returns events processed periodically as the output in time-repeating patterns, triggered based on time passing.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that represents a time schedule. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int)cron( */5 * * * * ? );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow \nselect symbol,price,volume\ninsert into outputStream ;  This will processed events as the output every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/4.0.0/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/4.0.0/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. When startTime is not given, initial value of timestamp is used as the default. \n         0 \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. If timeout is not provided, system waits till an event from next batch arrives to flush current batch. \n         0 \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/4.0.0/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/4.0.0/#length-window", 
            "text": "A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) length(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events and out put all events.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/4.0.0/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives.  Syntax  lengthBatch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing 10 events as a batch and out put all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/4.0.0/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/4.0.0/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/4.0.0/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/4.0.0/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds events that arrive during window.time periods, and gets updated for each window.time.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) timeBatch(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events arrived every 20 milliseconds as a batch and out put all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/4.0.0/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/4.0.0/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/4.0.0/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/4.0.0/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/4.0.0/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/4.0.0/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/4.0.0/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/4.0.0/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/4.0.0/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/4.0.0/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ),\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/api/latest/", 
            "text": "API Docs - v5.0.1-SNAPSHOT\n\n\nCore\n\n\nand \n(Aggregate Function)\n\n\nReturns the results of AND operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n and(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be AND operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\navg \n(Aggregate Function)\n\n\nCalculates the average for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n avg(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that need to be averaged.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;\n\n\n\n\n\navg(temp) returns the average temp value for all the events based on their arrival and expiry.\n\n\n\ncount \n(Aggregate Function)\n\n\nReturns the count of all the events.\n\n\n\nSyntax\n\n\nLONG\n count()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;\n\n\n\n\n\nThis will return the count of all the events for time batch in 10 seconds.\n\n\n\ndistinctCount \n(Aggregate Function)\n\n\nThis returns the count of distinct occurrences for a given arg.\n\n\n\nSyntax\n\n\nLONG\n distinctCount(\nINT|LONG|DOUBLE|FLOAT|STRING\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe object for which the number of distinct occurences needs to be counted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;\n\n\n\n\n\ndistinctcount(pageID) for the following output returns '3' when the available values are as follows.\n\"WEB_PAGE_1\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\n\"WEB_PAGE_3\"\n\"WEB_PAGE_1\"\n\"WEB_PAGE_2\"\nThe three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.\n\n\n\nmax \n(Aggregate Function)\n\n\nReturns the maximum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n max(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;\n\n\n\n\n\nmax(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nmaxForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maxForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the maximum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect maxForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nmaxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.\n\n\n\nmin \n(Aggregate Function)\n\n\nReturns the minimum value for all the events.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n min(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect min(temp) as minTemp\ninsert into outputStream;\n\n\n\n\n\nmin(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.\n\n\n\nminForever \n(Aggregate Function)\n\n\nThis is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minForever(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be compared to find the minimum value.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect minForever(temp) as max\ninsert into outputStream;\n\n\n\n\n\nminForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.\n\n\n\nor \n(Aggregate Function)\n\n\nReturns the results of OR operation for all the events.\n\n\n\nSyntax\n\n\nBOOL\n or(\nBOOL\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be OR operation.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;\n\n\n\n\n\nThis will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.\n\n\n\nstdDev \n(Aggregate Function)\n\n\nReturns the calculated standard deviation for all the events.\n\n\n\nSyntax\n\n\nDOUBLE\n stdDev(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that should be used to calculate the standard deviation.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;\n\n\n\n\n\nstddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.\n\n\n\nsum \n(Aggregate Function)\n\n\nReturns the sum for all the events.\n\n\n\nSyntax\n\n\nLONG|DOUBLE\n sum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe value that needs to be summed.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;\n\n\n\n\n\nThis will returns the sum of volume values as a long value for each event arrival and expiry.\n\n\n\nunionSet \n(Aggregate Function)\n\n\nUnion multiple sets. \nThis attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.\n\n\n\nSyntax\n\n\nOBJECT\n unionSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe java.util.Set object that needs to be added into the union set.\n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;\n\n\n\n\n\ndistinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.\n\n\n\nUUID \n(Function)\n\n\nGenerates a UUID (Universally Unique Identifier).\n\n\n\nSyntax\n\n\nSTRING\n UUID()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect convert(roomNo, \nstring\n) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\n\n\nThis will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8\nfrom TempStream\nselect convert(roomNo, 'string') as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;\n\n\n\ncast \n(Function)\n\n\nConverts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n cast(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n to.be.caster, \nSTRING\n cast.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.caster\n\n        \nThis specifies the attribute to be casted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ncast.to\n\n        \nA string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, cast(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will cast the fooStream temp field value into 'double' format.\n\n\n\ncoalesce \n(Function)\n\n\nReturns the value of the first input parameter that is not null, and all input parameters have to be on the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n coalesce(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n args)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nargs\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect coalesce(\n123\n, null, \n789\n) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 123.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns first null value 76.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;\n\n\n\n\n\nThis will returns null as there are no notnull values.\n\n\n\nconvert \n(Function)\n\n\nConverts the first input parameter according to the convertedTo parameter.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n convert(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n to.be.converted, \nSTRING\n converted.to)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nto.be.converted\n\n        \nThis specifies the value to be converted.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nconverted.to\n\n        \nA string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect convert(temp, \ndouble\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'double'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect convert(temp, \nint\n) as temp\ninsert into barStream;\n\n\n\n\n\nThis will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").\n\n\n\ncreateSet \n(Function)\n\n\nIncludes the given input parameter in a java.util.HashSet and returns the set. \n\n\n\nSyntax\n\n\nOBJECT\n createSet(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL\n input)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ninput\n\n        \nThe input that needs to be added into the set.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;\n\n\n\n\n\nFor every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.\n\n\n\ncurrentTimeMillis \n(Function)\n\n\nReturns the current timestamp of siddhi application in milliseconds.\n\n\n\nSyntax\n\n\nLONG\n currentTimeMillis()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current siddhi application timestamp.\n\n\n\ndefault \n(Function)\n\n\nChecks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n attribute, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n default)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that could be null.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndefault\n\n        \nThe default value that will be used when 'attribute' parameter is null\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;\n\n\n\n\n\nThis will replace TempStream's temp attribute with default value if the temp is null.\n\n\n\neventTimestamp \n(Function)\n\n\nReturns the timestamp of the processed event.\n\n\n\nSyntax\n\n\nLONG\n eventTimestamp()\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;\n\n\n\n\n\nThis will extract current events timestamp.\n\n\n\nifThenElse \n(Function)\n\n\nEvaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n ifThenElse(\nBOOL\n condition, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n if.expression, \nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n else.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncondition\n\n        \nThis specifies the if then else condition value.\n\n        \n\n        \nBOOL\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nif.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is true.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nelse.expression\n\n        \nThis specifies the value to be returned if the value of the condition parameter is false.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue\n35,\nHigh\n,\nLow\n) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns High if sensorValue = 50.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage \n 5, 0, 1) as status\ninsert into outputStream;\n\n\n\n\n\nThis will returns 1 if voltage= 12.\n\n\n\nEXAMPLE 3\n\n\n@info(name = \nquery1\n)\nfrom userEventStream\nselect userName, ifThenElse(password == \nadmin\n, true, false) as passwordState\ninsert into outputStream;\n\n\n\n\n\nThis will returns  passwordState as true if password = admin.\n\n\n\ninstanceOfBoolean \n(Function)\n\n\nChecks whether the parameter is an instance of Boolean or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfBoolean(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value of switchState is true.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;\n\n\n\n\n\nif the value = 32 then this will returns false as the value is not an instance of the boolean.\n\n\n\ninstanceOfDouble \n(Function)\n\n\nChecks whether the parameter is an instance of Double or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfDouble(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is double ex : 56.45.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is not an instance of the double.\n\n\n\ninstanceOfFloat \n(Function)\n\n\nChecks whether the parameter is an instance of Float or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfFloat(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is float ex : 56.45f.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a float.\n\n\n\ninstanceOfInteger \n(Function)\n\n\nChecks whether the parameter is an instance of Integer or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfInteger(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is integer.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfLong \n(Function)\n\n\nChecks whether the parameter is an instance of Long or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfLong(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is long ex : 56456l.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a long.\n\n\n\ninstanceOfString \n(Function)\n\n\nChecks whether the parameter is an instance of String or not.\n\n\n\nSyntax\n\n\nBOOL\n instanceOfString(\nINT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThe parameter to be checked.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\nSTRING\nBOOL\nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream\nselect instanceOfString(value) as state\ninsert into barStream;\n\n\n\n\n\nThis will return true if the value field format is string ex : 'test'.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;\n\n\n\n\n\nif the switchState = true then this will returns false as the value is an instance of the boolean not a string.\n\n\n\nmaximum \n(Function)\n\n\nReturns the maximum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n maximum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the maximum value of the input parameters price1, price2, price3.\n\n\n\nminimum \n(Function)\n\n\nReturns the minimum value of the input parameters.\n\n\n\nSyntax\n\n\nINT|LONG|DOUBLE|FLOAT\n minimum(\nINT|LONG|DOUBLE|FLOAT\n arg)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \narg\n\n        \nThis function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type.\n\n        \n\n        \nINT\nLONG\nDOUBLE\nFLOAT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;\n\n\n\n\n\nThis will returns the minimum value of the input parameters price1, price2, price3.\n\n\n\nsizeOfSet \n(Function)\n\n\nReturns the size of an object of type java.util.Set.\n\n\n\nSyntax\n\n\nINT\n sizeOfSet(\nOBJECT\n set)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nset\n\n        \nThe set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi. \n\n        \n\n        \nOBJECT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;\n\n\n\n\n\nThe sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.\n\n\n\npol2Cart \n(Stream Function)\n\n\nThe pol2Cart function calculating the cartesian coordinates x \n&\n y for the given theta, rho coordinates and adding them as new attributes to the existing events.\n\n\n\nSyntax\n\n\npol2Cart(\nDOUBLE\n theta, \nDOUBLE\n rho, \nDOUBLE\n z)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntheta\n\n        \nThe theta value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nrho\n\n        \nThe rho value of the coordinates.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nz\n\n        \nz value of the cartesian coordinates.\n\n        \nIf z value is not given, drop the third parameter of the output.\n\n        \nDOUBLE\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.\n\n\n\nEXAMPLE 2\n\n\nfrom PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;\n\n\n\n\n\nThis will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.\n\n\n\nlog \n(Stream Processor)\n\n\nThe logger logs the message on the given priority with or without processed event.\n\n\n\nSyntax\n\n\nlog(\nSTRING\n priority, \nSTRING\n log.message, \nBOOL\n is.event.logged)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThe priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE).\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nlog.message\n\n        \nThis message will be logged.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.event.logged\n\n        \nTo log the processed event.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom fooStream#log(\nINFO\n, \nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log as INFO with the message \"Sample Event :\" + fooStream:events.\n\n\n\nEXAMPLE 2\n\n\nfrom fooStream#log(\nSample Event :\n, true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will logs with default log level as INFO.\n\n\n\nEXAMPLE 3\n\n\nfrom fooStream#log(\nSample Event :\n, fasle)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log message.\n\n\n\nEXAMPLE 4\n\n\nfrom fooStream#log(true)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will only log fooStream:events.\n\n\n\nEXAMPLE 5\n\n\nfrom fooStream#log(\nSample Event :\n)\nselect *\ninsert into barStream;\n\n\n\n\n\nThis will log message and fooStream:events.\n\n\n\nbatch \n(Window)\n\n\nA window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches. If it has the parameter length specified, then batch window process the batch as several chunks.\n\n\n\nSyntax\n\n\nbatch(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe length of a chunk\n\n        \nIf length value was not given it assign 0 as length and process the whole batch as once\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;\n\n\n\n\n\nThis will output comma separated items IDs that have the same price for each incoming batch of events.\n\n\n\ncron \n(Window)\n\n\nThis window outputs the arriving events as and when they arrive, and resets (expires) the window periodically based on the given cron expression.\n\n\n\nSyntax\n\n\ncron(\nSTRING\n cron.expression)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ncron.expression\n\n        \nThe cron expression that resets the window.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\n\n@info(name = \nquery1\n)\nfrom InputEventStream#cron(\n*/5 * * * * ?\n)\nselect symbol, sum(price) as totalPrice \ninsert into OutputStream;\n\n\n\n\n\nThis let the totalPrice to gradually increase and resets to zero as a batch every 5 seconds.\n\n\n\nEXAMPLE 2\n\n\ndefine stream StockEventStream (symbol string, price float, volume int)\ndefine window StockEventWindow (symbol string, price float, volume int) cron(\n*/5 * * * * ?\n);\n\n@info(name = \nquery0\n)\nfrom StockEventStream\ninsert into StockEventWindow;\n\n@info(name = \nquery1\n)\nfrom StockEventWindow \nselect symbol, sum(price) as totalPrice\ninsert into OutputStream ;\n\n\n\n\n\nThe defined window will let the totalPrice to gradually increase and resets to zero as a batch every 5 seconds.\n\n\n\ndelay \n(Window)\n\n\nA delay window holds events for a specific time period that is regarded as a delay period before processing them.\n\n\n\nSyntax\n\n\ndelay(\nINT|LONG|TIME\n window.delay)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.delay\n\n        \nThe time period (specified in sec, min, ms) for which  the window should delay the events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name=\nquery1\n) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name=\nquery2\n) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;\n\n\n\n\n\nIn this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.\n\n\n\nexternalTime \n(Window)\n\n\nA sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.\n\n\n\nSyntax\n\n\nexternalTime(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nprocessing events arrived within the last 20 seconds from the eventTime and output expired events.\n\n\n\nexternalTimeBatch \n(Window)\n\n\nA batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.\n\n\n\nSyntax\n\n\nexternalTimeBatch(\nLONG\n timestamp, \nINT|LONG|TIME\n window.time, \nINT|LONG|TIME\n start.time, \nINT|LONG|TIME\n timeout)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntimestamp\n\n        \nThe time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing.\n\n        \n\n        \nLONG\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nUser defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime.\n\n        \nTimestamp of first event\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nTime to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch.\n\n        \nSystem waits till an event from next batch arrives to flush current batch\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime.\n\n\n\nEXAMPLE 2\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.\n\n\n\nEXAMPLE 3\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;\n\n\n\n\n\nThis will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.\n\n\n\nfrequent \n(Window)\n\n\nThis window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.\n\n\n\nSyntax\n\n\nfrequent(\nINT\n event.count, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nevent.count\n\n        \nThe number of most frequent events to be emitted to the stream.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 most frequent events.\n\n\n\nEXAMPLE 2\n\n\n@info(name = \nquery1\n)\nfrom purchase[price \n= 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nThis will returns the 2 latest events with the most frequently appeared card numbers.\n\n\n\nlength \n(Window)\n\n\nA sliding length window that holds the last 'window.length' events at a given time, and gets updated for each arrival and expiry.\n\n\n\nSyntax\n\n\nlength(\nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be included in a sliding length window.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window StockEventWindow (symbol string, price float, volume int) length(10) output all events;\n\n@info(name = \nquery0\n)\nfrom StockEventStream\ninsert into StockEventWindow;\n@info(name = \nquery1\n)\n\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will process last 10 events in a sliding manner.\n\n\n\nlengthBatch \n(Window)\n\n\nA batch (tumbling) length window that holds and process a number of events as specified in the window.length.\n\n\n\nSyntax\n\n\nlengthBatch(\nINT\n window.length, \nBOOL\n stream.current.event)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events the window should tumble.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstream.current.event\n\n        \nLet the window stream the current events out as and when they arrive to the window while expiring them in batches.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\n\n@info(name = \nquery1\n)\nfrom InputEventStream#lengthBatch(10)\nselect symbol, sum(price) as price \ninsert into OutputStream;\n\n\n\n\n\nThis collect and process 10 events as a batch and output them.\n\n\n\nEXAMPLE 2\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\n\n@info(name = \nquery1\n)\nfrom InputEventStream#lengthBatch(10, true)\nselect symbol, sum(price) as sumPrice \ninsert into OutputStream;\n\n\n\n\n\nThis window sends the arriving events directly to the output letting the \nsumPrice\n to increase gradually, after every 10 events it clears the window as a batch and resets the \nsumPrice\n to zero.\n\n\n\nEXAMPLE 3\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\ndefine window StockEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name = \nquery0\n)\nfrom InputEventStream\ninsert into StockEventWindow;\n\n@info(name = \nquery1\n)\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into OutputStream ;\n\n\n\n\n\nThis uses an defined window to process 10 events  as a batch and output all events.\n\n\n\nlossyFrequent \n(Window)\n\n\nThis window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.\n\n\n\nSyntax\n\n\nlossyFrequent(\nDOUBLE\n support.threshold, \nDOUBLE\n error.bound, \nSTRING\n attribute)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nsupport.threshold\n\n        \nThe support threshold value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nerror.bound\n\n        \nThe error bound value.\n\n        \n\n        \nDOUBLE\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.\n\n\n\nEXAMPLE 2\n\n\ndefine stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name = \nquery0\n)\nfrom purchase[price \n= 30]\ninsert into purchaseWindow;\n@info(name = \nquery1\n)\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;\n\n\n\n\n\nlossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.\n\n\n\nsession \n(Window)\n\n\nThis is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key.\nThere can be out of order and late arrival of events, these events can arrive after the session is expired, to include those events to the matching session key specify a latency time period that is less than the session gap period.To have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.\n\n\n\nSyntax\n\n\nsession(\nINT|LONG|TIME\n window.session, \nSTRING\n window.key, \nINT|LONG|TIME\n window.allowedlatency)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.session\n\n        \nThe time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.key\n\n        \nThe grouping attribute for events.\n\n        \ndefault-key\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.allowedlatency\n\n        \nThis specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter).\n\n        \n0\n\n        \nINT\nLONG\nTIME\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name=\nquery0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;\n\n\n\n\n\nThis query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.\n\n\n\nsort \n(Window)\n\n\nThis window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.\n\n\n\nSyntax\n\n\nsort(\nINT\n window.length, \nSTRING\n attribute, \nSTRING\n order)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe size of the window length.\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nattribute\n\n        \nThe attribute that should be checked for the order.\n\n        \nThe concatenation of all the attributes of the event is considered.\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \norder\n\n        \nThe order define as \"asc\" or \"desc\".\n\n        \nasc\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume, \nasc\n);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;\n\n\n\n\n\nsort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.\n\n\n\ntime \n(Window)\n\n\nA sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.\n\n\n\nSyntax\n\n\ntime(\nINT|LONG|TIME\n window.time)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;\n\n\n\n\n\nThis will processing events that arrived within the last 20 milliseconds.\n\n\n\ntimeBatch \n(Window)\n\n\nA batch (tumbling) time window that holds and process events that arrive during 'window.time' period as a batch.\n\n\n\nSyntax\n\n\ntimeBatch(\nINT|LONG|TIME\n window.time, \nINT\n start.time, \nBOOL\n stream.current.event)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe batch time period in which the window process the events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nstart.time\n\n        \nThis specifies an offset in milliseconds in order to start the window at a time different to the standard time.\n\n        \nTimestamp of first event\n\n        \nINT\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nstream.current.event\n\n        \nLet the window stream the current events out as and when they arrive to the window while expiring them in batches.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\n\n@info(name = \nquery1\n)\nfrom InputEventStream#timeBatch(20 sec)\nselect symbol, sum(price) as price \ninsert into OutputStream;\n\n\n\n\n\nThis collect and process incoming events as a batch every 20 seconds and output them.\n\n\n\nEXAMPLE 2\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\n\n@info(name = \nquery1\n)\nfrom InputEventStream#timeBatch(20 sec, true)\nselect symbol, sum(price) as sumPrice \ninsert into OutputStream;\n\n\n\n\n\nThis window sends the arriving events directly to the output letting the \nsumPrice\n to increase gradually and on every 20 second interval it clears the window as a batch resetting the \nsumPrice\n to zero.\n\n\n\nEXAMPLE 3\n\n\ndefine stream InputEventStream (symbol string, price float, volume int);\ndefine window StockEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name = \nquery0\n)\nfrom InputEventStream\ninsert into StockEventWindow;\n\n@info(name = \nquery1\n)\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into OutputStream ;\n\n\n\n\n\nThis uses an defined window to process events arrived every 20 seconds as a batch and output all events.\n\n\n\ntimeLength \n(Window)\n\n\nA sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.\n\n\n\nSyntax\n\n\ntimeLength(\nINT|LONG|TIME\n window.time, \nINT\n window.length)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nwindow.time\n\n        \nThe sliding time period for which the window should hold events.\n\n        \n\n        \nINT\nLONG\nTIME\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nwindow.length\n\n        \nThe number of events that should be be included in a sliding length window..\n\n        \n\n        \nINT\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\ndefine stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name = \nquery0\n)\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name = \nquery1\n)\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;\n\n\n\n\n\nwindow.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.\n\n\n\nSink\n\n\ninMemory \n(Sink)\n\n\nIn-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@sink(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nEvent will be delivered to allthe subscribers of the same topic\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.\n\n\n\nlog \n(Sink)\n\n\nThis is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix\n\n\n\nSyntax\n\n\n@sink(type=\nlog\n, priority=\nSTRING\n, prefix=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \npriority\n\n        \nThis will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE\n\n        \nINFO\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nprefix\n\n        \nThis will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\"\n\n        \ndefault prefix will be \n : \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n, priority=\nDEBUG\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.\n\n\n\nEXAMPLE 2\n\n\n@sink(type=\nlog\n, priority=\nDEBUG\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form \nSiddhi App Name\n : \nStream Name\n\n\n\nEXAMPLE 3\n\n\n@sink(type=\nlog\n, prefix=\nMy Log\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.\n\n\n\nEXAMPLE 4\n\n\n@sink(type=\nlog\n) \ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.\n\n\n\nSinkmapper\n\n\npassThrough \n(Sink Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@sink(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.\n\n\n\nSource\n\n\ninMemory \n(Source)\n\n\nIn-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).\n\n\n\nSyntax\n\n\n@source(type=\ninMemory\n, topic=\nSTRING\n, @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ntopic\n\n        \nSubscribes to sent on the given topic.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ninMemory\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long)\n\n\n\n\n\nIn this example BarStream uses inMemory transport which passes the received event internally without using external transport.\n\n\n\nSourcemapper\n\n\npassThrough \n(Source Mapper)\n\n\nPass-through mapper passed events (Event[]) through without any mapping or modifications.\n\n\n\nSyntax\n\n\n@source(..., @map(type=\npassThrough\n)\n\n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type=\ntcp\n, @map(type=\npassThrough\n))\ndefine stream BarStream (symbol string, price float, volume long);\n\n\n\n\n\nIn this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "latest"
        }, 
        {
            "location": "/api/latest/#api-docs-v501-snapshot", 
            "text": "", 
            "title": "API Docs - v5.0.1-SNAPSHOT"
        }, 
        {
            "location": "/api/latest/#core", 
            "text": "", 
            "title": "Core"
        }, 
        {
            "location": "/api/latest/#and-aggregate-function", 
            "text": "Returns the results of AND operation for all the events.  Syntax  BOOL  and( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be AND operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect and(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for AND operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "and (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#avg-aggregate-function", 
            "text": "Calculates the average for all the events.  Syntax  DOUBLE  avg( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that need to be averaged. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch\n select avg(temp) as avgTemp\n insert into barStream;  avg(temp) returns the average temp value for all the events based on their arrival and expiry.", 
            "title": "avg (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#count-aggregate-function", 
            "text": "Returns the count of all the events.  Syntax  LONG  count()  Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect count() as count\ninsert into barStream;  This will return the count of all the events for time batch in 10 seconds.", 
            "title": "count (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#distinctcount-aggregate-function", 
            "text": "This returns the count of distinct occurrences for a given arg.  Syntax  LONG  distinctCount( INT|LONG|DOUBLE|FLOAT|STRING  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The object for which the number of distinct occurences needs to be counted. \n         \n         INT LONG DOUBLE FLOAT STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect distinctcount(pageID) as count\ninsert into barStream;  distinctcount(pageID) for the following output returns '3' when the available values are as follows. \"WEB_PAGE_1\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" \"WEB_PAGE_3\" \"WEB_PAGE_1\" \"WEB_PAGE_2\" The three distinct occurences identified are 'WEB_PAGE_1', 'WEB_PAGE_2', and 'WEB_PAGE_3'.", 
            "title": "distinctCount (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#max-aggregate-function", 
            "text": "Returns the maximum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  max( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream#window.timeBatch(10 sec)\nselect max(temp) as maxTemp\ninsert into barStream;  max(temp) returns the maximum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "max (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#maxforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  maxForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the maximum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect maxForever(temp) as max\ninsert into outputStream;  maxForever(temp) returns the maximum temp value recorded for all the events throughout the lifetime of the query.", 
            "title": "maxForever (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#min-aggregate-function", 
            "text": "Returns the minimum value for all the events.  Syntax  INT|LONG|DOUBLE|FLOAT  min( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect min(temp) as minTemp\ninsert into outputStream;  min(temp) returns the minimum temp value recorded for all the events based on their arrival and expiry.", 
            "title": "min (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#minforever-aggregate-function", 
            "text": "This is the attribute aggregator to store the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front.  Syntax  INT|LONG|DOUBLE|FLOAT  minForever( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be compared to find the minimum value. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect minForever(temp) as max\ninsert into outputStream;  minForever(temp) returns the minimum temp value recorded for all the events throughoutthe lifetime of the query.", 
            "title": "minForever (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#or-aggregate-function", 
            "text": "Returns the results of OR operation for all the events.  Syntax  BOOL  or( BOOL  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be OR operation. \n         \n         BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from cscStream#window.lengthBatch(10)\nselect or(isFraud) as isFraudTransaction\ninsert into alertStream;  This will returns the result for OR operation of isFraud values as a boolean value for event chunk expiry by window length batch.", 
            "title": "or (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#stddev-aggregate-function", 
            "text": "Returns the calculated standard deviation for all the events.  Syntax  DOUBLE  stdDev( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that should be used to calculate the standard deviation. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect stddev(temp) as stdTemp\ninsert into outputStream;  stddev(temp) returns the calculated standard deviation of temp for all the events based on their arrival and expiry.", 
            "title": "stdDev (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#sum-aggregate-function", 
            "text": "Returns the sum for all the events.  Syntax  LONG|DOUBLE  sum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The value that needs to be summed. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  from inputStream\nselect sum(volume) as sumOfVolume\ninsert into outputStream;  This will returns the sum of volume values as a long value for each event arrival and expiry.", 
            "title": "sum (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#unionset-aggregate-function", 
            "text": "Union multiple sets.  This attribute aggregator maintains a union of sets. The given input set is put into the union set and the union set is returned.  Syntax  OBJECT  unionSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The java.util.Set object that needs to be added into the union set. \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream \n\nfrom initStream#window.timeBatch(10 sec) \nselect unionSet(initialSet) as distinctSymbols \ninsert into distinctStockStream;  distinctStockStream will return the set object which contains the distinct set of stock symbols received during a sliding window of 10 seconds.", 
            "title": "unionSet (Aggregate Function)"
        }, 
        {
            "location": "/api/latest/#uuid-function", 
            "text": "Generates a UUID (Universally Unique Identifier).  Syntax  STRING  UUID()  Examples  EXAMPLE 1  from TempStream\nselect convert(roomNo,  string ) as roomNo, temp, UUID() as messageID\ninsert into RoomTempStream;  This will converts a room number to string, introducing a message ID to each event asUUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8 from TempStream select convert(roomNo, 'string') as roomNo, temp, UUID() as messageID insert into RoomTempStream;", 
            "title": "UUID (Function)"
        }, 
        {
            "location": "/api/latest/#cast-function", 
            "text": "Converts the first parameter according to the cast.to parameter. Incompatible arguments cause Class Cast exceptions if further processed. This function is used with map extension that returns attributes of the object type. You can use this function to cast the object to an accurate and concrete type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  cast( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  to.be.caster,  STRING  cast.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.caster \n         This specifies the attribute to be casted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         cast.to \n         A string constant parameter expressing the cast to type using one of the following strings values: int, long, float, double, string, bool. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect symbol as name, cast(temp,  double ) as temp\ninsert into barStream;  This will cast the fooStream temp field value into 'double' format.", 
            "title": "cast (Function)"
        }, 
        {
            "location": "/api/latest/#coalesce-function", 
            "text": "Returns the value of the first input parameter that is not null, and all input parameters have to be on the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  coalesce( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  args)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         args \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect coalesce( 123 , null,  789 ) as value\ninsert into barStream;  This will returns first null value 123.  EXAMPLE 2  from fooStream\nselect coalesce(null, 76, 567) as value\ninsert into barStream;  This will returns first null value 76.  EXAMPLE 3  from fooStream\nselect coalesce(null, null, null) as value\ninsert into barStream;  This will returns null as there are no notnull values.", 
            "title": "coalesce (Function)"
        }, 
        {
            "location": "/api/latest/#convert-function", 
            "text": "Converts the first input parameter according to the convertedTo parameter.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL  convert( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  to.be.converted,  STRING  converted.to)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         to.be.converted \n         This specifies the value to be converted. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n     \n     \n         converted.to \n         A string constant parameter to which type the attribute need to be converted  using one of the following strings values: 'int', 'long', 'float', 'double', 'string', 'bool'. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect convert(temp,  double ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'double'.  EXAMPLE 2  from fooStream\nselect convert(temp,  int ) as temp\ninsert into barStream;  This will convert fooStream temp value into 'int' (value = \"convert(45.9, 'int') returns 46\").", 
            "title": "convert (Function)"
        }, 
        {
            "location": "/api/latest/#createset-function", 
            "text": "Includes the given input parameter in a java.util.HashSet and returns the set.   Syntax  OBJECT  createSet( INT|LONG|DOUBLE|FLOAT|STRING|BOOL  input)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         input \n         The input that needs to be added into the set. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect createSet(symbol) as initialSet \ninsert into initStream;  For every incoming stockStream event, the initStream stream will produce a set object having only one element: the symbol in the incoming stockStream.", 
            "title": "createSet (Function)"
        }, 
        {
            "location": "/api/latest/#currenttimemillis-function", 
            "text": "Returns the current timestamp of siddhi application in milliseconds.  Syntax  LONG  currentTimeMillis()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, currentTimeMillis() as eventTimestamp \ninsert into barStream;  This will extract current siddhi application timestamp.", 
            "title": "currentTimeMillis (Function)"
        }, 
        {
            "location": "/api/latest/#default-function", 
            "text": "Checks if the 'attribute' parameter is null and if so returns the value of the 'default' parameter  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  attribute,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  default)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         attribute \n         The attribute that could be null. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         default \n         The default value that will be used when 'attribute' parameter is null \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from TempStream\nselect default(temp, 0.0) as temp, roomNum\ninsert into StandardTempStream;  This will replace TempStream's temp attribute with default value if the temp is null.", 
            "title": "default (Function)"
        }, 
        {
            "location": "/api/latest/#eventtimestamp-function", 
            "text": "Returns the timestamp of the processed event.  Syntax  LONG  eventTimestamp()  Examples  EXAMPLE 1  from fooStream\nselect symbol as name, eventTimestamp() as eventTimestamp \ninsert into barStream;  This will extract current events timestamp.", 
            "title": "eventTimestamp (Function)"
        }, 
        {
            "location": "/api/latest/#ifthenelse-function", 
            "text": "Evaluates the 'condition' parameter and returns value of the 'if.expression' parameter if the condition is true, or returns value of the 'else.expression' parameter if the condition is false. Here both 'if.expression' and 'else.expression' should be of the same type.  Syntax  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  ifThenElse( BOOL  condition,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  if.expression,  INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  else.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         condition \n         This specifies the if then else condition value. \n         \n         BOOL \n         No \n         No \n     \n     \n         if.expression \n         This specifies the value to be returned if the value of the condition parameter is true. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n     \n     \n         else.expression \n         This specifies the value to be returned if the value of the condition parameter is false. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(sensorValue 35, High , Low ) as status\ninsert into outputStream;  This will returns High if sensorValue = 50.  EXAMPLE 2  @info(name =  query1 )\nfrom sensorEventStream\nselect sensorValue, ifThenElse(voltage   5, 0, 1) as status\ninsert into outputStream;  This will returns 1 if voltage= 12.  EXAMPLE 3  @info(name =  query1 )\nfrom userEventStream\nselect userName, ifThenElse(password ==  admin , true, false) as passwordState\ninsert into outputStream;  This will returns  passwordState as true if password = admin.", 
            "title": "ifThenElse (Function)"
        }, 
        {
            "location": "/api/latest/#instanceofboolean-function", 
            "text": "Checks whether the parameter is an instance of Boolean or not.  Syntax  BOOL  instanceOfBoolean( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfBoolean(switchState) as state\ninsert into barStream;  This will return true if the value of switchState is true.  EXAMPLE 2  from fooStream\nselect instanceOfBoolean(value) as state\ninsert into barStream;  if the value = 32 then this will returns false as the value is not an instance of the boolean.", 
            "title": "instanceOfBoolean (Function)"
        }, 
        {
            "location": "/api/latest/#instanceofdouble-function", 
            "text": "Checks whether the parameter is an instance of Double or not.  Syntax  BOOL  instanceOfDouble( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfDouble(value) as state\ninsert into barStream;  This will return true if the value field format is double ex : 56.45.  EXAMPLE 2  from fooStream\nselect instanceOfDouble(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is not an instance of the double.", 
            "title": "instanceOfDouble (Function)"
        }, 
        {
            "location": "/api/latest/#instanceoffloat-function", 
            "text": "Checks whether the parameter is an instance of Float or not.  Syntax  BOOL  instanceOfFloat( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfFloat(value) as state\ninsert into barStream;  This will return true if the value field format is float ex : 56.45f.  EXAMPLE 2  from fooStream\nselect instanceOfFloat(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a float.", 
            "title": "instanceOfFloat (Function)"
        }, 
        {
            "location": "/api/latest/#instanceofinteger-function", 
            "text": "Checks whether the parameter is an instance of Integer or not.  Syntax  BOOL  instanceOfInteger( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfInteger(value) as state\ninsert into barStream;  This will return true if the value field format is integer.  EXAMPLE 2  from fooStream\nselect instanceOfInteger(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfInteger (Function)"
        }, 
        {
            "location": "/api/latest/#instanceoflong-function", 
            "text": "Checks whether the parameter is an instance of Long or not.  Syntax  BOOL  instanceOfLong( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfLong(value) as state\ninsert into barStream;  This will return true if the value field format is long ex : 56456l.  EXAMPLE 2  from fooStream\nselect instanceOfLong(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a long.", 
            "title": "instanceOfLong (Function)"
        }, 
        {
            "location": "/api/latest/#instanceofstring-function", 
            "text": "Checks whether the parameter is an instance of String or not.  Syntax  BOOL  instanceOfString( INT|LONG|DOUBLE|FLOAT|STRING|BOOL|OBJECT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         The parameter to be checked. \n         \n         INT LONG DOUBLE FLOAT STRING BOOL OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from fooStream\nselect instanceOfString(value) as state\ninsert into barStream;  This will return true if the value field format is string ex : 'test'.  EXAMPLE 2  from fooStream\nselect instanceOfString(switchState) as state\ninsert into barStream;  if the switchState = true then this will returns false as the value is an instance of the boolean not a string.", 
            "title": "instanceOfString (Function)"
        }, 
        {
            "location": "/api/latest/#maximum-function", 
            "text": "Returns the maximum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  maximum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the maximum value of the input parameters price1, price2, price3.", 
            "title": "maximum (Function)"
        }, 
        {
            "location": "/api/latest/#minimum-function", 
            "text": "Returns the minimum value of the input parameters.  Syntax  INT|LONG|DOUBLE|FLOAT  minimum( INT|LONG|DOUBLE|FLOAT  arg)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         arg \n         This function accepts one or more parameters. They can belong to any one of the available types. All the specified parameters should be of the same type. \n         \n         INT LONG DOUBLE FLOAT \n         No \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 ) from inputStream\nselect maximum(price1, price2, price3) as max\ninsert into outputStream;  This will returns the minimum value of the input parameters price1, price2, price3.", 
            "title": "minimum (Function)"
        }, 
        {
            "location": "/api/latest/#sizeofset-function", 
            "text": "Returns the size of an object of type java.util.Set.  Syntax  INT  sizeOfSet( OBJECT  set)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         set \n         The set object. This parameter should be of type java.util.Set. A set object may be created by the 'set' attribute aggregator in Siddhi.  \n         \n         OBJECT \n         No \n         No \n       Examples  EXAMPLE 1  from stockStream \nselect initSet(symbol) as initialSet \ninsert into initStream; \n\n;from initStream#window.timeBatch(10 sec) \nselect union(initialSet) as distinctSymbols \ninsert into distinctStockStream; \n\nfrom distinctStockStream \nselect sizeOfSet(distinctSymbols) sizeOfSymbolSet \ninsert into sizeStream;  The sizeStream stream will output the number of distinct stock symbols received during a sliding window of 10 seconds.", 
            "title": "sizeOfSet (Function)"
        }, 
        {
            "location": "/api/latest/#pol2cart-stream-function", 
            "text": "The pol2Cart function calculating the cartesian coordinates x  &  y for the given theta, rho coordinates and adding them as new attributes to the existing events.  Syntax  pol2Cart( DOUBLE  theta,  DOUBLE  rho,  DOUBLE  z)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         theta \n         The theta value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         rho \n         The rho value of the coordinates. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         z \n         z value of the cartesian coordinates. \n         If z value is not given, drop the third parameter of the output. \n         DOUBLE \n         Yes \n         No \n       Examples  EXAMPLE 1  from PolarStream#pol2Cart(theta, rho)\nselect x, y \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748) for theta: 0.7854 and rho: 5.  EXAMPLE 2  from PolarStream#pol2Cart(theta, rho, 3.4)\nselect x, y, z \ninsert into outputStream ;  This will return cartesian coordinates (4.99953024681082, 0.06853693328228748, 3.4)for theta: 0.7854 and rho: 5 and z: 3.4.", 
            "title": "pol2Cart (Stream Function)"
        }, 
        {
            "location": "/api/latest/#log-stream-processor", 
            "text": "The logger logs the message on the given priority with or without processed event.  Syntax  log( STRING  priority,  STRING  log.message,  BOOL  is.event.logged)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         The priority/type of this log message (INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE). \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         log.message \n         This message will be logged. \n         \n         STRING \n         No \n         No \n     \n     \n         is.event.logged \n         To log the processed event. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  from fooStream#log( INFO ,  Sample Event : , true)\nselect *\ninsert into barStream;  This will log as INFO with the message \"Sample Event :\" + fooStream:events.  EXAMPLE 2  from fooStream#log( Sample Event : , true)\nselect *\ninsert into barStream;  This will logs with default log level as INFO.  EXAMPLE 3  from fooStream#log( Sample Event : , fasle)\nselect *\ninsert into barStream;  This will only log message.  EXAMPLE 4  from fooStream#log(true)\nselect *\ninsert into barStream;  This will only log fooStream:events.  EXAMPLE 5  from fooStream#log( Sample Event : )\nselect *\ninsert into barStream;  This will log message and fooStream:events.", 
            "title": "log (Stream Processor)"
        }, 
        {
            "location": "/api/latest/#batch-window", 
            "text": "A window that holds an incoming events batch. When a new set of events arrives, the previously arrived old events will be expired. Batch window can be used to aggregate events that comes in batches. If it has the parameter length specified, then batch window process the batch as several chunks.  Syntax  batch( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The length of a chunk \n         If length value was not given it assign 0 as length and process the whole batch as once \n         INT \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream consumerItemStream (itemId string, price float)\n\nfrom consumerItemStream#window.batch()\nselect price, str:groupConcat(itemId) as itemIds\ngroup by price\ninsert into outputStream;  This will output comma separated items IDs that have the same price for each incoming batch of events.", 
            "title": "batch (Window)"
        }, 
        {
            "location": "/api/latest/#cron-window", 
            "text": "This window outputs the arriving events as and when they arrive, and resets (expires) the window periodically based on the given cron expression.  Syntax  cron( STRING  cron.expression)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         cron.expression \n         The cron expression that resets the window. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  define stream InputEventStream (symbol string, price float, volume int);\n\n@info(name =  query1 )\nfrom InputEventStream#cron( */5 * * * * ? )\nselect symbol, sum(price) as totalPrice \ninsert into OutputStream;  This let the totalPrice to gradually increase and resets to zero as a batch every 5 seconds.  EXAMPLE 2  define stream StockEventStream (symbol string, price float, volume int)\ndefine window StockEventWindow (symbol string, price float, volume int) cron( */5 * * * * ? );\n\n@info(name =  query0 )\nfrom StockEventStream\ninsert into StockEventWindow;\n\n@info(name =  query1 )\nfrom StockEventWindow \nselect symbol, sum(price) as totalPrice\ninsert into OutputStream ;  The defined window will let the totalPrice to gradually increase and resets to zero as a batch every 5 seconds.", 
            "title": "cron (Window)"
        }, 
        {
            "location": "/api/latest/#delay-window", 
            "text": "A delay window holds events for a specific time period that is regarded as a delay period before processing them.  Syntax  delay( INT|LONG|TIME  window.delay)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.delay \n         The time period (specified in sec, min, ms) for which  the window should delay the events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window delayWindow(symbol string, volume int) delay(1 hour);\ndefine stream PurchaseStream(symbol string, volume int);\ndefine stream DeliveryStream(symbol string);\ndefine stream OutputStream(symbol string);\n\n@info(name= query1 ) \nfrom PurchaseStream\nselect symbol, volume\ninsert into delayWindow;\n\n@info(name= query2 ) \nfrom delayWindow join DeliveryStream\non delayWindow.symbol == DeliveryStream.symbol\nselect delayWindow.symbol\ninsert into OutputStream;  In this example, purchase events that arrive in the 'PurchaseStream' stream are directed to a delay window. At any given time, this delay window holds purchase events that have arrived within the last hour. These purchase events in the window are matched by the 'symbol' attribute, with delivery events that arrive in the 'DeliveryStream' stream. This monitors whether the delivery of products is done with a minimum delay of one hour after the purchase.", 
            "title": "delay (Window)"
        }, 
        {
            "location": "/api/latest/#externaltime-window", 
            "text": "A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp.  Syntax  externalTime( LONG  timestamp,  INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTime(eventTime, 20 sec) output expired events;\n\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  processing events arrived within the last 20 seconds from the eventTime and output expired events.", 
            "title": "externalTime (Window)"
        }, 
        {
            "location": "/api/latest/#externaltimebatch-window", 
            "text": "A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime.  Syntax  externalTimeBatch( LONG  timestamp,  INT|LONG|TIME  window.time,  INT|LONG|TIME  start.time,  INT|LONG|TIME  timeout)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         timestamp \n         The time which the window determines as current time and will act upon. The value of this parameter should be monotonically increasing. \n         \n         LONG \n         No \n         No \n     \n     \n         window.time \n         The batch time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         User defined start time. This could either be a constant (of type int, long or time) or an attribute of the corresponding stream (of type long). If an attribute is provided, initial value of attribute would be considered as startTime. \n         Timestamp of first event \n         INT LONG TIME \n         Yes \n         No \n     \n     \n         timeout \n         Time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. \n         System waits till an event from next batch arrives to flush current batch \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 1 sec) output expired events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert expired events into outputStream ;  This will processing events that arrive every 1 seconds from the eventTime.  EXAMPLE 2  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 20 sec, 0) output expired events;  This will processing events that arrive every 1 seconds from the eventTime. Starts on 0th millisecond of an hour.  EXAMPLE 3  define window cseEventWindow (symbol string, price float, volume int) externalTimeBatch(eventTime, 2 sec, eventTimestamp, 100) output expired events;  This will processing events that arrive every 2 seconds from the eventTim. Considers the first event's eventTimestamp value as startTime. Waits 100 milliseconds for the arrival of a new event before flushing current batch.", 
            "title": "externalTimeBatch (Window)"
        }, 
        {
            "location": "/api/latest/#frequent-window", 
            "text": "This window returns the latest events with the most frequently occurred value for a given attribute(s). Frequency calculation for this window processor is based on Misra-Gries counting algorithm.  Syntax  frequent( INT  event.count,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         event.count \n         The number of most frequent events to be emitted to the stream. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 most frequent events.  EXAMPLE 2  @info(name =  query1 )\nfrom purchase[price  = 30]#window.frequent(2, cardNo)\nselect cardNo, price\ninsert all events into PotentialFraud;  This will returns the 2 latest events with the most frequently appeared card numbers.", 
            "title": "frequent (Window)"
        }, 
        {
            "location": "/api/latest/#length-window", 
            "text": "A sliding length window that holds the last 'window.length' events at a given time, and gets updated for each arrival and expiry.  Syntax  length( INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events that should be included in a sliding length window. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define window StockEventWindow (symbol string, price float, volume int) length(10) output all events;\n\n@info(name =  query0 )\nfrom StockEventStream\ninsert into StockEventWindow;\n@info(name =  query1 )\n\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will process last 10 events in a sliding manner.", 
            "title": "length (Window)"
        }, 
        {
            "location": "/api/latest/#lengthbatch-window", 
            "text": "A batch (tumbling) length window that holds and process a number of events as specified in the window.length.  Syntax  lengthBatch( INT  window.length,  BOOL  stream.current.event)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The number of events the window should tumble. \n         \n         INT \n         No \n         No \n     \n     \n         stream.current.event \n         Let the window stream the current events out as and when they arrive to the window while expiring them in batches. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream InputEventStream (symbol string, price float, volume int);\n\n@info(name =  query1 )\nfrom InputEventStream#lengthBatch(10)\nselect symbol, sum(price) as price \ninsert into OutputStream;  This collect and process 10 events as a batch and output them.  EXAMPLE 2  define stream InputEventStream (symbol string, price float, volume int);\n\n@info(name =  query1 )\nfrom InputEventStream#lengthBatch(10, true)\nselect symbol, sum(price) as sumPrice \ninsert into OutputStream;  This window sends the arriving events directly to the output letting the  sumPrice  to increase gradually, after every 10 events it clears the window as a batch and resets the  sumPrice  to zero.  EXAMPLE 3  define stream InputEventStream (symbol string, price float, volume int);\ndefine window StockEventWindow (symbol string, price float, volume int) lengthBatch(10) output all events;\n\n@info(name =  query0 )\nfrom InputEventStream\ninsert into StockEventWindow;\n\n@info(name =  query1 )\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into OutputStream ;  This uses an defined window to process 10 events  as a batch and output all events.", 
            "title": "lengthBatch (Window)"
        }, 
        {
            "location": "/api/latest/#lossyfrequent-window", 
            "text": "This window identifies and returns all the events of which the current frequency exceeds the value specified for the supportThreshold parameter.  Syntax  lossyFrequent( DOUBLE  support.threshold,  DOUBLE  error.bound,  STRING  attribute)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         support.threshold \n         The support threshold value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         error.bound \n         The error bound value. \n         \n         DOUBLE \n         No \n         No \n     \n     \n         attribute \n         The attributes to group the events. If no attributes are given, the concatenation of all the attributes of the event is considered. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.1, 0.01);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.1, 0.01) returns all the events of which the current frequency exceeds 0.1, with an error bound of 0.01.  EXAMPLE 2  define stream purchase (cardNo string, price float);\ndefine window purchaseWindow (cardNo string, price float) lossyFrequent(0.3, 0.05, cardNo);\n@info(name =  query0 )\nfrom purchase[price  = 30]\ninsert into purchaseWindow;\n@info(name =  query1 )\nfrom purchaseWindow\nselect cardNo, price\ninsert all events into PotentialFraud;  lossyFrequent(0.3, 0.05, cardNo) returns all the events of which the cardNo attributes frequency exceeds 0.3, with an error bound of 0.05.", 
            "title": "lossyFrequent (Window)"
        }, 
        {
            "location": "/api/latest/#session-window", 
            "text": "This is a session window that holds events that belong to a specific session. The events that belong to a specific session are identified by a grouping attribute (i.e., a session key). A session gap period is specified to determine the time period after which the session is considered to be expired. A new event that arrives with a specific value for the session key is matched with the session window with the same session key. There can be out of order and late arrival of events, these events can arrive after the session is expired, to include those events to the matching session key specify a latency time period that is less than the session gap period.To have aggregate functions with session windows, the events need to be grouped by the session key via a 'group by' clause.  Syntax  session( INT|LONG|TIME  window.session,  STRING  window.key,  INT|LONG|TIME  window.allowedlatency)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.session \n         The time period for which the session considered is valid. This is specified in seconds, minutes, or milliseconds (i.e., 'min', 'sec', or 'ms'. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.key \n         The grouping attribute for events. \n         default-key \n         STRING \n         Yes \n         No \n     \n     \n         window.allowedlatency \n         This specifies the time period for which the session window is valid after the expiration of the session. The time period specified here should be less than the session time gap (which is specified via the 'window.session' parameter). \n         0 \n         INT LONG TIME \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream PurchaseEventStream (user string, item_number int, price float, quantity int);\n\n@info(name= query0) \nfrom PurchaseEventStream#window.session(5 sec, user, 2 sec) \nselect * \ninsert all events into OutputStream;  This query processes events that arrive at the PurchaseEvent input stream. The 'user' attribute is the session key, and the session gap is 5 seconds. '2 sec' is specified as the allowed latency. Therefore, events with the matching user name that arrive 2 seconds after the expiration of the session are also considered when performing aggregations for the session identified by the given user name.", 
            "title": "session (Window)"
        }, 
        {
            "location": "/api/latest/#sort-window", 
            "text": "This window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order.  Syntax  sort( INT  window.length,  STRING  attribute,  STRING  order)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.length \n         The size of the window length. \n         \n         INT \n         No \n         No \n     \n     \n         attribute \n         The attribute that should be checked for the order. \n         The concatenation of all the attributes of the event is considered. \n         STRING \n         Yes \n         No \n     \n     \n         order \n         The order define as \"asc\" or \"desc\". \n         asc \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume long);\ndefine window cseEventWindow (symbol string, price float, volume long) sort(2,volume,  asc );\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect volume\ninsert all events into outputStream ;  sort(5, price, 'asc') keeps the events sorted by price in the ascending order. Therefore, at any given time, the window contains the 5 lowest prices.", 
            "title": "sort (Window)"
        }, 
        {
            "location": "/api/latest/#time-window", 
            "text": "A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry.  Syntax  time( INT|LONG|TIME  window.time)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n       Examples  EXAMPLE 1  define window cseEventWindow (symbol string, price float, volume int) time(20) output all events;\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow\nselect symbol, sum(price) as price\ninsert all events into outputStream ;  This will processing events that arrived within the last 20 milliseconds.", 
            "title": "time (Window)"
        }, 
        {
            "location": "/api/latest/#timebatch-window", 
            "text": "A batch (tumbling) time window that holds and process events that arrive during 'window.time' period as a batch.  Syntax  timeBatch( INT|LONG|TIME  window.time,  INT  start.time,  BOOL  stream.current.event)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The batch time period in which the window process the events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         start.time \n         This specifies an offset in milliseconds in order to start the window at a time different to the standard time. \n         Timestamp of first event \n         INT \n         Yes \n         No \n     \n     \n         stream.current.event \n         Let the window stream the current events out as and when they arrive to the window while expiring them in batches. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  define stream InputEventStream (symbol string, price float, volume int);\n\n@info(name =  query1 )\nfrom InputEventStream#timeBatch(20 sec)\nselect symbol, sum(price) as price \ninsert into OutputStream;  This collect and process incoming events as a batch every 20 seconds and output them.  EXAMPLE 2  define stream InputEventStream (symbol string, price float, volume int);\n\n@info(name =  query1 )\nfrom InputEventStream#timeBatch(20 sec, true)\nselect symbol, sum(price) as sumPrice \ninsert into OutputStream;  This window sends the arriving events directly to the output letting the  sumPrice  to increase gradually and on every 20 second interval it clears the window as a batch resetting the  sumPrice  to zero.  EXAMPLE 3  define stream InputEventStream (symbol string, price float, volume int);\ndefine window StockEventWindow (symbol string, price float, volume int) timeBatch(20 sec) output all events;\n\n@info(name =  query0 )\nfrom InputEventStream\ninsert into StockEventWindow;\n\n@info(name =  query1 )\nfrom StockEventWindow\nselect symbol, sum(price) as price\ninsert all events into OutputStream ;  This uses an defined window to process events arrived every 20 seconds as a batch and output all events.", 
            "title": "timeBatch (Window)"
        }, 
        {
            "location": "/api/latest/#timelength-window", 
            "text": "A sliding time window that, at a given time holds the last window.length events that arrived during last window.time period, and gets updated for every event arrival and expiry.  Syntax  timeLength( INT|LONG|TIME  window.time,  INT  window.length)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         window.time \n         The sliding time period for which the window should hold events. \n         \n         INT LONG TIME \n         No \n         No \n     \n     \n         window.length \n         The number of events that should be be included in a sliding length window.. \n         \n         INT \n         No \n         No \n       Examples  EXAMPLE 1  define stream cseEventStream (symbol string, price float, volume int);\ndefine window cseEventWindow (symbol string, price float, volume int) timeLength(2 sec, 10);\n@info(name =  query0 )\nfrom cseEventStream\ninsert into cseEventWindow;\n@info(name =  query1 )\nfrom cseEventWindow select symbol, price, volume\ninsert all events into outputStream;  window.timeLength(2 sec, 10) holds the last 10 events that arrived during last 2 seconds and gets updated for every event arrival and expiry.", 
            "title": "timeLength (Window)"
        }, 
        {
            "location": "/api/latest/#sink", 
            "text": "", 
            "title": "Sink"
        }, 
        {
            "location": "/api/latest/#inmemory-sink", 
            "text": "In-memory transport that can communicate with other in-memory transports within the same JVM, itis assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @sink(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Event will be delivered to allthe subscribers of the same topic \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which emit the Siddhi events internally without using external transport and transformation.", 
            "title": "inMemory (Sink)"
        }, 
        {
            "location": "/api/latest/#log-sink", 
            "text": "This is a sink that can be used as a logger. This will log the output events in the output stream with user specified priority and a prefix  Syntax  @sink(type= log , priority= STRING , prefix= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         priority \n         This will set the logger priority i.e log level. Accepted values are INFO, DEBUG, WARN, FATAL, ERROR, OFF, TRACE \n         INFO \n         STRING \n         Yes \n         No \n     \n     \n         prefix \n         This will be the prefix to the output message. If the output stream has event [2,4] and the prefix is given as \"Hello\" then the log will show \"Hello : [2,4]\" \n         default prefix will be   :  \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type= log , prefix= My Log , priority= DEBUG ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. Also the priority is set to DEBUG.  EXAMPLE 2  @sink(type= log , priority= DEBUG ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the priority is set to DEBUG. User has not specified prefix so the default prefix will be in the form  Siddhi App Name  :  Stream Name  EXAMPLE 3  @sink(type= log , prefix= My Log ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink and the prefix is given as My Log. User has not given a priority so it will be set to default INFO.  EXAMPLE 4  @sink(type= log ) \ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses log sink. The user has not given prefix or priority so they will be set to their default values.", 
            "title": "log (Sink)"
        }, 
        {
            "location": "/api/latest/#sinkmapper", 
            "text": "", 
            "title": "Sinkmapper"
        }, 
        {
            "location": "/api/latest/#passthrough-sink-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @sink(..., @map(type= passThrough )  Examples  EXAMPLE 1  @sink(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In the following example BarStream uses passThrough outputmapper which emit Siddhi event directly without any transformation into sink.", 
            "title": "passThrough (Sink Mapper)"
        }, 
        {
            "location": "/api/latest/#source", 
            "text": "", 
            "title": "Source"
        }, 
        {
            "location": "/api/latest/#inmemory-source", 
            "text": "In-memory source that can communicate with other in-memory sinks within the same JVM, it is assumed that the publisher and subscriber of a topic uses same event schema (stream definition).  Syntax  @source(type= inMemory , topic= STRING , @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         topic \n         Subscribes to sent on the given topic. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  @source(type= inMemory , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long)  In this example BarStream uses inMemory transport which passes the received event internally without using external transport.", 
            "title": "inMemory (Source)"
        }, 
        {
            "location": "/api/latest/#sourcemapper", 
            "text": "", 
            "title": "Sourcemapper"
        }, 
        {
            "location": "/api/latest/#passthrough-source-mapper", 
            "text": "Pass-through mapper passed events (Event[]) through without any mapping or modifications.  Syntax  @source(..., @map(type= passThrough )  Examples  EXAMPLE 1  @source(type= tcp , @map(type= passThrough ))\ndefine stream BarStream (symbol string, price float, volume long);  In this example BarStream uses passThrough inputmapper which passes the received Siddhi event directly without any transformation into source.", 
            "title": "passThrough (Source Mapper)"
        }, 
        {
            "location": "/license/", 
            "text": "Copyright (c) 2017 WSO2 Inc. (\nhttp://www.wso2.org\n) All Rights Reserved.\n\n\nWSO2 Inc. licenses this file to you under the Apache License,\nVersion 2.0 (the \"License\"); you may not use this file except\nin compliance with the License.\nYou may obtain a copy of the License at\n\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\n\nUnless required by applicable law or agreed to in writing,\nsoftware distributed under the License is distributed on an\n\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, either express or implied.  See the License for the\nspecific language governing permissions and limitations\nunder the License.\n\n\n-------------------------------------------------------------------------\n                              Apache License\n                        Version 2.0, January 2004\n                     http://www.apache.org/licenses/\n\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n   \nLicense\n shall mean the terms and conditions for use, reproduction,\n   and distribution as defined by Sections 1 through 9 of this document.\n\n   \nLicensor\n shall mean the copyright owner or entity authorized by\n   the copyright owner that is granting the License.\n\n   \nLegal Entity\n shall mean the union of the acting entity and all\n   other entities that control, are controlled by, or are under common\n   control with that entity. For the purposes of this definition,\n   \ncontrol\n means (i) the power, direct or indirect, to cause the\n   direction or management of such entity, whether by contract or\n   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n   outstanding shares, or (iii) beneficial ownership of such entity.\n\n   \nYou\n (or \nYour\n) shall mean an individual or Legal Entity\n   exercising permissions granted by this License.\n\n   \nSource\n form shall mean the preferred form for making modifications,\n   including but not limited to software source code, documentation\n   source, and configuration files.\n\n   \nObject\n form shall mean any form resulting from mechanical\n   transformation or translation of a Source form, including but\n   not limited to compiled object code, generated documentation,\n   and conversions to other media types.\n\n   \nWork\n shall mean the work of authorship, whether in Source or\n   Object form, made available under the License, as indicated by a\n   copyright notice that is included in or attached to the work\n   (an example is provided in the Appendix below).\n\n   \nDerivative Works\n shall mean any work, whether in Source or Object\n   form, that is based on (or derived from) the Work and for which the\n   editorial revisions, annotations, elaborations, or other modifications\n   represent, as a whole, an original work of authorship. For the purposes\n   of this License, Derivative Works shall not include works that remain\n   separable from, or merely link (or bind by name) to the interfaces of,\n   the Work and Derivative Works thereof.\n\n   \nContribution\n shall mean any work of authorship, including\n   the original version of the Work and any modifications or additions\n   to that Work or Derivative Works thereof, that is intentionally\n   submitted to Licensor for inclusion in the Work by the copyright owner\n   or by an individual or Legal Entity authorized to submit on behalf of\n   the copyright owner. For the purposes of this definition, \nsubmitted\n\n   means any form of electronic, verbal, or written communication sent\n   to the Licensor or its representatives, including but not limited to\n   communication on electronic mailing lists, source code control systems,\n   and issue tracking systems that are managed by, or on behalf of, the\n   Licensor for the purpose of discussing and improving the Work, but\n   excluding communication that is conspicuously marked or otherwise\n   designated in writing by the copyright owner as \nNot a Contribution.\n\n\n   \nContributor\n shall mean Licensor and any individual or Legal Entity\n   on behalf of whom a Contribution has been received by Licensor and\n   subsequently incorporated within the Work.\n\n2. Grant of Copyright License. Subject to the terms and conditions of\n   this License, each Contributor hereby grants to You a perpetual,\n   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n   copyright license to reproduce, prepare Derivative Works of,\n   publicly display, publicly perform, sublicense, and distribute the\n   Work and such Derivative Works in Source or Object form.\n\n3. Grant of Patent License. Subject to the terms and conditions of\n   this License, each Contributor hereby grants to You a perpetual,\n   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n   (except as stated in this section) patent license to make, have made,\n   use, offer to sell, sell, import, and otherwise transfer the Work,\n   where such license applies only to those patent claims licensable\n   by such Contributor that are necessarily infringed by their\n   Contribution(s) alone or by combination of their Contribution(s)\n   with the Work to which such Contribution(s) was submitted. If You\n   institute patent litigation against any entity (including a\n   cross-claim or counterclaim in a lawsuit) alleging that the Work\n   or a Contribution incorporated within the Work constitutes direct\n   or contributory patent infringement, then any patent licenses\n   granted to You under this License for that Work shall terminate\n   as of the date such litigation is filed.\n\n4. Redistribution. You may reproduce and distribute copies of the\n   Work or Derivative Works thereof in any medium, with or without\n   modifications, and in Source or Object form, provided that You\n   meet the following conditions:\n\n   (a) You must give any other recipients of the Work or\n       Derivative Works a copy of this License; and\n\n   (b) You must cause any modified files to carry prominent notices\n       stating that You changed the files; and\n\n   (c) You must retain, in the Source form of any Derivative Works\n       that You distribute, all copyright, patent, trademark, and\n       attribution notices from the Source form of the Work,\n       excluding those notices that do not pertain to any part of\n       the Derivative Works; and\n\n   (d) If the Work includes a \nNOTICE\n text file as part of its\n       distribution, then any Derivative Works that You distribute must\n       include a readable copy of the attribution notices contained\n       within such NOTICE file, excluding those notices that do not\n       pertain to any part of the Derivative Works, in at least one\n       of the following places: within a NOTICE text file distributed\n       as part of the Derivative Works; within the Source form or\n       documentation, if provided along with the Derivative Works; or,\n       within a display generated by the Derivative Works, if and\n       wherever such third-party notices normally appear. The contents\n       of the NOTICE file are for informational purposes only and\n       do not modify the License. You may add Your own attribution\n       notices within Derivative Works that You distribute, alongside\n       or as an addendum to the NOTICE text from the Work, provided\n       that such additional attribution notices cannot be construed\n       as modifying the License.\n\n   You may add Your own copyright statement to Your modifications and\n   may provide additional or different license terms and conditions\n   for use, reproduction, or distribution of Your modifications, or\n   for any such Derivative Works as a whole, provided Your use,\n   reproduction, and distribution of the Work otherwise complies with\n   the conditions stated in this License.\n\n5. Submission of Contributions. Unless You explicitly state otherwise,\n   any Contribution intentionally submitted for inclusion in the Work\n   by You to the Licensor shall be under the terms and conditions of\n   this License, without any additional terms or conditions.\n   Notwithstanding the above, nothing herein shall supersede or modify\n   the terms of any separate license agreement you may have executed\n   with Licensor regarding such Contributions.\n\n6. Trademarks. This License does not grant permission to use the trade\n   names, trademarks, service marks, or product names of the Licensor,\n   except as required for reasonable and customary use in describing the\n   origin of the Work and reproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty. Unless required by applicable law or\n   agreed to in writing, Licensor provides the Work (and each\n   Contributor provides its Contributions) on an \nAS IS\n BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n   implied, including, without limitation, any warranties or conditions\n   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n   PARTICULAR PURPOSE. You are solely responsible for determining the\n   appropriateness of using or redistributing the Work and assume any\n   risks associated with Your exercise of permissions under this License.\n\n8. Limitation of Liability. In no event and under no legal theory,\n   whether in tort (including negligence), contract, or otherwise,\n   unless required by applicable law (such as deliberate and grossly\n   negligent acts) or agreed to in writing, shall any Contributor be\n   liable to You for damages, including any direct, indirect, special,\n   incidental, or consequential damages of any character arising as a\n   result of this License or out of the use or inability to use the\n   Work (including but not limited to damages for loss of goodwill,\n   work stoppage, computer failure or malfunction, or any and all\n   other commercial damages or losses), even if such Contributor\n   has been advised of the possibility of such damages.\n\n9. Accepting Warranty or Additional Liability. While redistributing\n   the Work or Derivative Works thereof, You may choose to offer,\n   and charge a fee for, acceptance of support, warranty, indemnity,\n   or other liability obligations and/or rights consistent with this\n   License. However, in accepting such obligations, You may act only\n   on Your own behalf and on Your sole responsibility, not on behalf\n   of any other Contributor, and only if You agree to indemnify,\n   defend, and hold each Contributor harmless for any liability\n   incurred by, or claims asserted against, such Contributor by reason\n   of your accepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS", 
            "title": "License"
        }, 
        {
            "location": "/season-of-docs-2019/", 
            "text": "Google Season of Docs 2019\n\n\nSiddhi project is excited to participate in the first Google Season of Docs program as a mentoring organization to foster \nopen source collaboration with technical writers on Siddhi documentation. We are pleased to introduce the below \nproject proposals to encourage you to participate and become a contributor in the Siddhi open source community.\n\n\nIf you are interested in working on any of the below projects and if you need further information, please feel free to \ncontact the mentors listed under each proposal below, or write to us via siddhi-dev@googlegroups.com .\n\n\nHappy documenting with Google Season of Docs!\n\n\n\n\nProposal 1: CI/CD Guideline for Siddhi Stream Processor\n\n\nDescription\n\n\nSiddhi is an open source cloud native stream processing engine [1]. The Siddhi engine is integrated with various other \nopen source and proprietary projects such as Apache Eagle [1], Apache Flink [2], UBER [3] and Punch Platform [4] and etc. \nOther than that, the Siddhi engine also plays the primary role in various WSO2 products such as WSO2 Stream Processor, \nWSO2 Data Analytics Server, WSO2 API Manager (Traffic Manager component),  etc.\n\n\nSiddhi Query Language is an SQL-like query language that defines a logic for analyzing high volumes of data generated \nin high speed and in real time. Siddhi documentation [2] currently describes the Siddhi architecture, main concepts, \nfeatures, the Siddhi grammar, and how to use it.\n\n\nHowever, at present, we lack proper documentation to explain the complete life cycle of the CI-CD process. We need \ndetailed and comprehensive documentation that explains this process. When writing this documentation, you are also \nexpected to try out the product and gather some user experience around it and make sure that it is captured properly \nin the documentation.\n\n\nDeliverables\n\n\nA comprehensive document that explains the complete CI/CD pipeline. This should specifically cover areas related to \nDocker-based deployment.\n\n\nSkills Needed\n\n\n\n\nA reasonable knowledge of how to work with Github\n\n\nA good command of English\n\n\nA clear understanding of the CI/CD pipeline\n\n\n\n\nReferences\n\n\n[1] - \nSiddhi Github repository\n\n\n[2] - \nSiddhi query guide\n -  The applicant \ncan use this to understand the Siddhi Concepts.\n\n\n[3] - \nWriting Tips\n - This guide contains the \ndocumentation guidelines we follow at WSO2.\n\n\n[4] - \nMicrosoft Style Guide\n - Download this guide to study \nglobally recognized styling standards.\n\n\nPossible Mentors\n\n\n\n\nSriskandarajah  Suhothayan (suho@wso2.com)\n\n\nChiran Fernando (chiran@wso2.com)\n\n\nRukshani Weerasinha (rukshani@wso2.com)\n\n\n\n\nProposal 2: Documentation on Event Driven Approaches\n\n\nDescription\n\n\nSiddhi is an open source cloud native stream processing engine [1]. The Siddhi engine is integrated with various other \nopen source and proprietary projects such as Apache Eagle [1], Apache Flink [2], UBER [3], Punch Platform [4], etc. \nOther than that, the Siddhi engine also plays the primary role in various WSO2 products such as WSO2 Stream Processor, \nWSO2 Data Analytics Server, WSO2 API Manager (Traffic Manager component), etc.\n\n\nSiddhi Query Language is an SQL-like query language that defines a logic for analyzing high volumes of data generated \nin high speed and in real time. Siddhi documentation [2] currently describes the Siddhi architecture, main concepts, \nfeatures, the Siddhi grammar, and how to use it.\n\n\nWe could perform extensive operations for streaming data integration purposes in Siddhi such as CDC \n(Change Data Capture), throttling and notification manager. Even though there are few resources covering these areas, \nthere is no  end-end to documentation that explains these use cases. We are expecting the applicant to understand these \nuse cases, come up with some good examples, and write a comprehensive guide around the topics mentioned.\n\n\nDeliverables\n\n\nA comprehensive document explains the below streaming data integration use cases.\n- Chance Data Capture (CDC)\n- Throttling\n- Notification Manager\n\n\nSkills Needed\n\n\n\n\nA reasonable knowledge of how to work with Github\n\n\nA good command of English\n\n\nA basic understanding of CDC, throttling and notifications\n\n\n\n\nReferences\n\n\n[1] - \nSiddhi Github repository\n\n\n[2] - \nSiddhi query guide\n -  The applicant \ncan use this to understand the Siddhi Concepts.\n\n\n[3] - \nWriting Tips\n - This guide contains the \ndocumentation guidelines we follow at WSO2.\n\n\n[4] - \nMicrosoft Style Guide\n - Download this guide to study \nglobally recognized styling standards.\n\n\nPossible Mentors\n\n\n\n\nMohandarshan Vivekanandalingam (mohan@wso2.com)\n\n\nDamith Wickramasinghe (damithn@wso2.com)\n\n\nRukshani Weerasinha (rukshani@wso2.com)\n\n\n\n\nProposal 3: Guide on Siddhi Stream Processor Monitoring\n\n\nDescription\n\n\nSiddhi is an open source cloud native stream processing engine [1]. The Siddhi engine is integrated with various other \nopen source and proprietary projects such as Apache Eagle [1], Apache Flink [2], UBER [3], Punch Platform [4],  etc. \nOther than that, the Siddhi engine also plays the primary role in various WSO2 products such as WSO2 Stream Processor, \nWSO2 Data Analytics Server, WSO2 API Manager (Traffic Manager component), etc.\n\n\nSiddhi Query Language is an SQL-like query language that defines a logic for analyzing high volumes of data generated \nin high speed and in real time. Siddhi documentation [2] currently describes the Siddhi architecture, main concepts, \nfeatures, the Siddhi grammar, and how to use it.\n\n\nMonitoring the live Siddhi Stream Processor engine is one of the key requirements of the users. At present, this \nrequirement is addressed via Prometheus that monitors Siddhi Stream Processor, allowing users to  understand the\n real live environment and take necessary actions based on the load and the TPS of the system. Currently, we need \n end to end documentation explaining these monitoring capabilities. \n\n\nDeliverables\n\n\nA comprehensive document that explains the monitoring capabilities of Siddhi Stream Processor. This documentation \nshould cover the integration use cases with Prometheus. \n\n\nSkills Needed\n\n\n\n\nA reasonable knowledge of how to work with Github\n\n\nA good command of English\n\n\nBasic knowledge of Prometheus [5]\n\n\n\n\nReferences\n\n\n[1] - \nSiddhi Github repository\n\n\n[2] - \nSiddhi query guide\n -  The applicant \ncan use this to understand the Siddhi Concepts.\n\n\n[3] - \nWriting Tips\n - This guide contains the \ndocumentation guidelines we follow at WSO2.\n\n\n[4] - \nMicrosoft Style Guide\n - Download this guide to study \nglobally recognized styling standards.\n\n\n[5] - \nPrometheus\n\n\nPossible Mentors\n\n\n\n\nTishan Dahanayakage (tishan@wso2.com)\n\n\nNiveathika Rajendran (niveathika@wso2.com )\n\n\nRukshani Weerasinha (rukshani@wso2.com)", 
            "title": "Google Season of Code 2019"
        }, 
        {
            "location": "/season-of-docs-2019/#google-season-of-docs-2019", 
            "text": "Siddhi project is excited to participate in the first Google Season of Docs program as a mentoring organization to foster \nopen source collaboration with technical writers on Siddhi documentation. We are pleased to introduce the below \nproject proposals to encourage you to participate and become a contributor in the Siddhi open source community.  If you are interested in working on any of the below projects and if you need further information, please feel free to \ncontact the mentors listed under each proposal below, or write to us via siddhi-dev@googlegroups.com .  Happy documenting with Google Season of Docs!", 
            "title": "Google Season of Docs 2019"
        }, 
        {
            "location": "/season-of-docs-2019/#proposal-1-cicd-guideline-for-siddhi-stream-processor", 
            "text": "", 
            "title": "Proposal 1: CI/CD Guideline for Siddhi Stream Processor"
        }, 
        {
            "location": "/season-of-docs-2019/#description", 
            "text": "Siddhi is an open source cloud native stream processing engine [1]. The Siddhi engine is integrated with various other \nopen source and proprietary projects such as Apache Eagle [1], Apache Flink [2], UBER [3] and Punch Platform [4] and etc. \nOther than that, the Siddhi engine also plays the primary role in various WSO2 products such as WSO2 Stream Processor, \nWSO2 Data Analytics Server, WSO2 API Manager (Traffic Manager component),  etc.  Siddhi Query Language is an SQL-like query language that defines a logic for analyzing high volumes of data generated \nin high speed and in real time. Siddhi documentation [2] currently describes the Siddhi architecture, main concepts, \nfeatures, the Siddhi grammar, and how to use it.  However, at present, we lack proper documentation to explain the complete life cycle of the CI-CD process. We need \ndetailed and comprehensive documentation that explains this process. When writing this documentation, you are also \nexpected to try out the product and gather some user experience around it and make sure that it is captured properly \nin the documentation.", 
            "title": "Description"
        }, 
        {
            "location": "/season-of-docs-2019/#deliverables", 
            "text": "A comprehensive document that explains the complete CI/CD pipeline. This should specifically cover areas related to \nDocker-based deployment.", 
            "title": "Deliverables"
        }, 
        {
            "location": "/season-of-docs-2019/#skills-needed", 
            "text": "A reasonable knowledge of how to work with Github  A good command of English  A clear understanding of the CI/CD pipeline", 
            "title": "Skills Needed"
        }, 
        {
            "location": "/season-of-docs-2019/#references", 
            "text": "[1] -  Siddhi Github repository  [2] -  Siddhi query guide  -  The applicant \ncan use this to understand the Siddhi Concepts.  [3] -  Writing Tips  - This guide contains the \ndocumentation guidelines we follow at WSO2.  [4] -  Microsoft Style Guide  - Download this guide to study \nglobally recognized styling standards.", 
            "title": "References"
        }, 
        {
            "location": "/season-of-docs-2019/#possible-mentors", 
            "text": "Sriskandarajah  Suhothayan (suho@wso2.com)  Chiran Fernando (chiran@wso2.com)  Rukshani Weerasinha (rukshani@wso2.com)", 
            "title": "Possible Mentors"
        }, 
        {
            "location": "/season-of-docs-2019/#proposal-2-documentation-on-event-driven-approaches", 
            "text": "", 
            "title": "Proposal 2: Documentation on Event Driven Approaches"
        }, 
        {
            "location": "/season-of-docs-2019/#description_1", 
            "text": "Siddhi is an open source cloud native stream processing engine [1]. The Siddhi engine is integrated with various other \nopen source and proprietary projects such as Apache Eagle [1], Apache Flink [2], UBER [3], Punch Platform [4], etc. \nOther than that, the Siddhi engine also plays the primary role in various WSO2 products such as WSO2 Stream Processor, \nWSO2 Data Analytics Server, WSO2 API Manager (Traffic Manager component), etc.  Siddhi Query Language is an SQL-like query language that defines a logic for analyzing high volumes of data generated \nin high speed and in real time. Siddhi documentation [2] currently describes the Siddhi architecture, main concepts, \nfeatures, the Siddhi grammar, and how to use it.  We could perform extensive operations for streaming data integration purposes in Siddhi such as CDC \n(Change Data Capture), throttling and notification manager. Even though there are few resources covering these areas, \nthere is no  end-end to documentation that explains these use cases. We are expecting the applicant to understand these \nuse cases, come up with some good examples, and write a comprehensive guide around the topics mentioned.", 
            "title": "Description"
        }, 
        {
            "location": "/season-of-docs-2019/#deliverables_1", 
            "text": "A comprehensive document explains the below streaming data integration use cases.\n- Chance Data Capture (CDC)\n- Throttling\n- Notification Manager", 
            "title": "Deliverables"
        }, 
        {
            "location": "/season-of-docs-2019/#skills-needed_1", 
            "text": "A reasonable knowledge of how to work with Github  A good command of English  A basic understanding of CDC, throttling and notifications", 
            "title": "Skills Needed"
        }, 
        {
            "location": "/season-of-docs-2019/#references_1", 
            "text": "[1] -  Siddhi Github repository  [2] -  Siddhi query guide  -  The applicant \ncan use this to understand the Siddhi Concepts.  [3] -  Writing Tips  - This guide contains the \ndocumentation guidelines we follow at WSO2.  [4] -  Microsoft Style Guide  - Download this guide to study \nglobally recognized styling standards.", 
            "title": "References"
        }, 
        {
            "location": "/season-of-docs-2019/#possible-mentors_1", 
            "text": "Mohandarshan Vivekanandalingam (mohan@wso2.com)  Damith Wickramasinghe (damithn@wso2.com)  Rukshani Weerasinha (rukshani@wso2.com)", 
            "title": "Possible Mentors"
        }, 
        {
            "location": "/season-of-docs-2019/#proposal-3-guide-on-siddhi-stream-processor-monitoring", 
            "text": "", 
            "title": "Proposal 3: Guide on Siddhi Stream Processor Monitoring"
        }, 
        {
            "location": "/season-of-docs-2019/#description_2", 
            "text": "Siddhi is an open source cloud native stream processing engine [1]. The Siddhi engine is integrated with various other \nopen source and proprietary projects such as Apache Eagle [1], Apache Flink [2], UBER [3], Punch Platform [4],  etc. \nOther than that, the Siddhi engine also plays the primary role in various WSO2 products such as WSO2 Stream Processor, \nWSO2 Data Analytics Server, WSO2 API Manager (Traffic Manager component), etc.  Siddhi Query Language is an SQL-like query language that defines a logic for analyzing high volumes of data generated \nin high speed and in real time. Siddhi documentation [2] currently describes the Siddhi architecture, main concepts, \nfeatures, the Siddhi grammar, and how to use it.  Monitoring the live Siddhi Stream Processor engine is one of the key requirements of the users. At present, this \nrequirement is addressed via Prometheus that monitors Siddhi Stream Processor, allowing users to  understand the\n real live environment and take necessary actions based on the load and the TPS of the system. Currently, we need \n end to end documentation explaining these monitoring capabilities.", 
            "title": "Description"
        }, 
        {
            "location": "/season-of-docs-2019/#deliverables_2", 
            "text": "A comprehensive document that explains the monitoring capabilities of Siddhi Stream Processor. This documentation \nshould cover the integration use cases with Prometheus.", 
            "title": "Deliverables"
        }, 
        {
            "location": "/season-of-docs-2019/#skills-needed_2", 
            "text": "A reasonable knowledge of how to work with Github  A good command of English  Basic knowledge of Prometheus [5]", 
            "title": "Skills Needed"
        }, 
        {
            "location": "/season-of-docs-2019/#references_2", 
            "text": "[1] -  Siddhi Github repository  [2] -  Siddhi query guide  -  The applicant \ncan use this to understand the Siddhi Concepts.  [3] -  Writing Tips  - This guide contains the \ndocumentation guidelines we follow at WSO2.  [4] -  Microsoft Style Guide  - Download this guide to study \nglobally recognized styling standards.  [5] -  Prometheus", 
            "title": "References"
        }, 
        {
            "location": "/season-of-docs-2019/#possible-mentors_2", 
            "text": "Tishan Dahanayakage (tishan@wso2.com)  Niveathika Rajendran (niveathika@wso2.com )  Rukshani Weerasinha (rukshani@wso2.com)", 
            "title": "Possible Mentors"
        }
    ]
}